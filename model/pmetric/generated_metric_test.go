// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by "model/internal/cmd/pdatagen/main.go". DO NOT EDIT.
// To regenerate this file run "go run model/internal/cmd/pdatagen/main.go".

package plog

import (
	"testing"

	"go.opentelemetry.io/collector/model/pmetric"

	"github.com/stretchr/testify/assert"

	otlpmetrics "go.opentelemetry.io/collector/model/internal/data/protogen/metrics/v1"
)

func TestResourceMetricsSlice(t *testing.T) {
	es := pmetric.NewResourceMetricsSlice()
	assert.EqualValues(t, 0, es.Len())
	es = pmetric.newResourceMetricsSlice(&[]*otlpmetrics.ResourceMetrics{})
	assert.EqualValues(t, 0, es.Len())

	es.EnsureCapacity(7)
	emptyVal := pmetric.newResourceMetrics(&otlpmetrics.ResourceMetrics{})
	testVal := generateTestResourceMetrics()
	assert.EqualValues(t, 7, cap(*es.orig))
	for i := 0; i < es.Len(); i++ {
		el := es.AppendEmpty()
		assert.EqualValues(t, emptyVal, el)
		fillTestResourceMetrics(el)
		assert.EqualValues(t, testVal, el)
	}
}

func TestResourceMetricsSlice_CopyTo(t *testing.T) {
	dest := pmetric.NewResourceMetricsSlice()
	// Test CopyTo to empty
	pmetric.NewResourceMetricsSlice().CopyTo(dest)
	assert.EqualValues(t, pmetric.NewResourceMetricsSlice(), dest)

	// Test CopyTo larger slice
	generateTestResourceMetricsSlice().CopyTo(dest)
	assert.EqualValues(t, generateTestResourceMetricsSlice(), dest)

	// Test CopyTo same size slice
	generateTestResourceMetricsSlice().CopyTo(dest)
	assert.EqualValues(t, generateTestResourceMetricsSlice(), dest)
}

func TestResourceMetricsSlice_EnsureCapacity(t *testing.T) {
	es := generateTestResourceMetricsSlice()
	// Test ensure smaller capacity.
	const ensureSmallLen = 4
	expectedEs := make(map[*otlpmetrics.ResourceMetrics]bool)
	for i := 0; i < es.Len(); i++ {
		expectedEs[es.At(i).orig] = true
	}
	assert.Equal(t, es.Len(), len(expectedEs))
	es.EnsureCapacity(ensureSmallLen)
	assert.Less(t, ensureSmallLen, es.Len())
	foundEs := make(map[*otlpmetrics.ResourceMetrics]bool, es.Len())
	for i := 0; i < es.Len(); i++ {
		foundEs[es.At(i).orig] = true
	}
	assert.EqualValues(t, expectedEs, foundEs)

	// Test ensure larger capacity
	const ensureLargeLen = 9
	oldLen := es.Len()
	expectedEs = make(map[*otlpmetrics.ResourceMetrics]bool, oldLen)
	for i := 0; i < oldLen; i++ {
		expectedEs[es.At(i).orig] = true
	}
	assert.Equal(t, oldLen, len(expectedEs))
	es.EnsureCapacity(ensureLargeLen)
	assert.Equal(t, ensureLargeLen, cap(*es.orig))
	foundEs = make(map[*otlpmetrics.ResourceMetrics]bool, oldLen)
	for i := 0; i < oldLen; i++ {
		foundEs[es.At(i).orig] = true
	}
	assert.EqualValues(t, expectedEs, foundEs)
}

func TestResourceMetricsSlice_MoveAndAppendTo(t *testing.T) {
	// Test MoveAndAppendTo to empty
	expectedSlice := generateTestResourceMetricsSlice()
	dest := pmetric.NewResourceMetricsSlice()
	src := generateTestResourceMetricsSlice()
	src.MoveAndAppendTo(dest)
	assert.EqualValues(t, generateTestResourceMetricsSlice(), dest)
	assert.EqualValues(t, 0, src.Len())
	assert.EqualValues(t, expectedSlice.Len(), dest.Len())

	// Test MoveAndAppendTo empty slice
	src.MoveAndAppendTo(dest)
	assert.EqualValues(t, generateTestResourceMetricsSlice(), dest)
	assert.EqualValues(t, 0, src.Len())
	assert.EqualValues(t, expectedSlice.Len(), dest.Len())

	// Test MoveAndAppendTo not empty slice
	generateTestResourceMetricsSlice().MoveAndAppendTo(dest)
	assert.EqualValues(t, 2*expectedSlice.Len(), dest.Len())
	for i := 0; i < expectedSlice.Len(); i++ {
		assert.EqualValues(t, expectedSlice.At(i), dest.At(i))
		assert.EqualValues(t, expectedSlice.At(i), dest.At(i+expectedSlice.Len()))
	}
}

func TestResourceMetricsSlice_RemoveIf(t *testing.T) {
	// Test RemoveIf on empty slice
	emptySlice := pmetric.NewResourceMetricsSlice()
	emptySlice.RemoveIf(func(el pmetric.ResourceMetrics) bool {
		t.Fail()
		return false
	})

	// Test RemoveIf
	filtered := generateTestResourceMetricsSlice()
	pos := 0
	filtered.RemoveIf(func(el pmetric.ResourceMetrics) bool {
		pos++
		return pos%3 == 0
	})
	assert.Equal(t, 5, filtered.Len())
}

func TestResourceMetrics_MoveTo(t *testing.T) {
	ms := generateTestResourceMetrics()
	dest := pmetric.NewResourceMetrics()
	ms.MoveTo(dest)
	assert.EqualValues(t, pmetric.NewResourceMetrics(), ms)
	assert.EqualValues(t, generateTestResourceMetrics(), dest)
}

func TestResourceMetrics_CopyTo(t *testing.T) {
	ms := pmetric.NewResourceMetrics()
	generateTestResourceMetrics().CopyTo(ms)
	assert.EqualValues(t, generateTestResourceMetrics(), ms)
}

func TestResourceMetrics_Resource(t *testing.T) {
	ms := pmetric.NewResourceMetrics()
	fillTestResource(ms.Resource())
	assert.EqualValues(t, generateTestResource(), ms.Resource())
}

func TestResourceMetrics_SchemaUrl(t *testing.T) {
	ms := pmetric.NewResourceMetrics()
	assert.EqualValues(t, "", ms.SchemaUrl())
	testValSchemaUrl := "https://opentelemetry.io/schemas/1.5.0"
	ms.SetSchemaUrl(testValSchemaUrl)
	assert.EqualValues(t, testValSchemaUrl, ms.SchemaUrl())
}

func TestResourceMetrics_InstrumentationLibraryMetrics(t *testing.T) {
	ms := pmetric.NewResourceMetrics()
	assert.EqualValues(t, pmetric.NewInstrumentationLibraryMetricsSlice(), ms.InstrumentationLibraryMetrics())
	fillTestInstrumentationLibraryMetricsSlice(ms.InstrumentationLibraryMetrics())
	testValInstrumentationLibraryMetrics := generateTestInstrumentationLibraryMetricsSlice()
	assert.EqualValues(t, testValInstrumentationLibraryMetrics, ms.InstrumentationLibraryMetrics())
}

func TestInstrumentationLibraryMetricsSlice(t *testing.T) {
	es := pmetric.NewInstrumentationLibraryMetricsSlice()
	assert.EqualValues(t, 0, es.Len())
	es = pmetric.newInstrumentationLibraryMetricsSlice(&[]*otlpmetrics.InstrumentationLibraryMetrics{})
	assert.EqualValues(t, 0, es.Len())

	es.EnsureCapacity(7)
	emptyVal := pmetric.newInstrumentationLibraryMetrics(&otlpmetrics.InstrumentationLibraryMetrics{})
	testVal := generateTestInstrumentationLibraryMetrics()
	assert.EqualValues(t, 7, cap(*es.orig))
	for i := 0; i < es.Len(); i++ {
		el := es.AppendEmpty()
		assert.EqualValues(t, emptyVal, el)
		fillTestInstrumentationLibraryMetrics(el)
		assert.EqualValues(t, testVal, el)
	}
}

func TestInstrumentationLibraryMetricsSlice_CopyTo(t *testing.T) {
	dest := pmetric.NewInstrumentationLibraryMetricsSlice()
	// Test CopyTo to empty
	pmetric.NewInstrumentationLibraryMetricsSlice().CopyTo(dest)
	assert.EqualValues(t, pmetric.NewInstrumentationLibraryMetricsSlice(), dest)

	// Test CopyTo larger slice
	generateTestInstrumentationLibraryMetricsSlice().CopyTo(dest)
	assert.EqualValues(t, generateTestInstrumentationLibraryMetricsSlice(), dest)

	// Test CopyTo same size slice
	generateTestInstrumentationLibraryMetricsSlice().CopyTo(dest)
	assert.EqualValues(t, generateTestInstrumentationLibraryMetricsSlice(), dest)
}

func TestInstrumentationLibraryMetricsSlice_EnsureCapacity(t *testing.T) {
	es := generateTestInstrumentationLibraryMetricsSlice()
	// Test ensure smaller capacity.
	const ensureSmallLen = 4
	expectedEs := make(map[*otlpmetrics.InstrumentationLibraryMetrics]bool)
	for i := 0; i < es.Len(); i++ {
		expectedEs[es.At(i).orig] = true
	}
	assert.Equal(t, es.Len(), len(expectedEs))
	es.EnsureCapacity(ensureSmallLen)
	assert.Less(t, ensureSmallLen, es.Len())
	foundEs := make(map[*otlpmetrics.InstrumentationLibraryMetrics]bool, es.Len())
	for i := 0; i < es.Len(); i++ {
		foundEs[es.At(i).orig] = true
	}
	assert.EqualValues(t, expectedEs, foundEs)

	// Test ensure larger capacity
	const ensureLargeLen = 9
	oldLen := es.Len()
	expectedEs = make(map[*otlpmetrics.InstrumentationLibraryMetrics]bool, oldLen)
	for i := 0; i < oldLen; i++ {
		expectedEs[es.At(i).orig] = true
	}
	assert.Equal(t, oldLen, len(expectedEs))
	es.EnsureCapacity(ensureLargeLen)
	assert.Equal(t, ensureLargeLen, cap(*es.orig))
	foundEs = make(map[*otlpmetrics.InstrumentationLibraryMetrics]bool, oldLen)
	for i := 0; i < oldLen; i++ {
		foundEs[es.At(i).orig] = true
	}
	assert.EqualValues(t, expectedEs, foundEs)
}

func TestInstrumentationLibraryMetricsSlice_MoveAndAppendTo(t *testing.T) {
	// Test MoveAndAppendTo to empty
	expectedSlice := generateTestInstrumentationLibraryMetricsSlice()
	dest := pmetric.NewInstrumentationLibraryMetricsSlice()
	src := generateTestInstrumentationLibraryMetricsSlice()
	src.MoveAndAppendTo(dest)
	assert.EqualValues(t, generateTestInstrumentationLibraryMetricsSlice(), dest)
	assert.EqualValues(t, 0, src.Len())
	assert.EqualValues(t, expectedSlice.Len(), dest.Len())

	// Test MoveAndAppendTo empty slice
	src.MoveAndAppendTo(dest)
	assert.EqualValues(t, generateTestInstrumentationLibraryMetricsSlice(), dest)
	assert.EqualValues(t, 0, src.Len())
	assert.EqualValues(t, expectedSlice.Len(), dest.Len())

	// Test MoveAndAppendTo not empty slice
	generateTestInstrumentationLibraryMetricsSlice().MoveAndAppendTo(dest)
	assert.EqualValues(t, 2*expectedSlice.Len(), dest.Len())
	for i := 0; i < expectedSlice.Len(); i++ {
		assert.EqualValues(t, expectedSlice.At(i), dest.At(i))
		assert.EqualValues(t, expectedSlice.At(i), dest.At(i+expectedSlice.Len()))
	}
}

func TestInstrumentationLibraryMetricsSlice_RemoveIf(t *testing.T) {
	// Test RemoveIf on empty slice
	emptySlice := pmetric.NewInstrumentationLibraryMetricsSlice()
	emptySlice.RemoveIf(func(el pmetric.InstrumentationLibraryMetrics) bool {
		t.Fail()
		return false
	})

	// Test RemoveIf
	filtered := generateTestInstrumentationLibraryMetricsSlice()
	pos := 0
	filtered.RemoveIf(func(el pmetric.InstrumentationLibraryMetrics) bool {
		pos++
		return pos%3 == 0
	})
	assert.Equal(t, 5, filtered.Len())
}

func TestInstrumentationLibraryMetrics_MoveTo(t *testing.T) {
	ms := generateTestInstrumentationLibraryMetrics()
	dest := pmetric.NewInstrumentationLibraryMetrics()
	ms.MoveTo(dest)
	assert.EqualValues(t, pmetric.NewInstrumentationLibraryMetrics(), ms)
	assert.EqualValues(t, generateTestInstrumentationLibraryMetrics(), dest)
}

func TestInstrumentationLibraryMetrics_CopyTo(t *testing.T) {
	ms := pmetric.NewInstrumentationLibraryMetrics()
	generateTestInstrumentationLibraryMetrics().CopyTo(ms)
	assert.EqualValues(t, generateTestInstrumentationLibraryMetrics(), ms)
}

func TestInstrumentationLibraryMetrics_InstrumentationLibrary(t *testing.T) {
	ms := pmetric.NewInstrumentationLibraryMetrics()
	pcommon.fillTestInstrumentationLibrary(ms.InstrumentationLibrary())
	assert.EqualValues(t, pcommon.generateTestInstrumentationLibrary(), ms.InstrumentationLibrary())
}

func TestInstrumentationLibraryMetrics_SchemaUrl(t *testing.T) {
	ms := pmetric.NewInstrumentationLibraryMetrics()
	assert.EqualValues(t, "", ms.SchemaUrl())
	testValSchemaUrl := "https://opentelemetry.io/schemas/1.5.0"
	ms.SetSchemaUrl(testValSchemaUrl)
	assert.EqualValues(t, testValSchemaUrl, ms.SchemaUrl())
}

func TestInstrumentationLibraryMetrics_Metrics(t *testing.T) {
	ms := pmetric.NewInstrumentationLibraryMetrics()
	assert.EqualValues(t, pmetric.NewMetricSlice(), ms.Metrics())
	fillTestMetricSlice(ms.Metrics())
	testValMetrics := generateTestMetricSlice()
	assert.EqualValues(t, testValMetrics, ms.Metrics())
}

func TestMetricSlice(t *testing.T) {
	es := pmetric.NewMetricSlice()
	assert.EqualValues(t, 0, es.Len())
	es = pmetric.newMetricSlice(&[]*otlpmetrics.Metric{})
	assert.EqualValues(t, 0, es.Len())

	es.EnsureCapacity(7)
	emptyVal := pmetric.newMetric(&otlpmetrics.Metric{})
	testVal := generateTestMetric()
	assert.EqualValues(t, 7, cap(*es.orig))
	for i := 0; i < es.Len(); i++ {
		el := es.AppendEmpty()
		assert.EqualValues(t, emptyVal, el)
		fillTestMetric(el)
		assert.EqualValues(t, testVal, el)
	}
}

func TestMetricSlice_CopyTo(t *testing.T) {
	dest := pmetric.NewMetricSlice()
	// Test CopyTo to empty
	pmetric.NewMetricSlice().CopyTo(dest)
	assert.EqualValues(t, pmetric.NewMetricSlice(), dest)

	// Test CopyTo larger slice
	generateTestMetricSlice().CopyTo(dest)
	assert.EqualValues(t, generateTestMetricSlice(), dest)

	// Test CopyTo same size slice
	generateTestMetricSlice().CopyTo(dest)
	assert.EqualValues(t, generateTestMetricSlice(), dest)
}

func TestMetricSlice_EnsureCapacity(t *testing.T) {
	es := generateTestMetricSlice()
	// Test ensure smaller capacity.
	const ensureSmallLen = 4
	expectedEs := make(map[*otlpmetrics.Metric]bool)
	for i := 0; i < es.Len(); i++ {
		expectedEs[es.At(i).orig] = true
	}
	assert.Equal(t, es.Len(), len(expectedEs))
	es.EnsureCapacity(ensureSmallLen)
	assert.Less(t, ensureSmallLen, es.Len())
	foundEs := make(map[*otlpmetrics.Metric]bool, es.Len())
	for i := 0; i < es.Len(); i++ {
		foundEs[es.At(i).orig] = true
	}
	assert.EqualValues(t, expectedEs, foundEs)

	// Test ensure larger capacity
	const ensureLargeLen = 9
	oldLen := es.Len()
	expectedEs = make(map[*otlpmetrics.Metric]bool, oldLen)
	for i := 0; i < oldLen; i++ {
		expectedEs[es.At(i).orig] = true
	}
	assert.Equal(t, oldLen, len(expectedEs))
	es.EnsureCapacity(ensureLargeLen)
	assert.Equal(t, ensureLargeLen, cap(*es.orig))
	foundEs = make(map[*otlpmetrics.Metric]bool, oldLen)
	for i := 0; i < oldLen; i++ {
		foundEs[es.At(i).orig] = true
	}
	assert.EqualValues(t, expectedEs, foundEs)
}

func TestMetricSlice_MoveAndAppendTo(t *testing.T) {
	// Test MoveAndAppendTo to empty
	expectedSlice := generateTestMetricSlice()
	dest := pmetric.NewMetricSlice()
	src := generateTestMetricSlice()
	src.MoveAndAppendTo(dest)
	assert.EqualValues(t, generateTestMetricSlice(), dest)
	assert.EqualValues(t, 0, src.Len())
	assert.EqualValues(t, expectedSlice.Len(), dest.Len())

	// Test MoveAndAppendTo empty slice
	src.MoveAndAppendTo(dest)
	assert.EqualValues(t, generateTestMetricSlice(), dest)
	assert.EqualValues(t, 0, src.Len())
	assert.EqualValues(t, expectedSlice.Len(), dest.Len())

	// Test MoveAndAppendTo not empty slice
	generateTestMetricSlice().MoveAndAppendTo(dest)
	assert.EqualValues(t, 2*expectedSlice.Len(), dest.Len())
	for i := 0; i < expectedSlice.Len(); i++ {
		assert.EqualValues(t, expectedSlice.At(i), dest.At(i))
		assert.EqualValues(t, expectedSlice.At(i), dest.At(i+expectedSlice.Len()))
	}
}

func TestMetricSlice_RemoveIf(t *testing.T) {
	// Test RemoveIf on empty slice
	emptySlice := pmetric.NewMetricSlice()
	emptySlice.RemoveIf(func(el pmetric.Metric) bool {
		t.Fail()
		return false
	})

	// Test RemoveIf
	filtered := generateTestMetricSlice()
	pos := 0
	filtered.RemoveIf(func(el pmetric.Metric) bool {
		pos++
		return pos%3 == 0
	})
	assert.Equal(t, 5, filtered.Len())
}

func TestMetric_MoveTo(t *testing.T) {
	ms := generateTestMetric()
	dest := pmetric.NewMetric()
	ms.MoveTo(dest)
	assert.EqualValues(t, pmetric.NewMetric(), ms)
	assert.EqualValues(t, generateTestMetric(), dest)
}

func TestMetric_CopyTo(t *testing.T) {
	ms := pmetric.NewMetric()
	generateTestMetric().CopyTo(ms)
	assert.EqualValues(t, generateTestMetric(), ms)
}

func TestMetric_Name(t *testing.T) {
	ms := pmetric.NewMetric()
	assert.EqualValues(t, "", ms.Name())
	testValName := "test_name"
	ms.SetName(testValName)
	assert.EqualValues(t, testValName, ms.Name())
}

func TestMetric_Description(t *testing.T) {
	ms := pmetric.NewMetric()
	assert.EqualValues(t, "", ms.Description())
	testValDescription := "test_description"
	ms.SetDescription(testValDescription)
	assert.EqualValues(t, testValDescription, ms.Description())
}

func TestMetric_Unit(t *testing.T) {
	ms := pmetric.NewMetric()
	assert.EqualValues(t, "", ms.Unit())
	testValUnit := "1"
	ms.SetUnit(testValUnit)
	assert.EqualValues(t, testValUnit, ms.Unit())
}

func TestMetricDataType(t *testing.T) {
	tv := pmetric.NewMetric()
	assert.Equal(t, pmetric.MetricDataTypeNone, tv.DataType())
	assert.Equal(t, "", pmetric.MetricDataType(1000).String())
	tv.SetDataType(pmetric.MetricDataTypeGauge)
	fillTestGauge(tv.Gauge())
	assert.Equal(t, pmetric.MetricDataTypeGauge, tv.DataType())
	tv.SetDataType(pmetric.MetricDataTypeSum)
	fillTestSum(tv.Sum())
	assert.Equal(t, pmetric.MetricDataTypeSum, tv.DataType())
	tv.SetDataType(pmetric.MetricDataTypeHistogram)
	fillTestHistogram(tv.Histogram())
	assert.Equal(t, pmetric.MetricDataTypeHistogram, tv.DataType())
	tv.SetDataType(pmetric.MetricDataTypeExponentialHistogram)
	fillTestExponentialHistogram(tv.ExponentialHistogram())
	assert.Equal(t, pmetric.MetricDataTypeExponentialHistogram, tv.DataType())
	tv.SetDataType(pmetric.MetricDataTypeSummary)
	fillTestSummary(tv.Summary())
	assert.Equal(t, pmetric.MetricDataTypeSummary, tv.DataType())
}

func TestMetric_Gauge(t *testing.T) {
	ms := pmetric.NewMetric()
	ms.SetDataType(pmetric.MetricDataTypeGauge)
	fillTestGauge(ms.Gauge())
	assert.EqualValues(t, generateTestGauge(), ms.Gauge())
}

func TestMetric_CopyTo_Gauge(t *testing.T) {
	ms := pmetric.NewMetric()
	ms.SetDataType(pmetric.MetricDataTypeGauge)
	fillTestGauge(ms.Gauge())
	dest := pmetric.NewMetric()
	ms.CopyTo(dest)
	assert.EqualValues(t, ms, dest)
}

func TestMetric_Sum(t *testing.T) {
	ms := pmetric.NewMetric()
	ms.SetDataType(pmetric.MetricDataTypeSum)
	fillTestSum(ms.Sum())
	assert.EqualValues(t, generateTestSum(), ms.Sum())
}

func TestMetric_CopyTo_Sum(t *testing.T) {
	ms := pmetric.NewMetric()
	ms.SetDataType(pmetric.MetricDataTypeSum)
	fillTestSum(ms.Sum())
	dest := pmetric.NewMetric()
	ms.CopyTo(dest)
	assert.EqualValues(t, ms, dest)
}

func TestMetric_Histogram(t *testing.T) {
	ms := pmetric.NewMetric()
	ms.SetDataType(pmetric.MetricDataTypeHistogram)
	fillTestHistogram(ms.Histogram())
	assert.EqualValues(t, generateTestHistogram(), ms.Histogram())
}

func TestMetric_CopyTo_Histogram(t *testing.T) {
	ms := pmetric.NewMetric()
	ms.SetDataType(pmetric.MetricDataTypeHistogram)
	fillTestHistogram(ms.Histogram())
	dest := pmetric.NewMetric()
	ms.CopyTo(dest)
	assert.EqualValues(t, ms, dest)
}

func TestMetric_ExponentialHistogram(t *testing.T) {
	ms := pmetric.NewMetric()
	ms.SetDataType(pmetric.MetricDataTypeExponentialHistogram)
	fillTestExponentialHistogram(ms.ExponentialHistogram())
	assert.EqualValues(t, generateTestExponentialHistogram(), ms.ExponentialHistogram())
}

func TestMetric_CopyTo_ExponentialHistogram(t *testing.T) {
	ms := pmetric.NewMetric()
	ms.SetDataType(pmetric.MetricDataTypeExponentialHistogram)
	fillTestExponentialHistogram(ms.ExponentialHistogram())
	dest := pmetric.NewMetric()
	ms.CopyTo(dest)
	assert.EqualValues(t, ms, dest)
}

func TestMetric_Summary(t *testing.T) {
	ms := pmetric.NewMetric()
	ms.SetDataType(pmetric.MetricDataTypeSummary)
	fillTestSummary(ms.Summary())
	assert.EqualValues(t, generateTestSummary(), ms.Summary())
}

func TestMetric_CopyTo_Summary(t *testing.T) {
	ms := pmetric.NewMetric()
	ms.SetDataType(pmetric.MetricDataTypeSummary)
	fillTestSummary(ms.Summary())
	dest := pmetric.NewMetric()
	ms.CopyTo(dest)
	assert.EqualValues(t, ms, dest)
}

func TestGauge_MoveTo(t *testing.T) {
	ms := generateTestGauge()
	dest := pmetric.NewGauge()
	ms.MoveTo(dest)
	assert.EqualValues(t, pmetric.NewGauge(), ms)
	assert.EqualValues(t, generateTestGauge(), dest)
}

func TestGauge_CopyTo(t *testing.T) {
	ms := pmetric.NewGauge()
	generateTestGauge().CopyTo(ms)
	assert.EqualValues(t, generateTestGauge(), ms)
}

func TestGauge_DataPoints(t *testing.T) {
	ms := pmetric.NewGauge()
	assert.EqualValues(t, pmetric.NewNumberDataPointSlice(), ms.DataPoints())
	fillTestNumberDataPointSlice(ms.DataPoints())
	testValDataPoints := generateTestNumberDataPointSlice()
	assert.EqualValues(t, testValDataPoints, ms.DataPoints())
}

func TestSum_MoveTo(t *testing.T) {
	ms := generateTestSum()
	dest := pmetric.NewSum()
	ms.MoveTo(dest)
	assert.EqualValues(t, pmetric.NewSum(), ms)
	assert.EqualValues(t, generateTestSum(), dest)
}

func TestSum_CopyTo(t *testing.T) {
	ms := pmetric.NewSum()
	generateTestSum().CopyTo(ms)
	assert.EqualValues(t, generateTestSum(), ms)
}

func TestSum_AggregationTemporality(t *testing.T) {
	ms := pmetric.NewSum()
	assert.EqualValues(t, pmetric.MetricAggregationTemporalityUnspecified, ms.AggregationTemporality())
	testValAggregationTemporality := pmetric.MetricAggregationTemporalityCumulative
	ms.SetAggregationTemporality(testValAggregationTemporality)
	assert.EqualValues(t, testValAggregationTemporality, ms.AggregationTemporality())
}

func TestSum_IsMonotonic(t *testing.T) {
	ms := pmetric.NewSum()
	assert.EqualValues(t, false, ms.IsMonotonic())
	testValIsMonotonic := true
	ms.SetIsMonotonic(testValIsMonotonic)
	assert.EqualValues(t, testValIsMonotonic, ms.IsMonotonic())
}

func TestSum_DataPoints(t *testing.T) {
	ms := pmetric.NewSum()
	assert.EqualValues(t, pmetric.NewNumberDataPointSlice(), ms.DataPoints())
	fillTestNumberDataPointSlice(ms.DataPoints())
	testValDataPoints := generateTestNumberDataPointSlice()
	assert.EqualValues(t, testValDataPoints, ms.DataPoints())
}

func TestHistogram_MoveTo(t *testing.T) {
	ms := generateTestHistogram()
	dest := pmetric.NewHistogram()
	ms.MoveTo(dest)
	assert.EqualValues(t, pmetric.NewHistogram(), ms)
	assert.EqualValues(t, generateTestHistogram(), dest)
}

func TestHistogram_CopyTo(t *testing.T) {
	ms := pmetric.NewHistogram()
	generateTestHistogram().CopyTo(ms)
	assert.EqualValues(t, generateTestHistogram(), ms)
}

func TestHistogram_AggregationTemporality(t *testing.T) {
	ms := pmetric.NewHistogram()
	assert.EqualValues(t, pmetric.MetricAggregationTemporalityUnspecified, ms.AggregationTemporality())
	testValAggregationTemporality := pmetric.MetricAggregationTemporalityCumulative
	ms.SetAggregationTemporality(testValAggregationTemporality)
	assert.EqualValues(t, testValAggregationTemporality, ms.AggregationTemporality())
}

func TestHistogram_DataPoints(t *testing.T) {
	ms := pmetric.NewHistogram()
	assert.EqualValues(t, pmetric.NewHistogramDataPointSlice(), ms.DataPoints())
	fillTestHistogramDataPointSlice(ms.DataPoints())
	testValDataPoints := generateTestHistogramDataPointSlice()
	assert.EqualValues(t, testValDataPoints, ms.DataPoints())
}

func TestExponentialHistogram_MoveTo(t *testing.T) {
	ms := generateTestExponentialHistogram()
	dest := pmetric.NewExponentialHistogram()
	ms.MoveTo(dest)
	assert.EqualValues(t, pmetric.NewExponentialHistogram(), ms)
	assert.EqualValues(t, generateTestExponentialHistogram(), dest)
}

func TestExponentialHistogram_CopyTo(t *testing.T) {
	ms := pmetric.NewExponentialHistogram()
	generateTestExponentialHistogram().CopyTo(ms)
	assert.EqualValues(t, generateTestExponentialHistogram(), ms)
}

func TestExponentialHistogram_AggregationTemporality(t *testing.T) {
	ms := pmetric.NewExponentialHistogram()
	assert.EqualValues(t, pmetric.MetricAggregationTemporalityUnspecified, ms.AggregationTemporality())
	testValAggregationTemporality := pmetric.MetricAggregationTemporalityCumulative
	ms.SetAggregationTemporality(testValAggregationTemporality)
	assert.EqualValues(t, testValAggregationTemporality, ms.AggregationTemporality())
}

func TestExponentialHistogram_DataPoints(t *testing.T) {
	ms := pmetric.NewExponentialHistogram()
	assert.EqualValues(t, pmetric.NewExponentialHistogramDataPointSlice(), ms.DataPoints())
	fillTestExponentialHistogramDataPointSlice(ms.DataPoints())
	testValDataPoints := generateTestExponentialHistogramDataPointSlice()
	assert.EqualValues(t, testValDataPoints, ms.DataPoints())
}

func TestSummary_MoveTo(t *testing.T) {
	ms := generateTestSummary()
	dest := pmetric.NewSummary()
	ms.MoveTo(dest)
	assert.EqualValues(t, pmetric.NewSummary(), ms)
	assert.EqualValues(t, generateTestSummary(), dest)
}

func TestSummary_CopyTo(t *testing.T) {
	ms := pmetric.NewSummary()
	generateTestSummary().CopyTo(ms)
	assert.EqualValues(t, generateTestSummary(), ms)
}

func TestSummary_DataPoints(t *testing.T) {
	ms := pmetric.NewSummary()
	assert.EqualValues(t, pmetric.NewSummaryDataPointSlice(), ms.DataPoints())
	fillTestSummaryDataPointSlice(ms.DataPoints())
	testValDataPoints := generateTestSummaryDataPointSlice()
	assert.EqualValues(t, testValDataPoints, ms.DataPoints())
}

func TestNumberDataPointSlice(t *testing.T) {
	es := pmetric.NewNumberDataPointSlice()
	assert.EqualValues(t, 0, es.Len())
	es = pmetric.newNumberDataPointSlice(&[]*otlpmetrics.NumberDataPoint{})
	assert.EqualValues(t, 0, es.Len())

	es.EnsureCapacity(7)
	emptyVal := pmetric.newNumberDataPoint(&otlpmetrics.NumberDataPoint{})
	testVal := generateTestNumberDataPoint()
	assert.EqualValues(t, 7, cap(*es.orig))
	for i := 0; i < es.Len(); i++ {
		el := es.AppendEmpty()
		assert.EqualValues(t, emptyVal, el)
		fillTestNumberDataPoint(el)
		assert.EqualValues(t, testVal, el)
	}
}

func TestNumberDataPointSlice_CopyTo(t *testing.T) {
	dest := pmetric.NewNumberDataPointSlice()
	// Test CopyTo to empty
	pmetric.NewNumberDataPointSlice().CopyTo(dest)
	assert.EqualValues(t, pmetric.NewNumberDataPointSlice(), dest)

	// Test CopyTo larger slice
	generateTestNumberDataPointSlice().CopyTo(dest)
	assert.EqualValues(t, generateTestNumberDataPointSlice(), dest)

	// Test CopyTo same size slice
	generateTestNumberDataPointSlice().CopyTo(dest)
	assert.EqualValues(t, generateTestNumberDataPointSlice(), dest)
}

func TestNumberDataPointSlice_EnsureCapacity(t *testing.T) {
	es := generateTestNumberDataPointSlice()
	// Test ensure smaller capacity.
	const ensureSmallLen = 4
	expectedEs := make(map[*otlpmetrics.NumberDataPoint]bool)
	for i := 0; i < es.Len(); i++ {
		expectedEs[es.At(i).orig] = true
	}
	assert.Equal(t, es.Len(), len(expectedEs))
	es.EnsureCapacity(ensureSmallLen)
	assert.Less(t, ensureSmallLen, es.Len())
	foundEs := make(map[*otlpmetrics.NumberDataPoint]bool, es.Len())
	for i := 0; i < es.Len(); i++ {
		foundEs[es.At(i).orig] = true
	}
	assert.EqualValues(t, expectedEs, foundEs)

	// Test ensure larger capacity
	const ensureLargeLen = 9
	oldLen := es.Len()
	expectedEs = make(map[*otlpmetrics.NumberDataPoint]bool, oldLen)
	for i := 0; i < oldLen; i++ {
		expectedEs[es.At(i).orig] = true
	}
	assert.Equal(t, oldLen, len(expectedEs))
	es.EnsureCapacity(ensureLargeLen)
	assert.Equal(t, ensureLargeLen, cap(*es.orig))
	foundEs = make(map[*otlpmetrics.NumberDataPoint]bool, oldLen)
	for i := 0; i < oldLen; i++ {
		foundEs[es.At(i).orig] = true
	}
	assert.EqualValues(t, expectedEs, foundEs)
}

func TestNumberDataPointSlice_MoveAndAppendTo(t *testing.T) {
	// Test MoveAndAppendTo to empty
	expectedSlice := generateTestNumberDataPointSlice()
	dest := pmetric.NewNumberDataPointSlice()
	src := generateTestNumberDataPointSlice()
	src.MoveAndAppendTo(dest)
	assert.EqualValues(t, generateTestNumberDataPointSlice(), dest)
	assert.EqualValues(t, 0, src.Len())
	assert.EqualValues(t, expectedSlice.Len(), dest.Len())

	// Test MoveAndAppendTo empty slice
	src.MoveAndAppendTo(dest)
	assert.EqualValues(t, generateTestNumberDataPointSlice(), dest)
	assert.EqualValues(t, 0, src.Len())
	assert.EqualValues(t, expectedSlice.Len(), dest.Len())

	// Test MoveAndAppendTo not empty slice
	generateTestNumberDataPointSlice().MoveAndAppendTo(dest)
	assert.EqualValues(t, 2*expectedSlice.Len(), dest.Len())
	for i := 0; i < expectedSlice.Len(); i++ {
		assert.EqualValues(t, expectedSlice.At(i), dest.At(i))
		assert.EqualValues(t, expectedSlice.At(i), dest.At(i+expectedSlice.Len()))
	}
}

func TestNumberDataPointSlice_RemoveIf(t *testing.T) {
	// Test RemoveIf on empty slice
	emptySlice := pmetric.NewNumberDataPointSlice()
	emptySlice.RemoveIf(func(el pmetric.NumberDataPoint) bool {
		t.Fail()
		return false
	})

	// Test RemoveIf
	filtered := generateTestNumberDataPointSlice()
	pos := 0
	filtered.RemoveIf(func(el pmetric.NumberDataPoint) bool {
		pos++
		return pos%3 == 0
	})
	assert.Equal(t, 5, filtered.Len())
}

func TestNumberDataPoint_MoveTo(t *testing.T) {
	ms := generateTestNumberDataPoint()
	dest := pmetric.NewNumberDataPoint()
	ms.MoveTo(dest)
	assert.EqualValues(t, pmetric.NewNumberDataPoint(), ms)
	assert.EqualValues(t, generateTestNumberDataPoint(), dest)
}

func TestNumberDataPoint_CopyTo(t *testing.T) {
	ms := pmetric.NewNumberDataPoint()
	generateTestNumberDataPoint().CopyTo(ms)
	assert.EqualValues(t, generateTestNumberDataPoint(), ms)
}

func TestNumberDataPoint_Attributes(t *testing.T) {
	ms := pmetric.NewNumberDataPoint()
	assert.EqualValues(t, NewAttributeMap(), ms.Attributes())
	pcommon.fillTestAttributeMap(ms.Attributes())
	testValAttributes := pcommon.generateTestAttributeMap()
	assert.EqualValues(t, testValAttributes, ms.Attributes())
}

func TestNumberDataPoint_StartTimestamp(t *testing.T) {
	ms := pmetric.NewNumberDataPoint()
	assert.EqualValues(t, Timestamp(0), ms.StartTimestamp())
	testValStartTimestamp := Timestamp(1234567890)
	ms.SetStartTimestamp(testValStartTimestamp)
	assert.EqualValues(t, testValStartTimestamp, ms.StartTimestamp())
}

func TestNumberDataPoint_Timestamp(t *testing.T) {
	ms := pmetric.NewNumberDataPoint()
	assert.EqualValues(t, Timestamp(0), ms.Timestamp())
	testValTimestamp := Timestamp(1234567890)
	ms.SetTimestamp(testValTimestamp)
	assert.EqualValues(t, testValTimestamp, ms.Timestamp())
}

func TestNumberDataPointValueType(t *testing.T) {
	tv := pmetric.NewNumberDataPoint()
	assert.Equal(t, pmetric.MetricValueTypeNone, tv.ValueType())
	assert.Equal(t, "", pmetric.MetricValueType(1000).String())
	tv.SetDoubleVal(float64(17.13))
	assert.Equal(t, pmetric.MetricValueTypeDouble, tv.ValueType())
	tv.SetIntVal(int64(17))
	assert.Equal(t, pmetric.MetricValueTypeInt, tv.ValueType())
}

func TestNumberDataPoint_DoubleVal(t *testing.T) {
	ms := pmetric.NewNumberDataPoint()
	assert.EqualValues(t, float64(0.0), ms.DoubleVal())
	testValDoubleVal := float64(17.13)
	ms.SetDoubleVal(testValDoubleVal)
	assert.EqualValues(t, testValDoubleVal, ms.DoubleVal())
}

func TestNumberDataPoint_IntVal(t *testing.T) {
	ms := pmetric.NewNumberDataPoint()
	assert.EqualValues(t, int64(0), ms.IntVal())
	testValIntVal := int64(17)
	ms.SetIntVal(testValIntVal)
	assert.EqualValues(t, testValIntVal, ms.IntVal())
}

func TestNumberDataPoint_Exemplars(t *testing.T) {
	ms := pmetric.NewNumberDataPoint()
	assert.EqualValues(t, pmetric.NewExemplarSlice(), ms.Exemplars())
	fillTestExemplarSlice(ms.Exemplars())
	testValExemplars := generateTestExemplarSlice()
	assert.EqualValues(t, testValExemplars, ms.Exemplars())
}

func TestNumberDataPoint_Flags(t *testing.T) {
	ms := pmetric.NewNumberDataPoint()
	assert.EqualValues(t, pmetric.MetricDataPointFlagsNone, ms.Flags())
	testValFlags := pmetric.MetricDataPointFlagsNone
	ms.SetFlags(testValFlags)
	assert.EqualValues(t, testValFlags, ms.Flags())
}

func TestHistogramDataPointSlice(t *testing.T) {
	es := pmetric.NewHistogramDataPointSlice()
	assert.EqualValues(t, 0, es.Len())
	es = pmetric.newHistogramDataPointSlice(&[]*otlpmetrics.HistogramDataPoint{})
	assert.EqualValues(t, 0, es.Len())

	es.EnsureCapacity(7)
	emptyVal := pmetric.newHistogramDataPoint(&otlpmetrics.HistogramDataPoint{})
	testVal := generateTestHistogramDataPoint()
	assert.EqualValues(t, 7, cap(*es.orig))
	for i := 0; i < es.Len(); i++ {
		el := es.AppendEmpty()
		assert.EqualValues(t, emptyVal, el)
		fillTestHistogramDataPoint(el)
		assert.EqualValues(t, testVal, el)
	}
}

func TestHistogramDataPointSlice_CopyTo(t *testing.T) {
	dest := pmetric.NewHistogramDataPointSlice()
	// Test CopyTo to empty
	pmetric.NewHistogramDataPointSlice().CopyTo(dest)
	assert.EqualValues(t, pmetric.NewHistogramDataPointSlice(), dest)

	// Test CopyTo larger slice
	generateTestHistogramDataPointSlice().CopyTo(dest)
	assert.EqualValues(t, generateTestHistogramDataPointSlice(), dest)

	// Test CopyTo same size slice
	generateTestHistogramDataPointSlice().CopyTo(dest)
	assert.EqualValues(t, generateTestHistogramDataPointSlice(), dest)
}

func TestHistogramDataPointSlice_EnsureCapacity(t *testing.T) {
	es := generateTestHistogramDataPointSlice()
	// Test ensure smaller capacity.
	const ensureSmallLen = 4
	expectedEs := make(map[*otlpmetrics.HistogramDataPoint]bool)
	for i := 0; i < es.Len(); i++ {
		expectedEs[es.At(i).orig] = true
	}
	assert.Equal(t, es.Len(), len(expectedEs))
	es.EnsureCapacity(ensureSmallLen)
	assert.Less(t, ensureSmallLen, es.Len())
	foundEs := make(map[*otlpmetrics.HistogramDataPoint]bool, es.Len())
	for i := 0; i < es.Len(); i++ {
		foundEs[es.At(i).orig] = true
	}
	assert.EqualValues(t, expectedEs, foundEs)

	// Test ensure larger capacity
	const ensureLargeLen = 9
	oldLen := es.Len()
	expectedEs = make(map[*otlpmetrics.HistogramDataPoint]bool, oldLen)
	for i := 0; i < oldLen; i++ {
		expectedEs[es.At(i).orig] = true
	}
	assert.Equal(t, oldLen, len(expectedEs))
	es.EnsureCapacity(ensureLargeLen)
	assert.Equal(t, ensureLargeLen, cap(*es.orig))
	foundEs = make(map[*otlpmetrics.HistogramDataPoint]bool, oldLen)
	for i := 0; i < oldLen; i++ {
		foundEs[es.At(i).orig] = true
	}
	assert.EqualValues(t, expectedEs, foundEs)
}

func TestHistogramDataPointSlice_MoveAndAppendTo(t *testing.T) {
	// Test MoveAndAppendTo to empty
	expectedSlice := generateTestHistogramDataPointSlice()
	dest := pmetric.NewHistogramDataPointSlice()
	src := generateTestHistogramDataPointSlice()
	src.MoveAndAppendTo(dest)
	assert.EqualValues(t, generateTestHistogramDataPointSlice(), dest)
	assert.EqualValues(t, 0, src.Len())
	assert.EqualValues(t, expectedSlice.Len(), dest.Len())

	// Test MoveAndAppendTo empty slice
	src.MoveAndAppendTo(dest)
	assert.EqualValues(t, generateTestHistogramDataPointSlice(), dest)
	assert.EqualValues(t, 0, src.Len())
	assert.EqualValues(t, expectedSlice.Len(), dest.Len())

	// Test MoveAndAppendTo not empty slice
	generateTestHistogramDataPointSlice().MoveAndAppendTo(dest)
	assert.EqualValues(t, 2*expectedSlice.Len(), dest.Len())
	for i := 0; i < expectedSlice.Len(); i++ {
		assert.EqualValues(t, expectedSlice.At(i), dest.At(i))
		assert.EqualValues(t, expectedSlice.At(i), dest.At(i+expectedSlice.Len()))
	}
}

func TestHistogramDataPointSlice_RemoveIf(t *testing.T) {
	// Test RemoveIf on empty slice
	emptySlice := pmetric.NewHistogramDataPointSlice()
	emptySlice.RemoveIf(func(el pmetric.HistogramDataPoint) bool {
		t.Fail()
		return false
	})

	// Test RemoveIf
	filtered := generateTestHistogramDataPointSlice()
	pos := 0
	filtered.RemoveIf(func(el pmetric.HistogramDataPoint) bool {
		pos++
		return pos%3 == 0
	})
	assert.Equal(t, 5, filtered.Len())
}

func TestHistogramDataPoint_MoveTo(t *testing.T) {
	ms := generateTestHistogramDataPoint()
	dest := pmetric.NewHistogramDataPoint()
	ms.MoveTo(dest)
	assert.EqualValues(t, pmetric.NewHistogramDataPoint(), ms)
	assert.EqualValues(t, generateTestHistogramDataPoint(), dest)
}

func TestHistogramDataPoint_CopyTo(t *testing.T) {
	ms := pmetric.NewHistogramDataPoint()
	generateTestHistogramDataPoint().CopyTo(ms)
	assert.EqualValues(t, generateTestHistogramDataPoint(), ms)
}

func TestHistogramDataPoint_Attributes(t *testing.T) {
	ms := pmetric.NewHistogramDataPoint()
	assert.EqualValues(t, NewAttributeMap(), ms.Attributes())
	pcommon.fillTestAttributeMap(ms.Attributes())
	testValAttributes := pcommon.generateTestAttributeMap()
	assert.EqualValues(t, testValAttributes, ms.Attributes())
}

func TestHistogramDataPoint_StartTimestamp(t *testing.T) {
	ms := pmetric.NewHistogramDataPoint()
	assert.EqualValues(t, Timestamp(0), ms.StartTimestamp())
	testValStartTimestamp := Timestamp(1234567890)
	ms.SetStartTimestamp(testValStartTimestamp)
	assert.EqualValues(t, testValStartTimestamp, ms.StartTimestamp())
}

func TestHistogramDataPoint_Timestamp(t *testing.T) {
	ms := pmetric.NewHistogramDataPoint()
	assert.EqualValues(t, Timestamp(0), ms.Timestamp())
	testValTimestamp := Timestamp(1234567890)
	ms.SetTimestamp(testValTimestamp)
	assert.EqualValues(t, testValTimestamp, ms.Timestamp())
}

func TestHistogramDataPoint_Count(t *testing.T) {
	ms := pmetric.NewHistogramDataPoint()
	assert.EqualValues(t, uint64(0), ms.Count())
	testValCount := uint64(17)
	ms.SetCount(testValCount)
	assert.EqualValues(t, testValCount, ms.Count())
}

func TestHistogramDataPoint_Sum(t *testing.T) {
	ms := pmetric.NewHistogramDataPoint()
	assert.EqualValues(t, float64(0.0), ms.Sum())
	testValSum := float64(17.13)
	ms.SetSum(testValSum)
	assert.EqualValues(t, testValSum, ms.Sum())
}

func TestHistogramDataPoint_BucketCounts(t *testing.T) {
	ms := pmetric.NewHistogramDataPoint()
	assert.EqualValues(t, []uint64(nil), ms.BucketCounts())
	testValBucketCounts := []uint64{1, 2, 3}
	ms.SetBucketCounts(testValBucketCounts)
	assert.EqualValues(t, testValBucketCounts, ms.BucketCounts())
}

func TestHistogramDataPoint_ExplicitBounds(t *testing.T) {
	ms := pmetric.NewHistogramDataPoint()
	assert.EqualValues(t, []float64(nil), ms.ExplicitBounds())
	testValExplicitBounds := []float64{1, 2, 3}
	ms.SetExplicitBounds(testValExplicitBounds)
	assert.EqualValues(t, testValExplicitBounds, ms.ExplicitBounds())
}

func TestHistogramDataPoint_Exemplars(t *testing.T) {
	ms := pmetric.NewHistogramDataPoint()
	assert.EqualValues(t, pmetric.NewExemplarSlice(), ms.Exemplars())
	fillTestExemplarSlice(ms.Exemplars())
	testValExemplars := generateTestExemplarSlice()
	assert.EqualValues(t, testValExemplars, ms.Exemplars())
}

func TestHistogramDataPoint_Flags(t *testing.T) {
	ms := pmetric.NewHistogramDataPoint()
	assert.EqualValues(t, pmetric.MetricDataPointFlagsNone, ms.Flags())
	testValFlags := pmetric.MetricDataPointFlagsNone
	ms.SetFlags(testValFlags)
	assert.EqualValues(t, testValFlags, ms.Flags())
}

func TestExponentialHistogramDataPointSlice(t *testing.T) {
	es := pmetric.NewExponentialHistogramDataPointSlice()
	assert.EqualValues(t, 0, es.Len())
	es = pmetric.newExponentialHistogramDataPointSlice(&[]*otlpmetrics.ExponentialHistogramDataPoint{})
	assert.EqualValues(t, 0, es.Len())

	es.EnsureCapacity(7)
	emptyVal := pmetric.newExponentialHistogramDataPoint(&otlpmetrics.ExponentialHistogramDataPoint{})
	testVal := generateTestExponentialHistogramDataPoint()
	assert.EqualValues(t, 7, cap(*es.orig))
	for i := 0; i < es.Len(); i++ {
		el := es.AppendEmpty()
		assert.EqualValues(t, emptyVal, el)
		fillTestExponentialHistogramDataPoint(el)
		assert.EqualValues(t, testVal, el)
	}
}

func TestExponentialHistogramDataPointSlice_CopyTo(t *testing.T) {
	dest := pmetric.NewExponentialHistogramDataPointSlice()
	// Test CopyTo to empty
	pmetric.NewExponentialHistogramDataPointSlice().CopyTo(dest)
	assert.EqualValues(t, pmetric.NewExponentialHistogramDataPointSlice(), dest)

	// Test CopyTo larger slice
	generateTestExponentialHistogramDataPointSlice().CopyTo(dest)
	assert.EqualValues(t, generateTestExponentialHistogramDataPointSlice(), dest)

	// Test CopyTo same size slice
	generateTestExponentialHistogramDataPointSlice().CopyTo(dest)
	assert.EqualValues(t, generateTestExponentialHistogramDataPointSlice(), dest)
}

func TestExponentialHistogramDataPointSlice_EnsureCapacity(t *testing.T) {
	es := generateTestExponentialHistogramDataPointSlice()
	// Test ensure smaller capacity.
	const ensureSmallLen = 4
	expectedEs := make(map[*otlpmetrics.ExponentialHistogramDataPoint]bool)
	for i := 0; i < es.Len(); i++ {
		expectedEs[es.At(i).orig] = true
	}
	assert.Equal(t, es.Len(), len(expectedEs))
	es.EnsureCapacity(ensureSmallLen)
	assert.Less(t, ensureSmallLen, es.Len())
	foundEs := make(map[*otlpmetrics.ExponentialHistogramDataPoint]bool, es.Len())
	for i := 0; i < es.Len(); i++ {
		foundEs[es.At(i).orig] = true
	}
	assert.EqualValues(t, expectedEs, foundEs)

	// Test ensure larger capacity
	const ensureLargeLen = 9
	oldLen := es.Len()
	expectedEs = make(map[*otlpmetrics.ExponentialHistogramDataPoint]bool, oldLen)
	for i := 0; i < oldLen; i++ {
		expectedEs[es.At(i).orig] = true
	}
	assert.Equal(t, oldLen, len(expectedEs))
	es.EnsureCapacity(ensureLargeLen)
	assert.Equal(t, ensureLargeLen, cap(*es.orig))
	foundEs = make(map[*otlpmetrics.ExponentialHistogramDataPoint]bool, oldLen)
	for i := 0; i < oldLen; i++ {
		foundEs[es.At(i).orig] = true
	}
	assert.EqualValues(t, expectedEs, foundEs)
}

func TestExponentialHistogramDataPointSlice_MoveAndAppendTo(t *testing.T) {
	// Test MoveAndAppendTo to empty
	expectedSlice := generateTestExponentialHistogramDataPointSlice()
	dest := pmetric.NewExponentialHistogramDataPointSlice()
	src := generateTestExponentialHistogramDataPointSlice()
	src.MoveAndAppendTo(dest)
	assert.EqualValues(t, generateTestExponentialHistogramDataPointSlice(), dest)
	assert.EqualValues(t, 0, src.Len())
	assert.EqualValues(t, expectedSlice.Len(), dest.Len())

	// Test MoveAndAppendTo empty slice
	src.MoveAndAppendTo(dest)
	assert.EqualValues(t, generateTestExponentialHistogramDataPointSlice(), dest)
	assert.EqualValues(t, 0, src.Len())
	assert.EqualValues(t, expectedSlice.Len(), dest.Len())

	// Test MoveAndAppendTo not empty slice
	generateTestExponentialHistogramDataPointSlice().MoveAndAppendTo(dest)
	assert.EqualValues(t, 2*expectedSlice.Len(), dest.Len())
	for i := 0; i < expectedSlice.Len(); i++ {
		assert.EqualValues(t, expectedSlice.At(i), dest.At(i))
		assert.EqualValues(t, expectedSlice.At(i), dest.At(i+expectedSlice.Len()))
	}
}

func TestExponentialHistogramDataPointSlice_RemoveIf(t *testing.T) {
	// Test RemoveIf on empty slice
	emptySlice := pmetric.NewExponentialHistogramDataPointSlice()
	emptySlice.RemoveIf(func(el pmetric.ExponentialHistogramDataPoint) bool {
		t.Fail()
		return false
	})

	// Test RemoveIf
	filtered := generateTestExponentialHistogramDataPointSlice()
	pos := 0
	filtered.RemoveIf(func(el pmetric.ExponentialHistogramDataPoint) bool {
		pos++
		return pos%3 == 0
	})
	assert.Equal(t, 5, filtered.Len())
}

func TestExponentialHistogramDataPoint_MoveTo(t *testing.T) {
	ms := generateTestExponentialHistogramDataPoint()
	dest := pmetric.NewExponentialHistogramDataPoint()
	ms.MoveTo(dest)
	assert.EqualValues(t, pmetric.NewExponentialHistogramDataPoint(), ms)
	assert.EqualValues(t, generateTestExponentialHistogramDataPoint(), dest)
}

func TestExponentialHistogramDataPoint_CopyTo(t *testing.T) {
	ms := pmetric.NewExponentialHistogramDataPoint()
	generateTestExponentialHistogramDataPoint().CopyTo(ms)
	assert.EqualValues(t, generateTestExponentialHistogramDataPoint(), ms)
}

func TestExponentialHistogramDataPoint_Attributes(t *testing.T) {
	ms := pmetric.NewExponentialHistogramDataPoint()
	assert.EqualValues(t, NewAttributeMap(), ms.Attributes())
	pcommon.fillTestAttributeMap(ms.Attributes())
	testValAttributes := pcommon.generateTestAttributeMap()
	assert.EqualValues(t, testValAttributes, ms.Attributes())
}

func TestExponentialHistogramDataPoint_StartTimestamp(t *testing.T) {
	ms := pmetric.NewExponentialHistogramDataPoint()
	assert.EqualValues(t, Timestamp(0), ms.StartTimestamp())
	testValStartTimestamp := Timestamp(1234567890)
	ms.SetStartTimestamp(testValStartTimestamp)
	assert.EqualValues(t, testValStartTimestamp, ms.StartTimestamp())
}

func TestExponentialHistogramDataPoint_Timestamp(t *testing.T) {
	ms := pmetric.NewExponentialHistogramDataPoint()
	assert.EqualValues(t, Timestamp(0), ms.Timestamp())
	testValTimestamp := Timestamp(1234567890)
	ms.SetTimestamp(testValTimestamp)
	assert.EqualValues(t, testValTimestamp, ms.Timestamp())
}

func TestExponentialHistogramDataPoint_Count(t *testing.T) {
	ms := pmetric.NewExponentialHistogramDataPoint()
	assert.EqualValues(t, uint64(0), ms.Count())
	testValCount := uint64(17)
	ms.SetCount(testValCount)
	assert.EqualValues(t, testValCount, ms.Count())
}

func TestExponentialHistogramDataPoint_Sum(t *testing.T) {
	ms := pmetric.NewExponentialHistogramDataPoint()
	assert.EqualValues(t, float64(0.0), ms.Sum())
	testValSum := float64(17.13)
	ms.SetSum(testValSum)
	assert.EqualValues(t, testValSum, ms.Sum())
}

func TestExponentialHistogramDataPoint_Scale(t *testing.T) {
	ms := pmetric.NewExponentialHistogramDataPoint()
	assert.EqualValues(t, int32(0), ms.Scale())
	testValScale := int32(4)
	ms.SetScale(testValScale)
	assert.EqualValues(t, testValScale, ms.Scale())
}

func TestExponentialHistogramDataPoint_ZeroCount(t *testing.T) {
	ms := pmetric.NewExponentialHistogramDataPoint()
	assert.EqualValues(t, uint64(0), ms.ZeroCount())
	testValZeroCount := uint64(201)
	ms.SetZeroCount(testValZeroCount)
	assert.EqualValues(t, testValZeroCount, ms.ZeroCount())
}

func TestExponentialHistogramDataPoint_Positive(t *testing.T) {
	ms := pmetric.NewExponentialHistogramDataPoint()
	fillTestBuckets(ms.Positive())
	assert.EqualValues(t, generateTestBuckets(), ms.Positive())
}

func TestExponentialHistogramDataPoint_Negative(t *testing.T) {
	ms := pmetric.NewExponentialHistogramDataPoint()
	fillTestBuckets(ms.Negative())
	assert.EqualValues(t, generateTestBuckets(), ms.Negative())
}

func TestExponentialHistogramDataPoint_Exemplars(t *testing.T) {
	ms := pmetric.NewExponentialHistogramDataPoint()
	assert.EqualValues(t, pmetric.NewExemplarSlice(), ms.Exemplars())
	fillTestExemplarSlice(ms.Exemplars())
	testValExemplars := generateTestExemplarSlice()
	assert.EqualValues(t, testValExemplars, ms.Exemplars())
}

func TestExponentialHistogramDataPoint_Flags(t *testing.T) {
	ms := pmetric.NewExponentialHistogramDataPoint()
	assert.EqualValues(t, pmetric.MetricDataPointFlagsNone, ms.Flags())
	testValFlags := pmetric.MetricDataPointFlagsNone
	ms.SetFlags(testValFlags)
	assert.EqualValues(t, testValFlags, ms.Flags())
}

func TestBuckets_MoveTo(t *testing.T) {
	ms := generateTestBuckets()
	dest := pmetric.NewBuckets()
	ms.MoveTo(dest)
	assert.EqualValues(t, pmetric.NewBuckets(), ms)
	assert.EqualValues(t, generateTestBuckets(), dest)
}

func TestBuckets_CopyTo(t *testing.T) {
	ms := pmetric.NewBuckets()
	generateTestBuckets().CopyTo(ms)
	assert.EqualValues(t, generateTestBuckets(), ms)
}

func TestBuckets_Offset(t *testing.T) {
	ms := pmetric.NewBuckets()
	assert.EqualValues(t, int32(0), ms.Offset())
	testValOffset := int32(909)
	ms.SetOffset(testValOffset)
	assert.EqualValues(t, testValOffset, ms.Offset())
}

func TestBuckets_BucketCounts(t *testing.T) {
	ms := pmetric.NewBuckets()
	assert.EqualValues(t, []uint64(nil), ms.BucketCounts())
	testValBucketCounts := []uint64{1, 2, 3}
	ms.SetBucketCounts(testValBucketCounts)
	assert.EqualValues(t, testValBucketCounts, ms.BucketCounts())
}

func TestSummaryDataPointSlice(t *testing.T) {
	es := pmetric.NewSummaryDataPointSlice()
	assert.EqualValues(t, 0, es.Len())
	es = pmetric.newSummaryDataPointSlice(&[]*otlpmetrics.SummaryDataPoint{})
	assert.EqualValues(t, 0, es.Len())

	es.EnsureCapacity(7)
	emptyVal := pmetric.newSummaryDataPoint(&otlpmetrics.SummaryDataPoint{})
	testVal := generateTestSummaryDataPoint()
	assert.EqualValues(t, 7, cap(*es.orig))
	for i := 0; i < es.Len(); i++ {
		el := es.AppendEmpty()
		assert.EqualValues(t, emptyVal, el)
		fillTestSummaryDataPoint(el)
		assert.EqualValues(t, testVal, el)
	}
}

func TestSummaryDataPointSlice_CopyTo(t *testing.T) {
	dest := pmetric.NewSummaryDataPointSlice()
	// Test CopyTo to empty
	pmetric.NewSummaryDataPointSlice().CopyTo(dest)
	assert.EqualValues(t, pmetric.NewSummaryDataPointSlice(), dest)

	// Test CopyTo larger slice
	generateTestSummaryDataPointSlice().CopyTo(dest)
	assert.EqualValues(t, generateTestSummaryDataPointSlice(), dest)

	// Test CopyTo same size slice
	generateTestSummaryDataPointSlice().CopyTo(dest)
	assert.EqualValues(t, generateTestSummaryDataPointSlice(), dest)
}

func TestSummaryDataPointSlice_EnsureCapacity(t *testing.T) {
	es := generateTestSummaryDataPointSlice()
	// Test ensure smaller capacity.
	const ensureSmallLen = 4
	expectedEs := make(map[*otlpmetrics.SummaryDataPoint]bool)
	for i := 0; i < es.Len(); i++ {
		expectedEs[es.At(i).orig] = true
	}
	assert.Equal(t, es.Len(), len(expectedEs))
	es.EnsureCapacity(ensureSmallLen)
	assert.Less(t, ensureSmallLen, es.Len())
	foundEs := make(map[*otlpmetrics.SummaryDataPoint]bool, es.Len())
	for i := 0; i < es.Len(); i++ {
		foundEs[es.At(i).orig] = true
	}
	assert.EqualValues(t, expectedEs, foundEs)

	// Test ensure larger capacity
	const ensureLargeLen = 9
	oldLen := es.Len()
	expectedEs = make(map[*otlpmetrics.SummaryDataPoint]bool, oldLen)
	for i := 0; i < oldLen; i++ {
		expectedEs[es.At(i).orig] = true
	}
	assert.Equal(t, oldLen, len(expectedEs))
	es.EnsureCapacity(ensureLargeLen)
	assert.Equal(t, ensureLargeLen, cap(*es.orig))
	foundEs = make(map[*otlpmetrics.SummaryDataPoint]bool, oldLen)
	for i := 0; i < oldLen; i++ {
		foundEs[es.At(i).orig] = true
	}
	assert.EqualValues(t, expectedEs, foundEs)
}

func TestSummaryDataPointSlice_MoveAndAppendTo(t *testing.T) {
	// Test MoveAndAppendTo to empty
	expectedSlice := generateTestSummaryDataPointSlice()
	dest := pmetric.NewSummaryDataPointSlice()
	src := generateTestSummaryDataPointSlice()
	src.MoveAndAppendTo(dest)
	assert.EqualValues(t, generateTestSummaryDataPointSlice(), dest)
	assert.EqualValues(t, 0, src.Len())
	assert.EqualValues(t, expectedSlice.Len(), dest.Len())

	// Test MoveAndAppendTo empty slice
	src.MoveAndAppendTo(dest)
	assert.EqualValues(t, generateTestSummaryDataPointSlice(), dest)
	assert.EqualValues(t, 0, src.Len())
	assert.EqualValues(t, expectedSlice.Len(), dest.Len())

	// Test MoveAndAppendTo not empty slice
	generateTestSummaryDataPointSlice().MoveAndAppendTo(dest)
	assert.EqualValues(t, 2*expectedSlice.Len(), dest.Len())
	for i := 0; i < expectedSlice.Len(); i++ {
		assert.EqualValues(t, expectedSlice.At(i), dest.At(i))
		assert.EqualValues(t, expectedSlice.At(i), dest.At(i+expectedSlice.Len()))
	}
}

func TestSummaryDataPointSlice_RemoveIf(t *testing.T) {
	// Test RemoveIf on empty slice
	emptySlice := pmetric.NewSummaryDataPointSlice()
	emptySlice.RemoveIf(func(el pmetric.SummaryDataPoint) bool {
		t.Fail()
		return false
	})

	// Test RemoveIf
	filtered := generateTestSummaryDataPointSlice()
	pos := 0
	filtered.RemoveIf(func(el pmetric.SummaryDataPoint) bool {
		pos++
		return pos%3 == 0
	})
	assert.Equal(t, 5, filtered.Len())
}

func TestSummaryDataPoint_MoveTo(t *testing.T) {
	ms := generateTestSummaryDataPoint()
	dest := pmetric.NewSummaryDataPoint()
	ms.MoveTo(dest)
	assert.EqualValues(t, pmetric.NewSummaryDataPoint(), ms)
	assert.EqualValues(t, generateTestSummaryDataPoint(), dest)
}

func TestSummaryDataPoint_CopyTo(t *testing.T) {
	ms := pmetric.NewSummaryDataPoint()
	generateTestSummaryDataPoint().CopyTo(ms)
	assert.EqualValues(t, generateTestSummaryDataPoint(), ms)
}

func TestSummaryDataPoint_Attributes(t *testing.T) {
	ms := pmetric.NewSummaryDataPoint()
	assert.EqualValues(t, NewAttributeMap(), ms.Attributes())
	pcommon.fillTestAttributeMap(ms.Attributes())
	testValAttributes := pcommon.generateTestAttributeMap()
	assert.EqualValues(t, testValAttributes, ms.Attributes())
}

func TestSummaryDataPoint_StartTimestamp(t *testing.T) {
	ms := pmetric.NewSummaryDataPoint()
	assert.EqualValues(t, Timestamp(0), ms.StartTimestamp())
	testValStartTimestamp := Timestamp(1234567890)
	ms.SetStartTimestamp(testValStartTimestamp)
	assert.EqualValues(t, testValStartTimestamp, ms.StartTimestamp())
}

func TestSummaryDataPoint_Timestamp(t *testing.T) {
	ms := pmetric.NewSummaryDataPoint()
	assert.EqualValues(t, Timestamp(0), ms.Timestamp())
	testValTimestamp := Timestamp(1234567890)
	ms.SetTimestamp(testValTimestamp)
	assert.EqualValues(t, testValTimestamp, ms.Timestamp())
}

func TestSummaryDataPoint_Count(t *testing.T) {
	ms := pmetric.NewSummaryDataPoint()
	assert.EqualValues(t, uint64(0), ms.Count())
	testValCount := uint64(17)
	ms.SetCount(testValCount)
	assert.EqualValues(t, testValCount, ms.Count())
}

func TestSummaryDataPoint_Sum(t *testing.T) {
	ms := pmetric.NewSummaryDataPoint()
	assert.EqualValues(t, float64(0.0), ms.Sum())
	testValSum := float64(17.13)
	ms.SetSum(testValSum)
	assert.EqualValues(t, testValSum, ms.Sum())
}

func TestSummaryDataPoint_QuantileValues(t *testing.T) {
	ms := pmetric.NewSummaryDataPoint()
	assert.EqualValues(t, pmetric.NewValueAtQuantileSlice(), ms.QuantileValues())
	fillTestValueAtQuantileSlice(ms.QuantileValues())
	testValQuantileValues := generateTestValueAtQuantileSlice()
	assert.EqualValues(t, testValQuantileValues, ms.QuantileValues())
}

func TestSummaryDataPoint_Flags(t *testing.T) {
	ms := pmetric.NewSummaryDataPoint()
	assert.EqualValues(t, pmetric.MetricDataPointFlagsNone, ms.Flags())
	testValFlags := pmetric.MetricDataPointFlagsNone
	ms.SetFlags(testValFlags)
	assert.EqualValues(t, testValFlags, ms.Flags())
}

func TestValueAtQuantileSlice(t *testing.T) {
	es := pmetric.NewValueAtQuantileSlice()
	assert.EqualValues(t, 0, es.Len())
	es = pmetric.newValueAtQuantileSlice(&[]*otlpmetrics.SummaryDataPoint_ValueAtQuantile{})
	assert.EqualValues(t, 0, es.Len())

	es.EnsureCapacity(7)
	emptyVal := pmetric.newValueAtQuantile(&otlpmetrics.SummaryDataPoint_ValueAtQuantile{})
	testVal := generateTestValueAtQuantile()
	assert.EqualValues(t, 7, cap(*es.orig))
	for i := 0; i < es.Len(); i++ {
		el := es.AppendEmpty()
		assert.EqualValues(t, emptyVal, el)
		fillTestValueAtQuantile(el)
		assert.EqualValues(t, testVal, el)
	}
}

func TestValueAtQuantileSlice_CopyTo(t *testing.T) {
	dest := pmetric.NewValueAtQuantileSlice()
	// Test CopyTo to empty
	pmetric.NewValueAtQuantileSlice().CopyTo(dest)
	assert.EqualValues(t, pmetric.NewValueAtQuantileSlice(), dest)

	// Test CopyTo larger slice
	generateTestValueAtQuantileSlice().CopyTo(dest)
	assert.EqualValues(t, generateTestValueAtQuantileSlice(), dest)

	// Test CopyTo same size slice
	generateTestValueAtQuantileSlice().CopyTo(dest)
	assert.EqualValues(t, generateTestValueAtQuantileSlice(), dest)
}

func TestValueAtQuantileSlice_EnsureCapacity(t *testing.T) {
	es := generateTestValueAtQuantileSlice()
	// Test ensure smaller capacity.
	const ensureSmallLen = 4
	expectedEs := make(map[*otlpmetrics.SummaryDataPoint_ValueAtQuantile]bool)
	for i := 0; i < es.Len(); i++ {
		expectedEs[es.At(i).orig] = true
	}
	assert.Equal(t, es.Len(), len(expectedEs))
	es.EnsureCapacity(ensureSmallLen)
	assert.Less(t, ensureSmallLen, es.Len())
	foundEs := make(map[*otlpmetrics.SummaryDataPoint_ValueAtQuantile]bool, es.Len())
	for i := 0; i < es.Len(); i++ {
		foundEs[es.At(i).orig] = true
	}
	assert.EqualValues(t, expectedEs, foundEs)

	// Test ensure larger capacity
	const ensureLargeLen = 9
	oldLen := es.Len()
	expectedEs = make(map[*otlpmetrics.SummaryDataPoint_ValueAtQuantile]bool, oldLen)
	for i := 0; i < oldLen; i++ {
		expectedEs[es.At(i).orig] = true
	}
	assert.Equal(t, oldLen, len(expectedEs))
	es.EnsureCapacity(ensureLargeLen)
	assert.Equal(t, ensureLargeLen, cap(*es.orig))
	foundEs = make(map[*otlpmetrics.SummaryDataPoint_ValueAtQuantile]bool, oldLen)
	for i := 0; i < oldLen; i++ {
		foundEs[es.At(i).orig] = true
	}
	assert.EqualValues(t, expectedEs, foundEs)
}

func TestValueAtQuantileSlice_MoveAndAppendTo(t *testing.T) {
	// Test MoveAndAppendTo to empty
	expectedSlice := generateTestValueAtQuantileSlice()
	dest := pmetric.NewValueAtQuantileSlice()
	src := generateTestValueAtQuantileSlice()
	src.MoveAndAppendTo(dest)
	assert.EqualValues(t, generateTestValueAtQuantileSlice(), dest)
	assert.EqualValues(t, 0, src.Len())
	assert.EqualValues(t, expectedSlice.Len(), dest.Len())

	// Test MoveAndAppendTo empty slice
	src.MoveAndAppendTo(dest)
	assert.EqualValues(t, generateTestValueAtQuantileSlice(), dest)
	assert.EqualValues(t, 0, src.Len())
	assert.EqualValues(t, expectedSlice.Len(), dest.Len())

	// Test MoveAndAppendTo not empty slice
	generateTestValueAtQuantileSlice().MoveAndAppendTo(dest)
	assert.EqualValues(t, 2*expectedSlice.Len(), dest.Len())
	for i := 0; i < expectedSlice.Len(); i++ {
		assert.EqualValues(t, expectedSlice.At(i), dest.At(i))
		assert.EqualValues(t, expectedSlice.At(i), dest.At(i+expectedSlice.Len()))
	}
}

func TestValueAtQuantileSlice_RemoveIf(t *testing.T) {
	// Test RemoveIf on empty slice
	emptySlice := pmetric.NewValueAtQuantileSlice()
	emptySlice.RemoveIf(func(el pmetric.ValueAtQuantile) bool {
		t.Fail()
		return false
	})

	// Test RemoveIf
	filtered := generateTestValueAtQuantileSlice()
	pos := 0
	filtered.RemoveIf(func(el pmetric.ValueAtQuantile) bool {
		pos++
		return pos%3 == 0
	})
	assert.Equal(t, 5, filtered.Len())
}

func TestValueAtQuantile_MoveTo(t *testing.T) {
	ms := generateTestValueAtQuantile()
	dest := pmetric.NewValueAtQuantile()
	ms.MoveTo(dest)
	assert.EqualValues(t, pmetric.NewValueAtQuantile(), ms)
	assert.EqualValues(t, generateTestValueAtQuantile(), dest)
}

func TestValueAtQuantile_CopyTo(t *testing.T) {
	ms := pmetric.NewValueAtQuantile()
	generateTestValueAtQuantile().CopyTo(ms)
	assert.EqualValues(t, generateTestValueAtQuantile(), ms)
}

func TestValueAtQuantile_Quantile(t *testing.T) {
	ms := pmetric.NewValueAtQuantile()
	assert.EqualValues(t, float64(0.0), ms.Quantile())
	testValQuantile := float64(17.13)
	ms.SetQuantile(testValQuantile)
	assert.EqualValues(t, testValQuantile, ms.Quantile())
}

func TestValueAtQuantile_Value(t *testing.T) {
	ms := pmetric.NewValueAtQuantile()
	assert.EqualValues(t, float64(0.0), ms.Value())
	testValValue := float64(17.13)
	ms.SetValue(testValValue)
	assert.EqualValues(t, testValValue, ms.Value())
}

func TestExemplarSlice(t *testing.T) {
	es := pmetric.NewExemplarSlice()
	assert.EqualValues(t, 0, es.Len())
	es = pmetric.newExemplarSlice(&[]otlpmetrics.Exemplar{})
	assert.EqualValues(t, 0, es.Len())

	es.EnsureCapacity(7)
	emptyVal := pmetric.newExemplar(&otlpmetrics.Exemplar{})
	testVal := generateTestExemplar()
	assert.EqualValues(t, 7, cap(*es.orig))
	for i := 0; i < es.Len(); i++ {
		el := es.AppendEmpty()
		assert.EqualValues(t, emptyVal, el)
		fillTestExemplar(el)
		assert.EqualValues(t, testVal, el)
	}
}

func TestExemplarSlice_CopyTo(t *testing.T) {
	dest := pmetric.NewExemplarSlice()
	// Test CopyTo to empty
	pmetric.NewExemplarSlice().CopyTo(dest)
	assert.EqualValues(t, pmetric.NewExemplarSlice(), dest)

	// Test CopyTo larger slice
	generateTestExemplarSlice().CopyTo(dest)
	assert.EqualValues(t, generateTestExemplarSlice(), dest)

	// Test CopyTo same size slice
	generateTestExemplarSlice().CopyTo(dest)
	assert.EqualValues(t, generateTestExemplarSlice(), dest)
}

func TestExemplarSlice_EnsureCapacity(t *testing.T) {
	es := generateTestExemplarSlice()
	// Test ensure smaller capacity.
	const ensureSmallLen = 4
	expectedEs := make(map[*otlpmetrics.Exemplar]bool)
	for i := 0; i < es.Len(); i++ {
		expectedEs[es.At(i).orig] = true
	}
	assert.Equal(t, es.Len(), len(expectedEs))
	es.EnsureCapacity(ensureSmallLen)
	assert.Less(t, ensureSmallLen, es.Len())
	foundEs := make(map[*otlpmetrics.Exemplar]bool, es.Len())
	for i := 0; i < es.Len(); i++ {
		foundEs[es.At(i).orig] = true
	}
	assert.EqualValues(t, expectedEs, foundEs)

	// Test ensure larger capacity
	const ensureLargeLen = 9
	oldLen := es.Len()
	assert.Equal(t, oldLen, len(expectedEs))
	es.EnsureCapacity(ensureLargeLen)
	assert.Equal(t, ensureLargeLen, cap(*es.orig))
}

func TestExemplarSlice_MoveAndAppendTo(t *testing.T) {
	// Test MoveAndAppendTo to empty
	expectedSlice := generateTestExemplarSlice()
	dest := pmetric.NewExemplarSlice()
	src := generateTestExemplarSlice()
	src.MoveAndAppendTo(dest)
	assert.EqualValues(t, generateTestExemplarSlice(), dest)
	assert.EqualValues(t, 0, src.Len())
	assert.EqualValues(t, expectedSlice.Len(), dest.Len())

	// Test MoveAndAppendTo empty slice
	src.MoveAndAppendTo(dest)
	assert.EqualValues(t, generateTestExemplarSlice(), dest)
	assert.EqualValues(t, 0, src.Len())
	assert.EqualValues(t, expectedSlice.Len(), dest.Len())

	// Test MoveAndAppendTo not empty slice
	generateTestExemplarSlice().MoveAndAppendTo(dest)
	assert.EqualValues(t, 2*expectedSlice.Len(), dest.Len())
	for i := 0; i < expectedSlice.Len(); i++ {
		assert.EqualValues(t, expectedSlice.At(i), dest.At(i))
		assert.EqualValues(t, expectedSlice.At(i), dest.At(i+expectedSlice.Len()))
	}
}

func TestExemplarSlice_RemoveIf(t *testing.T) {
	// Test RemoveIf on empty slice
	emptySlice := pmetric.NewExemplarSlice()
	emptySlice.RemoveIf(func(el pmetric.Exemplar) bool {
		t.Fail()
		return false
	})

	// Test RemoveIf
	filtered := generateTestExemplarSlice()
	pos := 0
	filtered.RemoveIf(func(el pmetric.Exemplar) bool {
		pos++
		return pos%3 == 0
	})
	assert.Equal(t, 5, filtered.Len())
}

func TestExemplar_MoveTo(t *testing.T) {
	ms := generateTestExemplar()
	dest := pmetric.NewExemplar()
	ms.MoveTo(dest)
	assert.EqualValues(t, pmetric.NewExemplar(), ms)
	assert.EqualValues(t, generateTestExemplar(), dest)
}

func TestExemplar_CopyTo(t *testing.T) {
	ms := pmetric.NewExemplar()
	generateTestExemplar().CopyTo(ms)
	assert.EqualValues(t, generateTestExemplar(), ms)
}

func TestExemplar_Timestamp(t *testing.T) {
	ms := pmetric.NewExemplar()
	assert.EqualValues(t, Timestamp(0), ms.Timestamp())
	testValTimestamp := Timestamp(1234567890)
	ms.SetTimestamp(testValTimestamp)
	assert.EqualValues(t, testValTimestamp, ms.Timestamp())
}

func TestExemplarValueType(t *testing.T) {
	tv := pmetric.NewExemplar()
	assert.Equal(t, pmetric.MetricValueTypeNone, tv.ValueType())
	assert.Equal(t, "", pmetric.MetricValueType(1000).String())
	tv.SetDoubleVal(float64(17.13))
	assert.Equal(t, pmetric.MetricValueTypeDouble, tv.ValueType())
	tv.SetIntVal(int64(17))
	assert.Equal(t, pmetric.MetricValueTypeInt, tv.ValueType())
}

func TestExemplar_DoubleVal(t *testing.T) {
	ms := pmetric.NewExemplar()
	assert.EqualValues(t, float64(0.0), ms.DoubleVal())
	testValDoubleVal := float64(17.13)
	ms.SetDoubleVal(testValDoubleVal)
	assert.EqualValues(t, testValDoubleVal, ms.DoubleVal())
}

func TestExemplar_IntVal(t *testing.T) {
	ms := pmetric.NewExemplar()
	assert.EqualValues(t, int64(0), ms.IntVal())
	testValIntVal := int64(17)
	ms.SetIntVal(testValIntVal)
	assert.EqualValues(t, testValIntVal, ms.IntVal())
}

func TestExemplar_FilteredAttributes(t *testing.T) {
	ms := pmetric.NewExemplar()
	assert.EqualValues(t, NewAttributeMap(), ms.FilteredAttributes())
	pcommon.fillTestAttributeMap(ms.FilteredAttributes())
	testValFilteredAttributes := pcommon.generateTestAttributeMap()
	assert.EqualValues(t, testValFilteredAttributes, ms.FilteredAttributes())
}

func TestExemplar_TraceID(t *testing.T) {
	ms := pmetric.NewExemplar()
	assert.EqualValues(t, NewTraceID([16]byte{}), ms.TraceID())
	testValTraceID := NewTraceID([16]byte{1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3, 2, 1})
	ms.SetTraceID(testValTraceID)
	assert.EqualValues(t, testValTraceID, ms.TraceID())
}

func TestExemplar_SpanID(t *testing.T) {
	ms := pmetric.NewExemplar()
	assert.EqualValues(t, NewSpanID([8]byte{}), ms.SpanID())
	testValSpanID := NewSpanID([8]byte{1, 2, 3, 4, 5, 6, 7, 8})
	ms.SetSpanID(testValSpanID)
	assert.EqualValues(t, testValSpanID, ms.SpanID())
}

func generateTestResourceMetricsSlice() pmetric.ResourceMetricsSlice {
	tv := pmetric.NewResourceMetricsSlice()
	fillTestResourceMetricsSlice(tv)
	return tv
}

func fillTestResourceMetricsSlice(tv pmetric.ResourceMetricsSlice) {
	l := 7
	tv.EnsureCapacity(l)
	for i := 0; i < l; i++ {
		fillTestResourceMetrics(tv.AppendEmpty())
	}
}

func generateTestResourceMetrics() pmetric.ResourceMetrics {
	tv := pmetric.NewResourceMetrics()
	fillTestResourceMetrics(tv)
	return tv
}

func fillTestResourceMetrics(tv pmetric.ResourceMetrics) {
	fillTestResource(tv.Resource())
	tv.SetSchemaUrl("https://opentelemetry.io/schemas/1.5.0")
	fillTestInstrumentationLibraryMetricsSlice(tv.InstrumentationLibraryMetrics())
}

func generateTestInstrumentationLibraryMetricsSlice() pmetric.InstrumentationLibraryMetricsSlice {
	tv := pmetric.NewInstrumentationLibraryMetricsSlice()
	fillTestInstrumentationLibraryMetricsSlice(tv)
	return tv
}

func fillTestInstrumentationLibraryMetricsSlice(tv pmetric.InstrumentationLibraryMetricsSlice) {
	l := 7
	tv.EnsureCapacity(l)
	for i := 0; i < l; i++ {
		fillTestInstrumentationLibraryMetrics(tv.AppendEmpty())
	}
}

func generateTestInstrumentationLibraryMetrics() pmetric.InstrumentationLibraryMetrics {
	tv := pmetric.NewInstrumentationLibraryMetrics()
	fillTestInstrumentationLibraryMetrics(tv)
	return tv
}

func fillTestInstrumentationLibraryMetrics(tv pmetric.InstrumentationLibraryMetrics) {
	pcommon.fillTestInstrumentationLibrary(tv.InstrumentationLibrary())
	tv.SetSchemaUrl("https://opentelemetry.io/schemas/1.5.0")
	fillTestMetricSlice(tv.Metrics())
}

func generateTestMetricSlice() pmetric.MetricSlice {
	tv := pmetric.NewMetricSlice()
	fillTestMetricSlice(tv)
	return tv
}

func fillTestMetricSlice(tv pmetric.MetricSlice) {
	l := 7
	tv.EnsureCapacity(l)
	for i := 0; i < l; i++ {
		fillTestMetric(tv.AppendEmpty())
	}
}

func generateTestMetric() pmetric.Metric {
	tv := pmetric.NewMetric()
	fillTestMetric(tv)
	return tv
}

func fillTestMetric(tv pmetric.Metric) {
	tv.SetName("test_name")
	tv.SetDescription("test_description")
	tv.SetUnit("1")
	tv.SetDataType(pmetric.MetricDataTypeSum)
	fillTestSum(tv.Sum())
}

func generateTestGauge() pmetric.Gauge {
	tv := pmetric.NewGauge()
	fillTestGauge(tv)
	return tv
}

func fillTestGauge(tv pmetric.Gauge) {
	fillTestNumberDataPointSlice(tv.DataPoints())
}

func generateTestSum() pmetric.Sum {
	tv := pmetric.NewSum()
	fillTestSum(tv)
	return tv
}

func fillTestSum(tv pmetric.Sum) {
	tv.SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	tv.SetIsMonotonic(true)
	fillTestNumberDataPointSlice(tv.DataPoints())
}

func generateTestHistogram() pmetric.Histogram {
	tv := pmetric.NewHistogram()
	fillTestHistogram(tv)
	return tv
}

func fillTestHistogram(tv pmetric.Histogram) {
	tv.SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	fillTestHistogramDataPointSlice(tv.DataPoints())
}

func generateTestExponentialHistogram() pmetric.ExponentialHistogram {
	tv := pmetric.NewExponentialHistogram()
	fillTestExponentialHistogram(tv)
	return tv
}

func fillTestExponentialHistogram(tv pmetric.ExponentialHistogram) {
	tv.SetAggregationTemporality(pmetric.MetricAggregationTemporalityCumulative)
	fillTestExponentialHistogramDataPointSlice(tv.DataPoints())
}

func generateTestSummary() pmetric.Summary {
	tv := pmetric.NewSummary()
	fillTestSummary(tv)
	return tv
}

func fillTestSummary(tv pmetric.Summary) {
	fillTestSummaryDataPointSlice(tv.DataPoints())
}

func generateTestNumberDataPointSlice() pmetric.NumberDataPointSlice {
	tv := pmetric.NewNumberDataPointSlice()
	fillTestNumberDataPointSlice(tv)
	return tv
}

func fillTestNumberDataPointSlice(tv pmetric.NumberDataPointSlice) {
	l := 7
	tv.EnsureCapacity(l)
	for i := 0; i < l; i++ {
		fillTestNumberDataPoint(tv.AppendEmpty())
	}
}

func generateTestNumberDataPoint() pmetric.NumberDataPoint {
	tv := pmetric.NewNumberDataPoint()
	fillTestNumberDataPoint(tv)
	return tv
}

func fillTestNumberDataPoint(tv pmetric.NumberDataPoint) {
	pcommon.fillTestAttributeMap(tv.Attributes())
	tv.SetStartTimestamp(Timestamp(1234567890))
	tv.SetTimestamp(Timestamp(1234567890))
	tv.SetDoubleVal(float64(17.13))
	fillTestExemplarSlice(tv.Exemplars())
	tv.SetFlags(pmetric.MetricDataPointFlagsNone)
}

func generateTestHistogramDataPointSlice() pmetric.HistogramDataPointSlice {
	tv := pmetric.NewHistogramDataPointSlice()
	fillTestHistogramDataPointSlice(tv)
	return tv
}

func fillTestHistogramDataPointSlice(tv pmetric.HistogramDataPointSlice) {
	l := 7
	tv.EnsureCapacity(l)
	for i := 0; i < l; i++ {
		fillTestHistogramDataPoint(tv.AppendEmpty())
	}
}

func generateTestHistogramDataPoint() pmetric.HistogramDataPoint {
	tv := pmetric.NewHistogramDataPoint()
	fillTestHistogramDataPoint(tv)
	return tv
}

func fillTestHistogramDataPoint(tv pmetric.HistogramDataPoint) {
	pcommon.fillTestAttributeMap(tv.Attributes())
	tv.SetStartTimestamp(Timestamp(1234567890))
	tv.SetTimestamp(Timestamp(1234567890))
	tv.SetCount(uint64(17))
	tv.SetSum(float64(17.13))
	tv.SetBucketCounts([]uint64{1, 2, 3})
	tv.SetExplicitBounds([]float64{1, 2, 3})
	fillTestExemplarSlice(tv.Exemplars())
	tv.SetFlags(pmetric.MetricDataPointFlagsNone)
}

func generateTestExponentialHistogramDataPointSlice() pmetric.ExponentialHistogramDataPointSlice {
	tv := pmetric.NewExponentialHistogramDataPointSlice()
	fillTestExponentialHistogramDataPointSlice(tv)
	return tv
}

func fillTestExponentialHistogramDataPointSlice(tv pmetric.ExponentialHistogramDataPointSlice) {
	l := 7
	tv.EnsureCapacity(l)
	for i := 0; i < l; i++ {
		fillTestExponentialHistogramDataPoint(tv.AppendEmpty())
	}
}

func generateTestExponentialHistogramDataPoint() pmetric.ExponentialHistogramDataPoint {
	tv := pmetric.NewExponentialHistogramDataPoint()
	fillTestExponentialHistogramDataPoint(tv)
	return tv
}

func fillTestExponentialHistogramDataPoint(tv pmetric.ExponentialHistogramDataPoint) {
	pcommon.fillTestAttributeMap(tv.Attributes())
	tv.SetStartTimestamp(Timestamp(1234567890))
	tv.SetTimestamp(Timestamp(1234567890))
	tv.SetCount(uint64(17))
	tv.SetSum(float64(17.13))
	tv.SetScale(int32(4))
	tv.SetZeroCount(uint64(201))
	fillTestBuckets(tv.Positive())
	fillTestBuckets(tv.Negative())
	fillTestExemplarSlice(tv.Exemplars())
	tv.SetFlags(pmetric.MetricDataPointFlagsNone)
}

func generateTestBuckets() pmetric.Buckets {
	tv := pmetric.NewBuckets()
	fillTestBuckets(tv)
	return tv
}

func fillTestBuckets(tv pmetric.Buckets) {
	tv.SetOffset(int32(909))
	tv.SetBucketCounts([]uint64{1, 2, 3})
}

func generateTestSummaryDataPointSlice() pmetric.SummaryDataPointSlice {
	tv := pmetric.NewSummaryDataPointSlice()
	fillTestSummaryDataPointSlice(tv)
	return tv
}

func fillTestSummaryDataPointSlice(tv pmetric.SummaryDataPointSlice) {
	l := 7
	tv.EnsureCapacity(l)
	for i := 0; i < l; i++ {
		fillTestSummaryDataPoint(tv.AppendEmpty())
	}
}

func generateTestSummaryDataPoint() pmetric.SummaryDataPoint {
	tv := pmetric.NewSummaryDataPoint()
	fillTestSummaryDataPoint(tv)
	return tv
}

func fillTestSummaryDataPoint(tv pmetric.SummaryDataPoint) {
	pcommon.fillTestAttributeMap(tv.Attributes())
	tv.SetStartTimestamp(Timestamp(1234567890))
	tv.SetTimestamp(Timestamp(1234567890))
	tv.SetCount(uint64(17))
	tv.SetSum(float64(17.13))
	fillTestValueAtQuantileSlice(tv.QuantileValues())
	tv.SetFlags(pmetric.MetricDataPointFlagsNone)
}

func generateTestValueAtQuantileSlice() pmetric.ValueAtQuantileSlice {
	tv := pmetric.NewValueAtQuantileSlice()
	fillTestValueAtQuantileSlice(tv)
	return tv
}

func fillTestValueAtQuantileSlice(tv pmetric.ValueAtQuantileSlice) {
	l := 7
	tv.EnsureCapacity(l)
	for i := 0; i < l; i++ {
		fillTestValueAtQuantile(tv.AppendEmpty())
	}
}

func generateTestValueAtQuantile() pmetric.ValueAtQuantile {
	tv := pmetric.NewValueAtQuantile()
	fillTestValueAtQuantile(tv)
	return tv
}

func fillTestValueAtQuantile(tv pmetric.ValueAtQuantile) {
	tv.SetQuantile(float64(17.13))
	tv.SetValue(float64(17.13))
}

func generateTestExemplarSlice() pmetric.ExemplarSlice {
	tv := pmetric.NewExemplarSlice()
	fillTestExemplarSlice(tv)
	return tv
}

func fillTestExemplarSlice(tv pmetric.ExemplarSlice) {
	l := 7
	tv.EnsureCapacity(l)
	for i := 0; i < l; i++ {
		fillTestExemplar(tv.AppendEmpty())
	}
}

func generateTestExemplar() pmetric.Exemplar {
	tv := pmetric.NewExemplar()
	fillTestExemplar(tv)
	return tv
}

func fillTestExemplar(tv pmetric.Exemplar) {
	tv.SetTimestamp(Timestamp(1234567890))
	tv.SetIntVal(int64(17))
	pcommon.fillTestAttributeMap(tv.FilteredAttributes())
	tv.SetTraceID(NewTraceID([16]byte{1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3, 2, 1}))
	tv.SetSpanID(NewSpanID([8]byte{1, 2, 3, 4, 5, 6, 7, 8}))
}
