// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: opentelemetry/proto/profiles/v1/profiles.proto

package v1

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"

	go_opentelemetry_io_collector_pdata_internal_data "go.opentelemetry.io/collector/pdata/internal/data"
	v11 "go.opentelemetry.io/collector/pdata/internal/data/protogen/common/v1"
	denormalized "go.opentelemetry.io/collector/pdata/internal/data/protogen/profiles/v1/alternatives/denormalized"
	pprof "go.opentelemetry.io/collector/pdata/internal/data/protogen/profiles/v1/alternatives/pprof"
	arrays "go.opentelemetry.io/collector/pdata/internal/data/protogen/profiles/v1/arrays"
	normalized "go.opentelemetry.io/collector/pdata/internal/data/protogen/profiles/v1/normalized"
	v1 "go.opentelemetry.io/collector/pdata/internal/data/protogen/resource/v1"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ProfilesData represents the profiles data that can be stored in a persistent storage,
// OR can be embedded by other protocols that transfer OTLP profiles data but do not
// implement the OTLP protocol.
//
// The main difference between this message and collector protocol is that
// in this message there will not be any "control" or "metadata" specific to
// OTLP protocol.
//
// When new fields are added into this message, the OTLP request MUST be updated
// as well.
type ProfilesData struct {
	// An array of ResourceProfiles.
	// For data coming from a single resource this array will typically contain
	// one element. Intermediary nodes that receive data from multiple origins
	// typically batch the data before forwarding further and in that case this
	// array will contain multiple elements.
	ResourceProfiles []*ResourceProfiles `protobuf:"bytes,1,rep,name=resource_profiles,json=resourceProfiles,proto3" json:"resource_profiles,omitempty"`
}

func (m *ProfilesData) Reset()         { *m = ProfilesData{} }
func (m *ProfilesData) String() string { return proto.CompactTextString(m) }
func (*ProfilesData) ProtoMessage()    {}
func (*ProfilesData) Descriptor() ([]byte, []int) {
	return fileDescriptor_57ba5958fad9a734, []int{0}
}
func (m *ProfilesData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProfilesData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProfilesData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProfilesData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProfilesData.Merge(m, src)
}
func (m *ProfilesData) XXX_Size() int {
	return m.Size()
}
func (m *ProfilesData) XXX_DiscardUnknown() {
	xxx_messageInfo_ProfilesData.DiscardUnknown(m)
}

var xxx_messageInfo_ProfilesData proto.InternalMessageInfo

func (m *ProfilesData) GetResourceProfiles() []*ResourceProfiles {
	if m != nil {
		return m.ResourceProfiles
	}
	return nil
}

// A collection of ScopeProfiles from a Resource.
type ResourceProfiles struct {
	DeprecatedScopeProfiles []*ScopeProfiles `protobuf:"bytes,1000,rep,name=deprecated_scope_profiles,json=deprecatedScopeProfiles,proto3" json:"deprecated_scope_profiles,omitempty"`
	// The resource for the profiles in this message.
	// If this field is not set then no resource info is known.
	Resource v1.Resource `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource"`
	// A list of ScopeProfiles that originate from a resource.
	ScopeProfiles []*ScopeProfiles `protobuf:"bytes,2,rep,name=scope_profiles,json=scopeProfiles,proto3" json:"scope_profiles,omitempty"`
	// This schema_url applies to the data in the "resource" field. It does not apply
	// to the data in the "scope_profiles" field which have their own schema_url field.
	SchemaUrl string `protobuf:"bytes,3,opt,name=schema_url,json=schemaUrl,proto3" json:"schema_url,omitempty"`
}

func (m *ResourceProfiles) Reset()         { *m = ResourceProfiles{} }
func (m *ResourceProfiles) String() string { return proto.CompactTextString(m) }
func (*ResourceProfiles) ProtoMessage()    {}
func (*ResourceProfiles) Descriptor() ([]byte, []int) {
	return fileDescriptor_57ba5958fad9a734, []int{1}
}
func (m *ResourceProfiles) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceProfiles) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceProfiles.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceProfiles) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceProfiles.Merge(m, src)
}
func (m *ResourceProfiles) XXX_Size() int {
	return m.Size()
}
func (m *ResourceProfiles) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceProfiles.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceProfiles proto.InternalMessageInfo

func (m *ResourceProfiles) GetDeprecatedScopeProfiles() []*ScopeProfiles {
	if m != nil {
		return m.DeprecatedScopeProfiles
	}
	return nil
}

func (m *ResourceProfiles) GetResource() v1.Resource {
	if m != nil {
		return m.Resource
	}
	return v1.Resource{}
}

func (m *ResourceProfiles) GetScopeProfiles() []*ScopeProfiles {
	if m != nil {
		return m.ScopeProfiles
	}
	return nil
}

func (m *ResourceProfiles) GetSchemaUrl() string {
	if m != nil {
		return m.SchemaUrl
	}
	return ""
}

// A collection of Profiles produced by an InstrumentationScope.
type ScopeProfiles struct {
	// The instrumentation scope information for the profiles in this message.
	// Semantically when InstrumentationScope isn't set, it is equivalent with
	// an empty instrumentation scope name (unknown).
	Scope v11.InstrumentationScope `protobuf:"bytes,1,opt,name=scope,proto3" json:"scope"`
	// A list of Profiles that originate from an instrumentation scope.
	Profiles []*Profile `protobuf:"bytes,2,rep,name=profiles,proto3" json:"profiles,omitempty"`
	// This schema_url applies to all profiles and profile events in the "profiles" field.
	SchemaUrl string `protobuf:"bytes,3,opt,name=schema_url,json=schemaUrl,proto3" json:"schema_url,omitempty"`
}

func (m *ScopeProfiles) Reset()         { *m = ScopeProfiles{} }
func (m *ScopeProfiles) String() string { return proto.CompactTextString(m) }
func (*ScopeProfiles) ProtoMessage()    {}
func (*ScopeProfiles) Descriptor() ([]byte, []int) {
	return fileDescriptor_57ba5958fad9a734, []int{2}
}
func (m *ScopeProfiles) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScopeProfiles) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScopeProfiles.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScopeProfiles) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScopeProfiles.Merge(m, src)
}
func (m *ScopeProfiles) XXX_Size() int {
	return m.Size()
}
func (m *ScopeProfiles) XXX_DiscardUnknown() {
	xxx_messageInfo_ScopeProfiles.DiscardUnknown(m)
}

var xxx_messageInfo_ScopeProfiles proto.InternalMessageInfo

func (m *ScopeProfiles) GetScope() v11.InstrumentationScope {
	if m != nil {
		return m.Scope
	}
	return v11.InstrumentationScope{}
}

func (m *ScopeProfiles) GetProfiles() []*Profile {
	if m != nil {
		return m.Profiles
	}
	return nil
}

func (m *ScopeProfiles) GetSchemaUrl() string {
	if m != nil {
		return m.SchemaUrl
	}
	return ""
}

// A Profile represents a single profile.
type Profile struct {
	// A unique identifier for a profile. The ID is a 16-byte array. An ID with
	// all zeroes is considered invalid.
	//
	// This field is required.
	ProfileId go_opentelemetry_io_collector_pdata_internal_data.ProfileID `protobuf:"bytes,1,opt,name=profile_id,json=profileId,proto3,customtype=go.opentelemetry.io/collector/pdata/internal/data.ProfileID" json:"profile_id"`
	// start_time_unix_nano is the start time of the profile.
	// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
	//
	// This field is semantically required and it is expected that end_time >= start_time.
	StartTimeUnixNano uint64 `protobuf:"fixed64,2,opt,name=start_time_unix_nano,json=startTimeUnixNano,proto3" json:"start_time_unix_nano,omitempty"`
	// end_time_unix_nano is the end time of the profile.
	// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
	//
	// This field is semantically required and it is expected that end_time >= start_time.
	EndTimeUnixNano uint64 `protobuf:"fixed64,3,opt,name=end_time_unix_nano,json=endTimeUnixNano,proto3" json:"end_time_unix_nano,omitempty"`
	// attributes is a collection of key/value pairs. Note, global attributes
	// like server name can be set using the resource API. Examples of attributes:
	//
	//     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
	//     "/http/server_latency": 300
	//     "abc.com/myattribute": true
	//     "abc.com/score": 10.239
	//
	// The OpenTelemetry API specification further restricts the allowed value types:
	// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute
	// Attribute keys MUST be unique (it is not allowed to have more than one
	// attribute with the same key).
	Attributes []v11.KeyValue `protobuf:"bytes,4,rep,name=attributes,proto3" json:"attributes"`
	// dropped_attributes_count is the number of attributes that were discarded. Attributes
	// can be discarded because their keys are too long or because there are too many
	// attributes. If this value is 0, then no attributes were dropped.
	DroppedAttributesCount uint32 `protobuf:"varint,5,opt,name=dropped_attributes_count,json=droppedAttributesCount,proto3" json:"dropped_attributes_count,omitempty"`
	// This can be original pprof or jfr encoded profile.
	OriginalPayload []byte `protobuf:"bytes,7,opt,name=original_payload,json=originalPayload,proto3" json:"original_payload,omitempty"`
	// this is temporary until we pick one of these formats
	// fields from one of these will be embedded in Profile message:
	//
	// Types that are valid to be assigned to AlternativeProfile:
	//	*Profile_Pprof
	//	*Profile_Normalized
	//	*Profile_Arrays
	//	*Profile_Denormalized
	AlternativeProfile isProfile_AlternativeProfile `protobuf_oneof:"alternative_profile"`
}

func (m *Profile) Reset()         { *m = Profile{} }
func (m *Profile) String() string { return proto.CompactTextString(m) }
func (*Profile) ProtoMessage()    {}
func (*Profile) Descriptor() ([]byte, []int) {
	return fileDescriptor_57ba5958fad9a734, []int{3}
}
func (m *Profile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Profile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Profile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Profile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Profile.Merge(m, src)
}
func (m *Profile) XXX_Size() int {
	return m.Size()
}
func (m *Profile) XXX_DiscardUnknown() {
	xxx_messageInfo_Profile.DiscardUnknown(m)
}

var xxx_messageInfo_Profile proto.InternalMessageInfo

type isProfile_AlternativeProfile interface {
	isProfile_AlternativeProfile()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Profile_Pprof struct {
	Pprof *pprof.Profile `protobuf:"bytes,8,opt,name=pprof,proto3,oneof" json:"pprof,omitempty"`
}
type Profile_Normalized struct {
	Normalized *normalized.Profile `protobuf:"bytes,9,opt,name=normalized,proto3,oneof" json:"normalized,omitempty"`
}
type Profile_Arrays struct {
	Arrays *arrays.Profile `protobuf:"bytes,10,opt,name=arrays,proto3,oneof" json:"arrays,omitempty"`
}
type Profile_Denormalized struct {
	Denormalized *denormalized.Profile `protobuf:"bytes,11,opt,name=denormalized,proto3,oneof" json:"denormalized,omitempty"`
}

func (*Profile_Pprof) isProfile_AlternativeProfile()        {}
func (*Profile_Normalized) isProfile_AlternativeProfile()   {}
func (*Profile_Arrays) isProfile_AlternativeProfile()       {}
func (*Profile_Denormalized) isProfile_AlternativeProfile() {}

func (m *Profile) GetAlternativeProfile() isProfile_AlternativeProfile {
	if m != nil {
		return m.AlternativeProfile
	}
	return nil
}

func (m *Profile) GetStartTimeUnixNano() uint64 {
	if m != nil {
		return m.StartTimeUnixNano
	}
	return 0
}

func (m *Profile) GetEndTimeUnixNano() uint64 {
	if m != nil {
		return m.EndTimeUnixNano
	}
	return 0
}

func (m *Profile) GetAttributes() []v11.KeyValue {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Profile) GetDroppedAttributesCount() uint32 {
	if m != nil {
		return m.DroppedAttributesCount
	}
	return 0
}

func (m *Profile) GetOriginalPayload() []byte {
	if m != nil {
		return m.OriginalPayload
	}
	return nil
}

func (m *Profile) GetPprof() *pprof.Profile {
	if x, ok := m.GetAlternativeProfile().(*Profile_Pprof); ok {
		return x.Pprof
	}
	return nil
}

func (m *Profile) GetNormalized() *normalized.Profile {
	if x, ok := m.GetAlternativeProfile().(*Profile_Normalized); ok {
		return x.Normalized
	}
	return nil
}

func (m *Profile) GetArrays() *arrays.Profile {
	if x, ok := m.GetAlternativeProfile().(*Profile_Arrays); ok {
		return x.Arrays
	}
	return nil
}

func (m *Profile) GetDenormalized() *denormalized.Profile {
	if x, ok := m.GetAlternativeProfile().(*Profile_Denormalized); ok {
		return x.Denormalized
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Profile) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Profile_Pprof)(nil),
		(*Profile_Normalized)(nil),
		(*Profile_Arrays)(nil),
		(*Profile_Denormalized)(nil),
	}
}

func init() {
	proto.RegisterType((*ProfilesData)(nil), "opentelemetry.proto.profiles.v1.ProfilesData")
	proto.RegisterType((*ResourceProfiles)(nil), "opentelemetry.proto.profiles.v1.ResourceProfiles")
	proto.RegisterType((*ScopeProfiles)(nil), "opentelemetry.proto.profiles.v1.ScopeProfiles")
	proto.RegisterType((*Profile)(nil), "opentelemetry.proto.profiles.v1.Profile")
}

func init() {
	proto.RegisterFile("opentelemetry/proto/profiles/v1/profiles.proto", fileDescriptor_57ba5958fad9a734)
}

var fileDescriptor_57ba5958fad9a734 = []byte{
	// 757 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x95, 0xcd, 0x6e, 0xd3, 0x4a,
	0x14, 0xc7, 0xe3, 0xb4, 0x4d, 0x9b, 0x69, 0x73, 0xdb, 0xce, 0xed, 0xbd, 0x98, 0x4a, 0x24, 0x51,
	0x36, 0xa4, 0x20, 0x39, 0x4a, 0xbb, 0x41, 0x2a, 0x42, 0x25, 0xad, 0x50, 0xab, 0x02, 0x8d, 0xdc,
	0x8f, 0x05, 0x0b, 0xac, 0x69, 0x3c, 0xa4, 0x23, 0xec, 0x19, 0x6b, 0x3c, 0x89, 0x1a, 0x9e, 0x02,
	0x5e, 0x83, 0x17, 0x60, 0x8f, 0x84, 0xd4, 0x65, 0x97, 0x88, 0x45, 0x85, 0xda, 0x0d, 0x8f, 0x81,
	0x3c, 0x1e, 0x3b, 0x76, 0x88, 0x64, 0x99, 0x4d, 0x32, 0x3e, 0x1f, 0xbf, 0x73, 0xce, 0xcc, 0xf8,
	0x6f, 0x60, 0x30, 0x0f, 0x53, 0x81, 0x1d, 0xec, 0x62, 0xc1, 0x47, 0x2d, 0x8f, 0x33, 0xc1, 0x82,
	0xdf, 0x77, 0xc4, 0xc1, 0x7e, 0x6b, 0xd8, 0x8e, 0xd7, 0x86, 0x74, 0xc1, 0x5a, 0x2a, 0x3e, 0x34,
	0x1a, 0x71, 0xcc, 0xb0, 0xbd, 0xbe, 0xd6, 0x67, 0x7d, 0x16, 0x62, 0x82, 0x55, 0x18, 0xb1, 0xfe,
	0x68, 0x5a, 0x99, 0x1e, 0x73, 0x5d, 0x46, 0x83, 0x22, 0xe1, 0x4a, 0xc5, 0x4e, 0x6d, 0x89, 0x63,
	0x9f, 0x0d, 0x78, 0x0f, 0x07, 0xd1, 0xd1, 0x5a, 0xc5, 0x3f, 0xcb, 0x1a, 0x01, 0x39, 0x02, 0x73,
	0x8a, 0x04, 0x19, 0x62, 0xbf, 0xe5, 0x05, 0x9e, 0xf0, 0x57, 0xe5, 0xbf, 0xcc, 0x95, 0x6f, 0x63,
	0xca, 0xb8, 0x8b, 0x1c, 0xf2, 0x01, 0xdb, 0xa9, 0x07, 0x45, 0xdb, 0xcf, 0x45, 0x4b, 0xb0, 0xfe,
	0x20, 0xed, 0xe4, 0x22, 0x21, 0xce, 0xd1, 0x28, 0xfa, 0x0b, 0x09, 0x0d, 0x0a, 0x96, 0xba, 0x2a,
	0x7e, 0x0f, 0x09, 0x04, 0xdf, 0x82, 0xd5, 0x68, 0xef, 0xac, 0x08, 0xa4, 0x6b, 0xf5, 0x99, 0xe6,
	0xe2, 0x66, 0xdb, 0xc8, 0x38, 0x58, 0xc3, 0x54, 0x99, 0x11, 0xd1, 0x5c, 0xe1, 0x13, 0x96, 0xc6,
	0xd7, 0x22, 0x58, 0x99, 0x0c, 0x83, 0xef, 0xc1, 0x7d, 0x1b, 0x7b, 0x1c, 0xf7, 0x90, 0xc0, 0xb6,
	0xe5, 0xf7, 0x98, 0x97, 0x28, 0xfe, 0x6b, 0x5e, 0x56, 0x37, 0x32, 0xab, 0x1f, 0x07, 0x79, 0x71,
	0xe9, 0x7b, 0x63, 0x62, 0xca, 0x01, 0x0f, 0xc1, 0x42, 0xd4, 0x95, 0xae, 0xd5, 0xb5, 0xe6, 0xe2,
	0xe6, 0xc6, 0x54, 0x74, 0x7c, 0x85, 0x12, 0x83, 0x75, 0x66, 0xaf, 0x6e, 0x6a, 0x05, 0x33, 0x06,
	0xc0, 0x53, 0xf0, 0xcf, 0x44, 0xbb, 0xc5, 0xbf, 0xea, 0xb6, 0xe2, 0xa7, 0x7a, 0x7c, 0x00, 0x80,
	0xdf, 0xbb, 0xc0, 0x2e, 0xb2, 0x06, 0xdc, 0xd1, 0x67, 0xea, 0x5a, 0xb3, 0x6c, 0x96, 0x43, 0xcb,
	0x29, 0x77, 0x1a, 0xdf, 0x34, 0x50, 0x49, 0x0f, 0x75, 0x04, 0xe6, 0x24, 0x41, 0x4d, 0xb4, 0x35,
	0xb5, 0xbc, 0x7a, 0x85, 0x86, 0x6d, 0xe3, 0x80, 0xfa, 0x82, 0x0f, 0x5c, 0x4c, 0x05, 0x12, 0x84,
	0x51, 0xc9, 0x52, 0xb3, 0x85, 0x1c, 0xb8, 0x07, 0x16, 0x26, 0x46, 0x6a, 0x66, 0x8e, 0xa4, 0xba,
	0x31, 0xe3, 0xcc, 0xac, 0x39, 0x3e, 0x95, 0xc0, 0xbc, 0x4a, 0x82, 0xe7, 0x00, 0xa8, 0x34, 0x8b,
	0xd8, 0x72, 0x8c, 0xa5, 0xce, 0x6e, 0xd0, 0xd1, 0x8f, 0x9b, 0xda, 0x76, 0x9f, 0x4d, 0x14, 0x27,
	0x81, 0x34, 0x38, 0x0e, 0xee, 0x09, 0xc6, 0x5b, 0x9e, 0x8d, 0x04, 0x6a, 0x11, 0x2a, 0xaf, 0xba,
	0xd3, 0x0a, 0x9e, 0xa2, 0x5e, 0x0e, 0xf6, 0xcc, 0xb2, 0xc2, 0x1e, 0xd8, 0xb0, 0x05, 0xd6, 0x7c,
	0x81, 0xb8, 0xb0, 0x04, 0x71, 0xb1, 0x35, 0xa0, 0xe4, 0xd2, 0xa2, 0x88, 0x32, 0xbd, 0x58, 0xd7,
	0x9a, 0x25, 0x73, 0x55, 0xfa, 0x4e, 0x88, 0x8b, 0x4f, 0x29, 0xb9, 0x7c, 0x8d, 0x28, 0x83, 0x8f,
	0x01, 0xc4, 0xd4, 0x9e, 0x0c, 0x9f, 0x91, 0xe1, 0xcb, 0x98, 0xda, 0xa9, 0xe0, 0x57, 0x00, 0x20,
	0x21, 0x38, 0x39, 0x1f, 0x08, 0xec, 0xeb, 0xb3, 0x72, 0xd3, 0x1e, 0x66, 0x1c, 0xc4, 0x21, 0x1e,
	0x9d, 0x21, 0x67, 0x10, 0x6d, 0x7e, 0x02, 0x00, 0x9f, 0x00, 0xdd, 0xe6, 0xcc, 0xf3, 0xb0, 0x6d,
	0x8d, 0xad, 0x56, 0x8f, 0x0d, 0xa8, 0xd0, 0xe7, 0xea, 0x5a, 0xb3, 0x62, 0xfe, 0xaf, 0xfc, 0xcf,
	0x63, 0xf7, 0x6e, 0xe0, 0x85, 0x1b, 0x60, 0x85, 0x71, 0xd2, 0x27, 0x14, 0x39, 0x96, 0x87, 0x46,
	0x0e, 0x43, 0xb6, 0x3e, 0x1f, 0x6c, 0xa8, 0xb9, 0x1c, 0xd9, 0xbb, 0xa1, 0x19, 0x1e, 0x83, 0x39,
	0xa9, 0x73, 0xfa, 0x82, 0xbc, 0x37, 0xdb, 0x99, 0x67, 0x9c, 0x14, 0x14, 0x23, 0x94, 0x48, 0xb5,
	0xd5, 0xfb, 0x05, 0x33, 0x64, 0x05, 0x47, 0x39, 0x56, 0x2a, 0xbd, 0x2c, 0xc9, 0x3b, 0xf9, 0xc8,
	0x09, 0xa5, 0x1b, 0xe3, 0x13, 0x54, 0x78, 0x06, 0x4a, 0xa1, 0x8e, 0xe9, 0x40, 0xf2, 0x9f, 0xe6,
	0xe3, 0x2b, 0x0d, 0x1c, 0xb3, 0x15, 0x0d, 0x5e, 0x80, 0xa5, 0xa4, 0x62, 0xeb, 0x8b, 0x92, 0xde,
	0xc9, 0x47, 0x4f, 0x69, 0xfe, 0xb8, 0x46, 0x8a, 0xdc, 0xf9, 0x0f, 0xfc, 0x9b, 0x48, 0x8a, 0x04,
	0xa4, 0xf3, 0x45, 0xbb, 0xba, 0xad, 0x6a, 0xd7, 0xb7, 0x55, 0xed, 0xe7, 0x6d, 0x55, 0xfb, 0x78,
	0x57, 0x2d, 0x5c, 0xdf, 0x55, 0x0b, 0xdf, 0xef, 0xaa, 0x05, 0xd0, 0x20, 0x2c, 0xab, 0x8f, 0x4e,
	0x25, 0x92, 0x84, 0x6e, 0xe0, 0xea, 0x6a, 0x6f, 0x5e, 0xe4, 0x7e, 0x77, 0xc2, 0xcf, 0x48, 0x1f,
	0xd3, 0xe4, 0x97, 0xe4, 0x73, 0xb1, 0x76, 0xe4, 0x61, 0x7a, 0x12, 0x53, 0x24, 0x3f, 0x1a, 0xce,
	0x37, 0xce, 0xda, 0xe7, 0x25, 0x99, 0xb7, 0xf5, 0x3b, 0x00, 0x00, 0xff, 0xff, 0x93, 0x7c, 0x3c,
	0xa4, 0x30, 0x08, 0x00, 0x00,
}

func (m *ProfilesData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProfilesData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProfilesData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResourceProfiles) > 0 {
		for iNdEx := len(m.ResourceProfiles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResourceProfiles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProfiles(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResourceProfiles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceProfiles) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceProfiles) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeprecatedScopeProfiles) > 0 {
		for iNdEx := len(m.DeprecatedScopeProfiles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DeprecatedScopeProfiles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProfiles(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.SchemaUrl) > 0 {
		i -= len(m.SchemaUrl)
		copy(dAtA[i:], m.SchemaUrl)
		i = encodeVarintProfiles(dAtA, i, uint64(len(m.SchemaUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ScopeProfiles) > 0 {
		for iNdEx := len(m.ScopeProfiles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ScopeProfiles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProfiles(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Resource.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProfiles(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ScopeProfiles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScopeProfiles) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopeProfiles) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SchemaUrl) > 0 {
		i -= len(m.SchemaUrl)
		copy(dAtA[i:], m.SchemaUrl)
		i = encodeVarintProfiles(dAtA, i, uint64(len(m.SchemaUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Profiles) > 0 {
		for iNdEx := len(m.Profiles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Profiles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProfiles(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Scope.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProfiles(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Profile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Profile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Profile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AlternativeProfile != nil {
		{
			size := m.AlternativeProfile.Size()
			i -= size
			if _, err := m.AlternativeProfile.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.OriginalPayload) > 0 {
		i -= len(m.OriginalPayload)
		copy(dAtA[i:], m.OriginalPayload)
		i = encodeVarintProfiles(dAtA, i, uint64(len(m.OriginalPayload)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DroppedAttributesCount != 0 {
		i = encodeVarintProfiles(dAtA, i, uint64(m.DroppedAttributesCount))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProfiles(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.EndTimeUnixNano != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.EndTimeUnixNano))
		i--
		dAtA[i] = 0x19
	}
	if m.StartTimeUnixNano != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.StartTimeUnixNano))
		i--
		dAtA[i] = 0x11
	}
	{
		size := m.ProfileId.Size()
		i -= size
		if _, err := m.ProfileId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProfiles(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Profile_Pprof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Profile_Pprof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Pprof != nil {
		{
			size, err := m.Pprof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProfiles(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Profile_Normalized) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Profile_Normalized) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Normalized != nil {
		{
			size, err := m.Normalized.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProfiles(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Profile_Arrays) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Profile_Arrays) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Arrays != nil {
		{
			size, err := m.Arrays.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProfiles(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Profile_Denormalized) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Profile_Denormalized) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Denormalized != nil {
		{
			size, err := m.Denormalized.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProfiles(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func encodeVarintProfiles(dAtA []byte, offset int, v uint64) int {
	offset -= sovProfiles(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ProfilesData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResourceProfiles) > 0 {
		for _, e := range m.ResourceProfiles {
			l = e.Size()
			n += 1 + l + sovProfiles(uint64(l))
		}
	}
	return n
}

func (m *ResourceProfiles) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Resource.Size()
	n += 1 + l + sovProfiles(uint64(l))
	if len(m.ScopeProfiles) > 0 {
		for _, e := range m.ScopeProfiles {
			l = e.Size()
			n += 1 + l + sovProfiles(uint64(l))
		}
	}
	l = len(m.SchemaUrl)
	if l > 0 {
		n += 1 + l + sovProfiles(uint64(l))
	}
	if len(m.DeprecatedScopeProfiles) > 0 {
		for _, e := range m.DeprecatedScopeProfiles {
			l = e.Size()
			n += 2 + l + sovProfiles(uint64(l))
		}
	}
	return n
}

func (m *ScopeProfiles) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Scope.Size()
	n += 1 + l + sovProfiles(uint64(l))
	if len(m.Profiles) > 0 {
		for _, e := range m.Profiles {
			l = e.Size()
			n += 1 + l + sovProfiles(uint64(l))
		}
	}
	l = len(m.SchemaUrl)
	if l > 0 {
		n += 1 + l + sovProfiles(uint64(l))
	}
	return n
}

func (m *Profile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ProfileId.Size()
	n += 1 + l + sovProfiles(uint64(l))
	if m.StartTimeUnixNano != 0 {
		n += 9
	}
	if m.EndTimeUnixNano != 0 {
		n += 9
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovProfiles(uint64(l))
		}
	}
	if m.DroppedAttributesCount != 0 {
		n += 1 + sovProfiles(uint64(m.DroppedAttributesCount))
	}
	l = len(m.OriginalPayload)
	if l > 0 {
		n += 1 + l + sovProfiles(uint64(l))
	}
	if m.AlternativeProfile != nil {
		n += m.AlternativeProfile.Size()
	}
	return n
}

func (m *Profile_Pprof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pprof != nil {
		l = m.Pprof.Size()
		n += 1 + l + sovProfiles(uint64(l))
	}
	return n
}
func (m *Profile_Normalized) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Normalized != nil {
		l = m.Normalized.Size()
		n += 1 + l + sovProfiles(uint64(l))
	}
	return n
}
func (m *Profile_Arrays) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Arrays != nil {
		l = m.Arrays.Size()
		n += 1 + l + sovProfiles(uint64(l))
	}
	return n
}
func (m *Profile_Denormalized) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Denormalized != nil {
		l = m.Denormalized.Size()
		n += 1 + l + sovProfiles(uint64(l))
	}
	return n
}

func sovProfiles(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProfiles(x uint64) (n int) {
	return sovProfiles(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ProfilesData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProfiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProfilesData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProfilesData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceProfiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProfiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceProfiles = append(m.ResourceProfiles, &ResourceProfiles{})
			if err := m.ResourceProfiles[len(m.ResourceProfiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProfiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProfiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceProfiles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProfiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceProfiles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceProfiles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProfiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeProfiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProfiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeProfiles = append(m.ScopeProfiles, &ScopeProfiles{})
			if err := m.ScopeProfiles[len(m.ScopeProfiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProfiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedScopeProfiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProfiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeprecatedScopeProfiles = append(m.DeprecatedScopeProfiles, &ScopeProfiles{})
			if err := m.DeprecatedScopeProfiles[len(m.DeprecatedScopeProfiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProfiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProfiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScopeProfiles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProfiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScopeProfiles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScopeProfiles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProfiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Scope.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProfiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Profiles = append(m.Profiles, &Profile{})
			if err := m.Profiles[len(m.Profiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProfiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProfiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProfiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Profile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProfiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Profile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Profile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProfiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProfileId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimeUnixNano", wireType)
			}
			m.StartTimeUnixNano = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTimeUnixNano = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTimeUnixNano", wireType)
			}
			m.EndTimeUnixNano = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTimeUnixNano = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProfiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, v11.KeyValue{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedAttributesCount", wireType)
			}
			m.DroppedAttributesCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DroppedAttributesCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalPayload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProfiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalPayload = append(m.OriginalPayload[:0], dAtA[iNdEx:postIndex]...)
			if m.OriginalPayload == nil {
				m.OriginalPayload = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pprof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProfiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &pprof.Profile{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AlternativeProfile = &Profile_Pprof{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Normalized", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProfiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &normalized.Profile{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AlternativeProfile = &Profile_Normalized{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arrays", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProfiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &arrays.Profile{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AlternativeProfile = &Profile_Arrays{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denormalized", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProfiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &denormalized.Profile{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AlternativeProfile = &Profile_Denormalized{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProfiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProfiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProfiles(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProfiles
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProfiles
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProfiles
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProfiles
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProfiles
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProfiles        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProfiles          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProfiles = fmt.Errorf("proto: unexpected end of group")
)
