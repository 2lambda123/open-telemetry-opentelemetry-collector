// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: opentelemetry/proto/profiles/v1/alternatives/normalized/normalized.proto

package normalized

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"

	go_opentelemetry_io_collector_pdata_internal_data "go.opentelemetry.io/collector/pdata/internal/data"
	v1 "go.opentelemetry.io/collector/pdata/internal/data/protogen/common/v1"
	_ "go.opentelemetry.io/collector/pdata/internal/data/protogen/resource/v1"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// borrowed from metrics proto
type SampleType_AggregationTemporality int32

const (
	SampleType_AGGREGATION_TEMPORALITY_UNSPECIFIED SampleType_AggregationTemporality = 0
	SampleType_AGGREGATION_TEMPORALITY_DELTA       SampleType_AggregationTemporality = 1
	SampleType_AGGREGATION_TEMPORALITY_CUMULATIVE  SampleType_AggregationTemporality = 2
)

var SampleType_AggregationTemporality_name = map[int32]string{
	0: "AGGREGATION_TEMPORALITY_UNSPECIFIED",
	1: "AGGREGATION_TEMPORALITY_DELTA",
	2: "AGGREGATION_TEMPORALITY_CUMULATIVE",
}

var SampleType_AggregationTemporality_value = map[string]int32{
	"AGGREGATION_TEMPORALITY_UNSPECIFIED": 0,
	"AGGREGATION_TEMPORALITY_DELTA":       1,
	"AGGREGATION_TEMPORALITY_CUMULATIVE":  2,
}

func (x SampleType_AggregationTemporality) String() string {
	return proto.EnumName(SampleType_AggregationTemporality_name, int32(x))
}

func (SampleType_AggregationTemporality) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2a46c7ccddd4b033, []int{4, 0}
}

type Mapping_SymbolFidelity int32

const (
	Mapping_SYMBOL_FIDELITY_UNSPECIFIED Mapping_SymbolFidelity = 0
	Mapping_SYMBOL_FIDELITY_FULL        Mapping_SymbolFidelity = 1
)

var Mapping_SymbolFidelity_name = map[int32]string{
	0: "SYMBOL_FIDELITY_UNSPECIFIED",
	1: "SYMBOL_FIDELITY_FULL",
}

var Mapping_SymbolFidelity_value = map[string]int32{
	"SYMBOL_FIDELITY_UNSPECIFIED": 0,
	"SYMBOL_FIDELITY_FULL":        1,
}

func (x Mapping_SymbolFidelity) String() string {
	return proto.EnumName(Mapping_SymbolFidelity_name, int32(x))
}

func (Mapping_SymbolFidelity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2a46c7ccddd4b033, []int{6, 0}
}

// A pointer from a profile to a trace span.
type Link struct {
	// A unique identifier of a trace that this linked span is part of. The ID is a
	// 16-byte array.
	TraceId go_opentelemetry_io_collector_pdata_internal_data.TraceID `protobuf:"bytes,1,opt,name=trace_id,json=traceId,proto3,customtype=go.opentelemetry.io/collector/pdata/internal/data.TraceID" json:"trace_id"`
	// A unique identifier for the linked span. The ID is an 8-byte array.
	SpanId go_opentelemetry_io_collector_pdata_internal_data.SpanID `protobuf:"bytes,2,opt,name=span_id,json=spanId,proto3,customtype=go.opentelemetry.io/collector/pdata/internal/data.SpanID" json:"span_id"`
}

func (m *Link) Reset()         { *m = Link{} }
func (m *Link) String() string { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()    {}
func (*Link) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c7ccddd4b033, []int{0}
}
func (m *Link) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Link) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Link.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Link) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link.Merge(m, src)
}
func (m *Link) XXX_Size() int {
	return m.Size()
}
func (m *Link) XXX_DiscardUnknown() {
	xxx_messageInfo_Link.DiscardUnknown(m)
}

var xxx_messageInfo_Link proto.InternalMessageInfo

// AttributeSet represents a set of attributes. It is referenced from Samples
// and not embedded because it is common for multiple samples to have the same
// set of attributes
type AttributeSet struct {
	Attributes             []v1.KeyValue `protobuf:"bytes,1,rep,name=attributes,proto3" json:"attributes"`
	DroppedAttributesCount uint32        `protobuf:"varint,2,opt,name=dropped_attributes_count,json=droppedAttributesCount,proto3" json:"dropped_attributes_count,omitempty"`
}

func (m *AttributeSet) Reset()         { *m = AttributeSet{} }
func (m *AttributeSet) String() string { return proto.CompactTextString(m) }
func (*AttributeSet) ProtoMessage()    {}
func (*AttributeSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c7ccddd4b033, []int{1}
}
func (m *AttributeSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttributeSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttributeSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttributeSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttributeSet.Merge(m, src)
}
func (m *AttributeSet) XXX_Size() int {
	return m.Size()
}
func (m *AttributeSet) XXX_DiscardUnknown() {
	xxx_messageInfo_AttributeSet.DiscardUnknown(m)
}

var xxx_messageInfo_AttributeSet proto.InternalMessageInfo

func (m *AttributeSet) GetAttributes() []v1.KeyValue {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *AttributeSet) GetDroppedAttributesCount() uint32 {
	if m != nil {
		return m.DroppedAttributesCount
	}
	return 0
}

type Stacktrace struct {
	LocationIndices []uint32 `protobuf:"varint,1,rep,packed,name=location_indices,json=locationIndices,proto3" json:"location_indices,omitempty"`
}

func (m *Stacktrace) Reset()         { *m = Stacktrace{} }
func (m *Stacktrace) String() string { return proto.CompactTextString(m) }
func (*Stacktrace) ProtoMessage()    {}
func (*Stacktrace) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c7ccddd4b033, []int{2}
}
func (m *Stacktrace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stacktrace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stacktrace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stacktrace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stacktrace.Merge(m, src)
}
func (m *Stacktrace) XXX_Size() int {
	return m.Size()
}
func (m *Stacktrace) XXX_DiscardUnknown() {
	xxx_messageInfo_Stacktrace.DiscardUnknown(m)
}

var xxx_messageInfo_Stacktrace proto.InternalMessageInfo

func (m *Stacktrace) GetLocationIndices() []uint32 {
	if m != nil {
		return m.LocationIndices
	}
	return nil
}

type Sample struct {
	StacktraceIndex     uint32   `protobuf:"varint,1,opt,name=stacktrace_index,json=stacktraceIndex,proto3" json:"stacktrace_index,omitempty"`
	LinkIndices         []uint32 `protobuf:"varint,2,rep,packed,name=link_indices,json=linkIndices,proto3" json:"link_indices,omitempty"`
	AttributeSetIndices []uint32 `protobuf:"varint,3,rep,packed,name=attribute_set_indices,json=attributeSetIndices,proto3" json:"attribute_set_indices,omitempty"`
	// this one is repeated because there can be multiple profile kinds in one profile. Typical example is memory profiles in go that contain:
	//   * alloc_objects
	//   * alloc_bytes
	//   * inuse_objects
	//   * inuse_bytes
	Values []int64 `protobuf:"varint,4,rep,packed,name=values,proto3" json:"values,omitempty"`
	// optional
	TimestampUnixNano uint64 `protobuf:"fixed64,5,opt,name=timestamp_unix_nano,json=timestampUnixNano,proto3" json:"timestamp_unix_nano,omitempty"`
}

func (m *Sample) Reset()         { *m = Sample{} }
func (m *Sample) String() string { return proto.CompactTextString(m) }
func (*Sample) ProtoMessage()    {}
func (*Sample) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c7ccddd4b033, []int{3}
}
func (m *Sample) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sample) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sample.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sample) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sample.Merge(m, src)
}
func (m *Sample) XXX_Size() int {
	return m.Size()
}
func (m *Sample) XXX_DiscardUnknown() {
	xxx_messageInfo_Sample.DiscardUnknown(m)
}

var xxx_messageInfo_Sample proto.InternalMessageInfo

func (m *Sample) GetStacktraceIndex() uint32 {
	if m != nil {
		return m.StacktraceIndex
	}
	return 0
}

func (m *Sample) GetLinkIndices() []uint32 {
	if m != nil {
		return m.LinkIndices
	}
	return nil
}

func (m *Sample) GetAttributeSetIndices() []uint32 {
	if m != nil {
		return m.AttributeSetIndices
	}
	return nil
}

func (m *Sample) GetValues() []int64 {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *Sample) GetTimestampUnixNano() uint64 {
	if m != nil {
		return m.TimestampUnixNano
	}
	return 0
}

type SampleType struct {
	AggregationTemporality SampleType_AggregationTemporality `protobuf:"varint,1,opt,name=aggregation_temporality,json=aggregationTemporality,proto3,enum=opentelemetry.proto.profiles.v1.alternatives.normalized.SampleType_AggregationTemporality" json:"aggregation_temporality,omitempty"`
	SampleSize             uint64                            `protobuf:"varint,2,opt,name=sample_size,json=sampleSize,proto3" json:"sample_size,omitempty"`
	// CPU / memory /etc
	TypeIndex uint32 `protobuf:"varint,3,opt,name=type_index,json=typeIndex,proto3" json:"type_index,omitempty"`
	UnitIndex uint32 `protobuf:"varint,4,opt,name=unit_index,json=unitIndex,proto3" json:"unit_index,omitempty"`
}

func (m *SampleType) Reset()         { *m = SampleType{} }
func (m *SampleType) String() string { return proto.CompactTextString(m) }
func (*SampleType) ProtoMessage()    {}
func (*SampleType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c7ccddd4b033, []int{4}
}
func (m *SampleType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SampleType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SampleType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SampleType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SampleType.Merge(m, src)
}
func (m *SampleType) XXX_Size() int {
	return m.Size()
}
func (m *SampleType) XXX_DiscardUnknown() {
	xxx_messageInfo_SampleType.DiscardUnknown(m)
}

var xxx_messageInfo_SampleType proto.InternalMessageInfo

func (m *SampleType) GetAggregationTemporality() SampleType_AggregationTemporality {
	if m != nil {
		return m.AggregationTemporality
	}
	return SampleType_AGGREGATION_TEMPORALITY_UNSPECIFIED
}

func (m *SampleType) GetSampleSize() uint64 {
	if m != nil {
		return m.SampleSize
	}
	return 0
}

func (m *SampleType) GetTypeIndex() uint32 {
	if m != nil {
		return m.TypeIndex
	}
	return 0
}

func (m *SampleType) GetUnitIndex() uint32 {
	if m != nil {
		return m.UnitIndex
	}
	return 0
}

type Profile struct {
	SampleTypes   []*SampleType   `protobuf:"bytes,1,rep,name=sample_types,json=sampleTypes,proto3" json:"sample_types,omitempty"`
	Stacktraces   []*Stacktrace   `protobuf:"bytes,2,rep,name=stacktraces,proto3" json:"stacktraces,omitempty"`
	Samples       []*Sample       `protobuf:"bytes,3,rep,name=samples,proto3" json:"samples,omitempty"`
	Mappings      []*Mapping      `protobuf:"bytes,4,rep,name=mappings,proto3" json:"mappings,omitempty"`
	Locations     []*Location     `protobuf:"bytes,5,rep,name=locations,proto3" json:"locations,omitempty"`
	Functions     []*Function     `protobuf:"bytes,6,rep,name=functions,proto3" json:"functions,omitempty"`
	Links         []*Link         `protobuf:"bytes,7,rep,name=links,proto3" json:"links,omitempty"`
	AttributeSets []*AttributeSet `protobuf:"bytes,8,rep,name=attribute_sets,json=attributeSets,proto3" json:"attribute_sets,omitempty"`
	// 0-th element must be an empty string ("")
	StringTable []string `protobuf:"bytes,9,rep,name=string_table,json=stringTable,proto3" json:"string_table,omitempty"`
}

func (m *Profile) Reset()         { *m = Profile{} }
func (m *Profile) String() string { return proto.CompactTextString(m) }
func (*Profile) ProtoMessage()    {}
func (*Profile) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c7ccddd4b033, []int{5}
}
func (m *Profile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Profile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Profile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Profile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Profile.Merge(m, src)
}
func (m *Profile) XXX_Size() int {
	return m.Size()
}
func (m *Profile) XXX_DiscardUnknown() {
	xxx_messageInfo_Profile.DiscardUnknown(m)
}

var xxx_messageInfo_Profile proto.InternalMessageInfo

func (m *Profile) GetSampleTypes() []*SampleType {
	if m != nil {
		return m.SampleTypes
	}
	return nil
}

func (m *Profile) GetStacktraces() []*Stacktrace {
	if m != nil {
		return m.Stacktraces
	}
	return nil
}

func (m *Profile) GetSamples() []*Sample {
	if m != nil {
		return m.Samples
	}
	return nil
}

func (m *Profile) GetMappings() []*Mapping {
	if m != nil {
		return m.Mappings
	}
	return nil
}

func (m *Profile) GetLocations() []*Location {
	if m != nil {
		return m.Locations
	}
	return nil
}

func (m *Profile) GetFunctions() []*Function {
	if m != nil {
		return m.Functions
	}
	return nil
}

func (m *Profile) GetLinks() []*Link {
	if m != nil {
		return m.Links
	}
	return nil
}

func (m *Profile) GetAttributeSets() []*AttributeSet {
	if m != nil {
		return m.AttributeSets
	}
	return nil
}

func (m *Profile) GetStringTable() []string {
	if m != nil {
		return m.StringTable
	}
	return nil
}

// borrowed from pprof proto
type Mapping struct {
	// Address at which the binary (or DLL) is loaded into memory.
	MemoryStart uint64 `protobuf:"varint,1,opt,name=memory_start,json=memoryStart,proto3" json:"memory_start,omitempty"`
	// The limit of the address range occupied by this mapping.
	MemoryLimit uint64 `protobuf:"varint,2,opt,name=memory_limit,json=memoryLimit,proto3" json:"memory_limit,omitempty"`
	// Offset in the binary that corresponds to the first mapped address.
	FileOffset uint64 `protobuf:"varint,3,opt,name=file_offset,json=fileOffset,proto3" json:"file_offset,omitempty"`
	// The object this entry is loaded from.  This can be a filename on
	// disk for the main binary and shared libraries, or virtual
	// abstractions like "[vdso]".
	FilenameIndex uint32 `protobuf:"varint,4,opt,name=filename_index,json=filenameIndex,proto3" json:"filename_index,omitempty"`
	// A string that uniquely identifies a particular program version
	// with high probability. E.g., for binaries generated by GNU tools,
	// it could be the contents of the .note.gnu.build-id field.
	BuildIdIndex uint32                 `protobuf:"varint,5,opt,name=build_id_index,json=buildIdIndex,proto3" json:"build_id_index,omitempty"`
	SymbolicInfo Mapping_SymbolFidelity `protobuf:"varint,6,opt,name=symbolic_info,json=symbolicInfo,proto3,enum=opentelemetry.proto.profiles.v1.alternatives.normalized.Mapping_SymbolFidelity" json:"symbolic_info,omitempty"`
	// TODO(@petethepig): I wonder if we need something a little more specialized here
	AttributeSetIndices []uint32 `protobuf:"varint,7,rep,packed,name=attribute_set_indices,json=attributeSetIndices,proto3" json:"attribute_set_indices,omitempty"`
}

func (m *Mapping) Reset()         { *m = Mapping{} }
func (m *Mapping) String() string { return proto.CompactTextString(m) }
func (*Mapping) ProtoMessage()    {}
func (*Mapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c7ccddd4b033, []int{6}
}
func (m *Mapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Mapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Mapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mapping.Merge(m, src)
}
func (m *Mapping) XXX_Size() int {
	return m.Size()
}
func (m *Mapping) XXX_DiscardUnknown() {
	xxx_messageInfo_Mapping.DiscardUnknown(m)
}

var xxx_messageInfo_Mapping proto.InternalMessageInfo

func (m *Mapping) GetMemoryStart() uint64 {
	if m != nil {
		return m.MemoryStart
	}
	return 0
}

func (m *Mapping) GetMemoryLimit() uint64 {
	if m != nil {
		return m.MemoryLimit
	}
	return 0
}

func (m *Mapping) GetFileOffset() uint64 {
	if m != nil {
		return m.FileOffset
	}
	return 0
}

func (m *Mapping) GetFilenameIndex() uint32 {
	if m != nil {
		return m.FilenameIndex
	}
	return 0
}

func (m *Mapping) GetBuildIdIndex() uint32 {
	if m != nil {
		return m.BuildIdIndex
	}
	return 0
}

func (m *Mapping) GetSymbolicInfo() Mapping_SymbolFidelity {
	if m != nil {
		return m.SymbolicInfo
	}
	return Mapping_SYMBOL_FIDELITY_UNSPECIFIED
}

func (m *Mapping) GetAttributeSetIndices() []uint32 {
	if m != nil {
		return m.AttributeSetIndices
	}
	return nil
}

// borrowed from pprof proto
// Describes function and line table debug information.
type Location struct {
	// The id of the corresponding profile.Mapping for this location.
	// It can be unset if the mapping is unknown or not applicable for
	// this profile type.
	MappingIndex uint32 `protobuf:"varint,1,opt,name=mapping_index,json=mappingIndex,proto3" json:"mapping_index,omitempty"`
	// The instruction address for this location, if available.  It
	// should be within [Mapping.memory_start...Mapping.memory_limit]
	// for the corresponding mapping. A non-leaf address may be in the
	// middle of a call instruction. It is up to display tools to find
	// the beginning of the instruction if necessary.
	Address uint64 `protobuf:"varint,2,opt,name=address,proto3" json:"address,omitempty"`
	// Multiple line indicates this location has inlined functions,
	// where the last entry represents the caller into which the
	// preceding entries were inlined.
	//
	// E.g., if memcpy() is inlined into printf:
	//    line[0].function_name == "memcpy"
	//    line[1].function_name == "printf"
	Line []*Line `protobuf:"bytes,3,rep,name=line,proto3" json:"line,omitempty"`
	// TODO(@petethepig): I wonder if we need something a little more specialized here
	AttributeSetIndices []uint32 `protobuf:"varint,5,rep,packed,name=attribute_set_indices,json=attributeSetIndices,proto3" json:"attribute_set_indices,omitempty"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}
func (*Location) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c7ccddd4b033, []int{7}
}
func (m *Location) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Location) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Location.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Location) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Location.Merge(m, src)
}
func (m *Location) XXX_Size() int {
	return m.Size()
}
func (m *Location) XXX_DiscardUnknown() {
	xxx_messageInfo_Location.DiscardUnknown(m)
}

var xxx_messageInfo_Location proto.InternalMessageInfo

func (m *Location) GetMappingIndex() uint32 {
	if m != nil {
		return m.MappingIndex
	}
	return 0
}

func (m *Location) GetAddress() uint64 {
	if m != nil {
		return m.Address
	}
	return 0
}

func (m *Location) GetLine() []*Line {
	if m != nil {
		return m.Line
	}
	return nil
}

func (m *Location) GetAttributeSetIndices() []uint32 {
	if m != nil {
		return m.AttributeSetIndices
	}
	return nil
}

// borrowed from pprof proto
type Line struct {
	// The id of the corresponding profile.Function for this line.
	FunctionIndex uint32 `protobuf:"varint,1,opt,name=function_index,json=functionIndex,proto3" json:"function_index,omitempty"`
	// Line number in source code.
	Line uint32 `protobuf:"varint,2,opt,name=line,proto3" json:"line,omitempty"`
}

func (m *Line) Reset()         { *m = Line{} }
func (m *Line) String() string { return proto.CompactTextString(m) }
func (*Line) ProtoMessage()    {}
func (*Line) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c7ccddd4b033, []int{8}
}
func (m *Line) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Line) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Line.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Line) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Line.Merge(m, src)
}
func (m *Line) XXX_Size() int {
	return m.Size()
}
func (m *Line) XXX_DiscardUnknown() {
	xxx_messageInfo_Line.DiscardUnknown(m)
}

var xxx_messageInfo_Line proto.InternalMessageInfo

func (m *Line) GetFunctionIndex() uint32 {
	if m != nil {
		return m.FunctionIndex
	}
	return 0
}

func (m *Line) GetLine() uint32 {
	if m != nil {
		return m.Line
	}
	return 0
}

// borrowed from pprof proto
type Function struct {
	// Name of the function, in human-readable form if available.
	NameIndex uint32 `protobuf:"varint,1,opt,name=name_index,json=nameIndex,proto3" json:"name_index,omitempty"`
	// Name of the function, as identified by the system.
	// For instance, it can be a C++ mangled name.
	SystemNameIndex uint32 `protobuf:"varint,2,opt,name=system_name_index,json=systemNameIndex,proto3" json:"system_name_index,omitempty"`
	// Source file containing the function.
	FilenameIndex uint32 `protobuf:"varint,3,opt,name=filename_index,json=filenameIndex,proto3" json:"filename_index,omitempty"`
	// Line number in source file.
	StartLine uint32 `protobuf:"varint,4,opt,name=start_line,json=startLine,proto3" json:"start_line,omitempty"`
}

func (m *Function) Reset()         { *m = Function{} }
func (m *Function) String() string { return proto.CompactTextString(m) }
func (*Function) ProtoMessage()    {}
func (*Function) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c7ccddd4b033, []int{9}
}
func (m *Function) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Function) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Function.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Function) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Function.Merge(m, src)
}
func (m *Function) XXX_Size() int {
	return m.Size()
}
func (m *Function) XXX_DiscardUnknown() {
	xxx_messageInfo_Function.DiscardUnknown(m)
}

var xxx_messageInfo_Function proto.InternalMessageInfo

func (m *Function) GetNameIndex() uint32 {
	if m != nil {
		return m.NameIndex
	}
	return 0
}

func (m *Function) GetSystemNameIndex() uint32 {
	if m != nil {
		return m.SystemNameIndex
	}
	return 0
}

func (m *Function) GetFilenameIndex() uint32 {
	if m != nil {
		return m.FilenameIndex
	}
	return 0
}

func (m *Function) GetStartLine() uint32 {
	if m != nil {
		return m.StartLine
	}
	return 0
}

func init() {
	proto.RegisterEnum("opentelemetry.proto.profiles.v1.alternatives.normalized.SampleType_AggregationTemporality", SampleType_AggregationTemporality_name, SampleType_AggregationTemporality_value)
	proto.RegisterEnum("opentelemetry.proto.profiles.v1.alternatives.normalized.Mapping_SymbolFidelity", Mapping_SymbolFidelity_name, Mapping_SymbolFidelity_value)
	proto.RegisterType((*Link)(nil), "opentelemetry.proto.profiles.v1.alternatives.normalized.Link")
	proto.RegisterType((*AttributeSet)(nil), "opentelemetry.proto.profiles.v1.alternatives.normalized.AttributeSet")
	proto.RegisterType((*Stacktrace)(nil), "opentelemetry.proto.profiles.v1.alternatives.normalized.Stacktrace")
	proto.RegisterType((*Sample)(nil), "opentelemetry.proto.profiles.v1.alternatives.normalized.Sample")
	proto.RegisterType((*SampleType)(nil), "opentelemetry.proto.profiles.v1.alternatives.normalized.SampleType")
	proto.RegisterType((*Profile)(nil), "opentelemetry.proto.profiles.v1.alternatives.normalized.Profile")
	proto.RegisterType((*Mapping)(nil), "opentelemetry.proto.profiles.v1.alternatives.normalized.Mapping")
	proto.RegisterType((*Location)(nil), "opentelemetry.proto.profiles.v1.alternatives.normalized.Location")
	proto.RegisterType((*Line)(nil), "opentelemetry.proto.profiles.v1.alternatives.normalized.Line")
	proto.RegisterType((*Function)(nil), "opentelemetry.proto.profiles.v1.alternatives.normalized.Function")
}

func init() {
	proto.RegisterFile("opentelemetry/proto/profiles/v1/alternatives/normalized/normalized.proto", fileDescriptor_2a46c7ccddd4b033)
}

var fileDescriptor_2a46c7ccddd4b033 = []byte{
	// 1176 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x4d, 0x6f, 0xdb, 0x36,
	0x18, 0x8e, 0x62, 0xc7, 0x4e, 0x5e, 0xdb, 0x69, 0xca, 0x76, 0x99, 0xd0, 0x21, 0x1f, 0x55, 0xb7,
	0x35, 0xeb, 0x41, 0x46, 0xb3, 0x43, 0xbb, 0xc3, 0xb0, 0x3a, 0x89, 0xd3, 0x09, 0x75, 0x92, 0x56,
	0x76, 0x0a, 0xb4, 0x18, 0x20, 0x30, 0x16, 0x6d, 0x10, 0x91, 0x28, 0x41, 0xa4, 0x83, 0xba, 0xbf,
	0x61, 0x87, 0x02, 0x3b, 0xec, 0xb0, 0xbf, 0xb1, 0xcb, 0x4e, 0xbb, 0xf6, 0x58, 0xec, 0x34, 0xec,
	0x50, 0x0c, 0xcd, 0x1f, 0x19, 0xf8, 0x21, 0x7f, 0x6c, 0xce, 0xa1, 0xc9, 0x2e, 0x02, 0xf5, 0xf0,
	0xe1, 0xf3, 0xf2, 0xfd, 0xe0, 0x4b, 0xc2, 0xf7, 0x49, 0x4a, 0x98, 0x20, 0x11, 0x89, 0x89, 0xc8,
	0x86, 0xf5, 0x34, 0x4b, 0x44, 0x22, 0xbf, 0x3d, 0x1a, 0x11, 0x5e, 0x3f, 0xbb, 0x5f, 0xc7, 0x91,
	0x20, 0x19, 0xc3, 0x82, 0x9e, 0x11, 0x5e, 0x67, 0x49, 0x16, 0xe3, 0x88, 0xbe, 0x26, 0xe1, 0xc4,
	0xd0, 0x55, 0x8b, 0xd0, 0x83, 0x29, 0x25, 0x0d, 0xba, 0xb9, 0x92, 0x7b, 0x76, 0xdf, 0x9d, 0x54,
	0x72, 0xc7, 0xcb, 0x6f, 0xdd, 0xec, 0x27, 0xfd, 0x44, 0x1b, 0x96, 0x23, 0xbd, 0xf2, 0xd6, 0xbd,
	0x59, 0x1b, 0xeb, 0x26, 0x71, 0x9c, 0x30, 0xb9, 0x2d, 0x3d, 0x32, 0x5c, 0x77, 0x16, 0x37, 0x23,
	0x3c, 0x19, 0x64, 0x5d, 0x22, 0xd9, 0xf9, 0x58, 0xf3, 0x9d, 0xdf, 0x2d, 0x28, 0xb6, 0x28, 0x3b,
	0x45, 0x3f, 0xc0, 0xa2, 0xc8, 0x70, 0x97, 0x04, 0x34, 0xb4, 0xad, 0x4d, 0x6b, 0xab, 0xba, 0xd3,
	0x78, 0xfb, 0x7e, 0x63, 0xee, 0xaf, 0xf7, 0x1b, 0xdf, 0xf4, 0x93, 0x69, 0x55, 0x97, 0x4a, 0xf3,
	0x51, 0x44, 0xba, 0x22, 0xc9, 0xea, 0x69, 0x88, 0x05, 0xae, 0x53, 0xa6, 0x3c, 0x8a, 0xea, 0xf2,
	0xcf, 0xed, 0x48, 0x25, 0x6f, 0xcf, 0x2f, 0x2b, 0x49, 0x2f, 0x44, 0x2f, 0xa0, 0xcc, 0x53, 0xcc,
	0xa4, 0xf8, 0xbc, 0x12, 0x7f, 0x64, 0xc4, 0x1f, 0x7e, 0xbc, 0x78, 0x3b, 0xc5, 0xcc, 0xdb, 0xf3,
	0x4b, 0x52, 0xd0, 0x0b, 0x9d, 0x9f, 0x2d, 0xa8, 0x36, 0x84, 0xc8, 0xe8, 0xc9, 0x40, 0x90, 0x36,
	0x11, 0xe8, 0x00, 0x00, 0xe7, 0xff, 0xdc, 0xb6, 0x36, 0x0b, 0x5b, 0x95, 0xed, 0xbb, 0xee, 0xac,
	0x94, 0x98, 0xc8, 0x9d, 0xdd, 0x77, 0x9f, 0x90, 0xe1, 0x73, 0x1c, 0x0d, 0xc8, 0x4e, 0x51, 0xee,
	0xcb, 0x9f, 0x10, 0x40, 0x0f, 0xc1, 0x0e, 0xb3, 0x24, 0x4d, 0x49, 0x18, 0x8c, 0xd1, 0xa0, 0x9b,
	0x0c, 0x98, 0x50, 0xbe, 0xd4, 0xfc, 0x55, 0x33, 0x3f, 0xda, 0x05, 0xdf, 0x95, 0xb3, 0xce, 0x03,
	0x80, 0xb6, 0xc0, 0xdd, 0x53, 0x15, 0x04, 0xf4, 0x15, 0xac, 0x44, 0x49, 0x17, 0x0b, 0x9a, 0xb0,
	0x80, 0xb2, 0x90, 0x76, 0xcd, 0xe6, 0x6a, 0xfe, 0xb5, 0x1c, 0xf7, 0x34, 0xec, 0xfc, 0x61, 0x41,
	0xa9, 0x8d, 0xe3, 0x34, 0x52, 0xab, 0xf8, 0x48, 0x43, 0xae, 0x23, 0xaf, 0x54, 0x7a, 0x6a, 0xfe,
	0xb5, 0x31, 0xee, 0x49, 0x18, 0xdd, 0x86, 0x6a, 0x44, 0xd9, 0xe9, 0x48, 0x7c, 0x5e, 0x89, 0x57,
	0x24, 0x66, 0x84, 0xd1, 0x36, 0x7c, 0x32, 0xf2, 0x21, 0xe0, 0x44, 0x8c, 0xb8, 0x05, 0xc5, 0xbd,
	0x81, 0x27, 0xe2, 0x98, 0xaf, 0x59, 0x85, 0xd2, 0x99, 0x0c, 0x0d, 0xb7, 0x8b, 0x9b, 0x85, 0xad,
	0x82, 0x6f, 0xfe, 0x90, 0x0b, 0x37, 0x04, 0x8d, 0x09, 0x17, 0x38, 0x4e, 0x83, 0x01, 0xa3, 0xaf,
	0x02, 0x86, 0x59, 0x62, 0x2f, 0x6c, 0x5a, 0x5b, 0x25, 0xff, 0xfa, 0x68, 0xea, 0x98, 0xd1, 0x57,
	0x87, 0x98, 0x25, 0xce, 0x9b, 0x02, 0x80, 0x76, 0xaa, 0x33, 0x4c, 0x09, 0xfa, 0xc9, 0x82, 0x4f,
	0x71, 0xbf, 0x9f, 0x91, 0xbe, 0x0e, 0x89, 0x20, 0x71, 0x9a, 0x64, 0x38, 0xa2, 0x62, 0xa8, 0x1c,
	0x5c, 0xde, 0x7e, 0xe9, 0x5e, 0xf2, 0x18, 0xb9, 0x63, 0x33, 0x6e, 0x63, 0x6c, 0xa2, 0x33, 0xb6,
	0xe0, 0xaf, 0xe2, 0x99, 0x38, 0xda, 0x80, 0x0a, 0x57, 0x8b, 0x03, 0x4e, 0x5f, 0x13, 0x95, 0xdf,
	0xa2, 0x0f, 0x1a, 0x6a, 0xd3, 0xd7, 0x04, 0xad, 0x01, 0x88, 0x61, 0x9a, 0x67, 0xa2, 0xa0, 0x32,
	0xb1, 0x24, 0x11, 0x9d, 0x83, 0x35, 0x80, 0x01, 0xa3, 0xc2, 0x4c, 0x17, 0xf5, 0xb4, 0x44, 0xd4,
	0xb4, 0xf3, 0xa3, 0x05, 0xab, 0xb3, 0x77, 0x84, 0xee, 0xc2, 0x9d, 0xc6, 0xe3, 0xc7, 0x7e, 0xf3,
	0x71, 0xa3, 0xe3, 0x1d, 0x1d, 0x06, 0x9d, 0xe6, 0xc1, 0xd3, 0x23, 0xbf, 0xd1, 0xf2, 0x3a, 0x2f,
	0x82, 0xe3, 0xc3, 0xf6, 0xd3, 0xe6, 0xae, 0xb7, 0xef, 0x35, 0xf7, 0x56, 0xe6, 0xd0, 0x6d, 0x58,
	0xbb, 0x88, 0xb8, 0xd7, 0x6c, 0x75, 0x1a, 0x2b, 0x16, 0xfa, 0x12, 0x9c, 0x8b, 0x28, 0xbb, 0xc7,
	0x07, 0xc7, 0xad, 0x46, 0xc7, 0x7b, 0xde, 0x5c, 0x99, 0x77, 0x7e, 0x2b, 0x41, 0xf9, 0xa9, 0x8e,
	0x27, 0xea, 0x41, 0xd5, 0x78, 0x2e, 0xbd, 0xc9, 0xcf, 0xcd, 0xee, 0xff, 0x90, 0x03, 0xdf, 0x84,
	0x54, 0x8e, 0x39, 0x22, 0x50, 0x19, 0x17, 0xae, 0x2e, 0xd2, 0x2b, 0x99, 0x19, 0x69, 0xf9, 0x93,
	0xba, 0xaa, 0xe1, 0x28, 0xab, 0xba, 0xb6, 0x2b, 0xdb, 0xdf, 0x5d, 0xd1, 0x13, 0x3f, 0xd7, 0x93,
	0x9d, 0x32, 0xc6, 0x69, 0x4a, 0x59, 0x5f, 0x1f, 0x89, 0xca, 0xf6, 0xa3, 0x4b, 0x6b, 0x1f, 0x68,
	0x21, 0x7f, 0xa4, 0x88, 0x02, 0x58, 0xca, 0xdb, 0x01, 0xb7, 0x17, 0x94, 0x7c, 0xe3, 0xd2, 0xf2,
	0x2d, 0xa3, 0xe4, 0x8f, 0x35, 0xa5, 0x81, 0xde, 0x80, 0x75, 0xb5, 0x81, 0xd2, 0x15, 0x0d, 0xec,
	0x1b, 0x25, 0x7f, 0xac, 0x89, 0xda, 0xb0, 0x20, 0x7b, 0x0e, 0xb7, 0xcb, 0x4a, 0xfc, 0xdb, 0xcb,
	0xef, 0x9e, 0xb2, 0x53, 0x5f, 0x6b, 0xa1, 0x08, 0x96, 0xa7, 0x3a, 0x17, 0xb7, 0x17, 0x95, 0x7a,
	0xf3, 0xd2, 0xea, 0x93, 0x77, 0x86, 0x5f, 0x9b, 0xec, 0x7c, 0x5c, 0xb6, 0x52, 0x2e, 0x32, 0xca,
	0xfa, 0x81, 0xc0, 0x27, 0x11, 0xb1, 0x97, 0x36, 0x0b, 0x5b, 0x4b, 0xb2, 0xc0, 0x24, 0xd6, 0x91,
	0x90, 0xf3, 0x6b, 0x01, 0xca, 0x26, 0x7b, 0x92, 0x1e, 0x93, 0x38, 0xc9, 0x86, 0x01, 0x17, 0x38,
	0x13, 0xaa, 0x7f, 0x15, 0xfd, 0x8a, 0xc6, 0xda, 0x12, 0x9a, 0xa0, 0x44, 0x34, 0xa6, 0xc2, 0x74,
	0x16, 0x43, 0x69, 0x49, 0x48, 0xf6, 0x1e, 0xb9, 0xe9, 0x20, 0xe9, 0xf5, 0x38, 0x11, 0xaa, 0xb7,
	0x14, 0x7d, 0x90, 0xd0, 0x91, 0x42, 0xd0, 0x17, 0xb0, 0x2c, 0xff, 0x18, 0x8e, 0xc9, 0x54, 0x83,
	0xa9, 0xe5, 0xa8, 0xee, 0x41, 0x9f, 0xc3, 0xf2, 0xc9, 0x80, 0x46, 0x61, 0x40, 0x43, 0x43, 0x5b,
	0x50, 0xb4, 0xaa, 0x42, 0xbd, 0x50, 0xb3, 0x04, 0xd4, 0xf8, 0x30, 0x3e, 0x49, 0x22, 0xda, 0x0d,
	0x28, 0xeb, 0x25, 0x76, 0x49, 0x35, 0xdd, 0xa3, 0xab, 0x96, 0xb2, 0xdb, 0x56, 0xaa, 0xfb, 0x34,
	0x24, 0xaa, 0xd3, 0x56, 0x73, 0x2b, 0x1e, 0xeb, 0x25, 0x17, 0x5f, 0x40, 0xe5, 0x0b, 0x2f, 0x20,
	0xe7, 0x09, 0x2c, 0x4f, 0x6b, 0xa2, 0x0d, 0xf8, 0xac, 0xfd, 0xe2, 0x60, 0xe7, 0xa8, 0x15, 0xec,
	0x7b, 0x7b, 0xcd, 0x19, 0x3d, 0xd2, 0x86, 0x9b, 0xff, 0x26, 0xec, 0x1f, 0xb7, 0x5a, 0x2b, 0x96,
	0xf3, 0xce, 0x82, 0xc5, 0xfc, 0x54, 0xa0, 0x3b, 0x50, 0x33, 0xe7, 0x6e, 0xea, 0x66, 0xad, 0x1a,
	0x50, 0x07, 0xca, 0x86, 0x32, 0x0e, 0xc3, 0x8c, 0x70, 0x6e, 0x92, 0x96, 0xff, 0xa2, 0x67, 0x50,
	0x8c, 0x28, 0x23, 0xa6, 0xc1, 0x5c, 0xa9, 0xce, 0x89, 0xaf, 0xa4, 0x2e, 0x8e, 0xcf, 0xc2, 0xc5,
	0xf1, 0x69, 0xa8, 0x17, 0x1c, 0x51, 0xe5, 0x61, 0x0e, 0xe1, 0x94, 0x3b, 0xb5, 0x1c, 0xd5, 0xfe,
	0x20, 0xb3, 0x6b, 0xfd, 0x76, 0x51, 0x63, 0xe7, 0x17, 0x0b, 0x16, 0xf3, 0xa3, 0x2c, 0xef, 0xb0,
	0x89, 0x12, 0xd3, 0x1a, 0x4b, 0xe3, 0xf2, 0xba, 0x07, 0xd7, 0xf9, 0x90, 0x0b, 0x12, 0x07, 0x13,
	0xac, 0x79, 0xf3, 0x24, 0x51, 0x13, 0x87, 0x23, 0xee, 0x7f, 0x2b, 0xb6, 0x30, 0xab, 0x62, 0xd7,
	0x00, 0xd4, 0xc1, 0x09, 0xd4, 0xc6, 0xcc, 0xad, 0xa9, 0x10, 0xe9, 0xd8, 0xce, 0xe9, 0xdb, 0x0f,
	0xeb, 0xd6, 0xbb, 0x0f, 0xeb, 0xd6, 0xdf, 0x1f, 0xd6, 0xad, 0x37, 0xe7, 0xeb, 0x73, 0xef, 0xce,
	0xd7, 0xe7, 0xfe, 0x3c, 0x5f, 0x9f, 0x7b, 0xf9, 0xec, 0xa3, 0x5f, 0x8f, 0xfa, 0x45, 0xdc, 0x27,
	0x6c, 0xea, 0x65, 0x3f, 0x4e, 0xc6, 0x49, 0x49, 0x11, 0xbe, 0xfe, 0x27, 0x00, 0x00, 0xff, 0xff,
	0xa3, 0x05, 0x53, 0x47, 0x0e, 0x0c, 0x00, 0x00,
}

func (m *Link) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Link) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Link) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SpanId.Size()
		i -= size
		if _, err := m.SpanId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintNormalized(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TraceId.Size()
		i -= size
		if _, err := m.TraceId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintNormalized(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AttributeSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttributeSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttributeSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DroppedAttributesCount != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.DroppedAttributesCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNormalized(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Stacktrace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stacktrace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stacktrace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LocationIndices) > 0 {
		dAtA2 := make([]byte, len(m.LocationIndices)*10)
		var j1 int
		for _, num := range m.LocationIndices {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintNormalized(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Sample) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sample) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sample) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimestampUnixNano != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.TimestampUnixNano))
		i--
		dAtA[i] = 0x29
	}
	if len(m.Values) > 0 {
		dAtA4 := make([]byte, len(m.Values)*10)
		var j3 int
		for _, num1 := range m.Values {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintNormalized(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AttributeSetIndices) > 0 {
		dAtA6 := make([]byte, len(m.AttributeSetIndices)*10)
		var j5 int
		for _, num := range m.AttributeSetIndices {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintNormalized(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.LinkIndices) > 0 {
		dAtA8 := make([]byte, len(m.LinkIndices)*10)
		var j7 int
		for _, num := range m.LinkIndices {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintNormalized(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x12
	}
	if m.StacktraceIndex != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.StacktraceIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SampleType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SampleType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SampleType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UnitIndex != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.UnitIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.TypeIndex != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.TypeIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.SampleSize != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.SampleSize))
		i--
		dAtA[i] = 0x10
	}
	if m.AggregationTemporality != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.AggregationTemporality))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Profile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Profile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Profile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StringTable) > 0 {
		for iNdEx := len(m.StringTable) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StringTable[iNdEx])
			copy(dAtA[i:], m.StringTable[iNdEx])
			i = encodeVarintNormalized(dAtA, i, uint64(len(m.StringTable[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.AttributeSets) > 0 {
		for iNdEx := len(m.AttributeSets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AttributeSets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNormalized(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Links) > 0 {
		for iNdEx := len(m.Links) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Links[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNormalized(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Functions) > 0 {
		for iNdEx := len(m.Functions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Functions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNormalized(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Locations) > 0 {
		for iNdEx := len(m.Locations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Locations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNormalized(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Mappings) > 0 {
		for iNdEx := len(m.Mappings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Mappings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNormalized(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Samples) > 0 {
		for iNdEx := len(m.Samples) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Samples[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNormalized(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Stacktraces) > 0 {
		for iNdEx := len(m.Stacktraces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Stacktraces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNormalized(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SampleTypes) > 0 {
		for iNdEx := len(m.SampleTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SampleTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNormalized(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Mapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttributeSetIndices) > 0 {
		dAtA10 := make([]byte, len(m.AttributeSetIndices)*10)
		var j9 int
		for _, num := range m.AttributeSetIndices {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintNormalized(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x3a
	}
	if m.SymbolicInfo != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.SymbolicInfo))
		i--
		dAtA[i] = 0x30
	}
	if m.BuildIdIndex != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.BuildIdIndex))
		i--
		dAtA[i] = 0x28
	}
	if m.FilenameIndex != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.FilenameIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.FileOffset != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.FileOffset))
		i--
		dAtA[i] = 0x18
	}
	if m.MemoryLimit != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.MemoryLimit))
		i--
		dAtA[i] = 0x10
	}
	if m.MemoryStart != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.MemoryStart))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Location) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttributeSetIndices) > 0 {
		dAtA12 := make([]byte, len(m.AttributeSetIndices)*10)
		var j11 int
		for _, num := range m.AttributeSetIndices {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintNormalized(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Line) > 0 {
		for iNdEx := len(m.Line) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Line[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNormalized(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Address != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.Address))
		i--
		dAtA[i] = 0x10
	}
	if m.MappingIndex != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.MappingIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Line) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Line) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Line) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Line != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.Line))
		i--
		dAtA[i] = 0x10
	}
	if m.FunctionIndex != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.FunctionIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Function) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Function) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Function) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StartLine != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.StartLine))
		i--
		dAtA[i] = 0x20
	}
	if m.FilenameIndex != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.FilenameIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.SystemNameIndex != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.SystemNameIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.NameIndex != 0 {
		i = encodeVarintNormalized(dAtA, i, uint64(m.NameIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintNormalized(dAtA []byte, offset int, v uint64) int {
	offset -= sovNormalized(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Link) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TraceId.Size()
	n += 1 + l + sovNormalized(uint64(l))
	l = m.SpanId.Size()
	n += 1 + l + sovNormalized(uint64(l))
	return n
}

func (m *AttributeSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovNormalized(uint64(l))
		}
	}
	if m.DroppedAttributesCount != 0 {
		n += 1 + sovNormalized(uint64(m.DroppedAttributesCount))
	}
	return n
}

func (m *Stacktrace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LocationIndices) > 0 {
		l = 0
		for _, e := range m.LocationIndices {
			l += sovNormalized(uint64(e))
		}
		n += 1 + sovNormalized(uint64(l)) + l
	}
	return n
}

func (m *Sample) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StacktraceIndex != 0 {
		n += 1 + sovNormalized(uint64(m.StacktraceIndex))
	}
	if len(m.LinkIndices) > 0 {
		l = 0
		for _, e := range m.LinkIndices {
			l += sovNormalized(uint64(e))
		}
		n += 1 + sovNormalized(uint64(l)) + l
	}
	if len(m.AttributeSetIndices) > 0 {
		l = 0
		for _, e := range m.AttributeSetIndices {
			l += sovNormalized(uint64(e))
		}
		n += 1 + sovNormalized(uint64(l)) + l
	}
	if len(m.Values) > 0 {
		l = 0
		for _, e := range m.Values {
			l += sovNormalized(uint64(e))
		}
		n += 1 + sovNormalized(uint64(l)) + l
	}
	if m.TimestampUnixNano != 0 {
		n += 9
	}
	return n
}

func (m *SampleType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregationTemporality != 0 {
		n += 1 + sovNormalized(uint64(m.AggregationTemporality))
	}
	if m.SampleSize != 0 {
		n += 1 + sovNormalized(uint64(m.SampleSize))
	}
	if m.TypeIndex != 0 {
		n += 1 + sovNormalized(uint64(m.TypeIndex))
	}
	if m.UnitIndex != 0 {
		n += 1 + sovNormalized(uint64(m.UnitIndex))
	}
	return n
}

func (m *Profile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SampleTypes) > 0 {
		for _, e := range m.SampleTypes {
			l = e.Size()
			n += 1 + l + sovNormalized(uint64(l))
		}
	}
	if len(m.Stacktraces) > 0 {
		for _, e := range m.Stacktraces {
			l = e.Size()
			n += 1 + l + sovNormalized(uint64(l))
		}
	}
	if len(m.Samples) > 0 {
		for _, e := range m.Samples {
			l = e.Size()
			n += 1 + l + sovNormalized(uint64(l))
		}
	}
	if len(m.Mappings) > 0 {
		for _, e := range m.Mappings {
			l = e.Size()
			n += 1 + l + sovNormalized(uint64(l))
		}
	}
	if len(m.Locations) > 0 {
		for _, e := range m.Locations {
			l = e.Size()
			n += 1 + l + sovNormalized(uint64(l))
		}
	}
	if len(m.Functions) > 0 {
		for _, e := range m.Functions {
			l = e.Size()
			n += 1 + l + sovNormalized(uint64(l))
		}
	}
	if len(m.Links) > 0 {
		for _, e := range m.Links {
			l = e.Size()
			n += 1 + l + sovNormalized(uint64(l))
		}
	}
	if len(m.AttributeSets) > 0 {
		for _, e := range m.AttributeSets {
			l = e.Size()
			n += 1 + l + sovNormalized(uint64(l))
		}
	}
	if len(m.StringTable) > 0 {
		for _, s := range m.StringTable {
			l = len(s)
			n += 1 + l + sovNormalized(uint64(l))
		}
	}
	return n
}

func (m *Mapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemoryStart != 0 {
		n += 1 + sovNormalized(uint64(m.MemoryStart))
	}
	if m.MemoryLimit != 0 {
		n += 1 + sovNormalized(uint64(m.MemoryLimit))
	}
	if m.FileOffset != 0 {
		n += 1 + sovNormalized(uint64(m.FileOffset))
	}
	if m.FilenameIndex != 0 {
		n += 1 + sovNormalized(uint64(m.FilenameIndex))
	}
	if m.BuildIdIndex != 0 {
		n += 1 + sovNormalized(uint64(m.BuildIdIndex))
	}
	if m.SymbolicInfo != 0 {
		n += 1 + sovNormalized(uint64(m.SymbolicInfo))
	}
	if len(m.AttributeSetIndices) > 0 {
		l = 0
		for _, e := range m.AttributeSetIndices {
			l += sovNormalized(uint64(e))
		}
		n += 1 + sovNormalized(uint64(l)) + l
	}
	return n
}

func (m *Location) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MappingIndex != 0 {
		n += 1 + sovNormalized(uint64(m.MappingIndex))
	}
	if m.Address != 0 {
		n += 1 + sovNormalized(uint64(m.Address))
	}
	if len(m.Line) > 0 {
		for _, e := range m.Line {
			l = e.Size()
			n += 1 + l + sovNormalized(uint64(l))
		}
	}
	if len(m.AttributeSetIndices) > 0 {
		l = 0
		for _, e := range m.AttributeSetIndices {
			l += sovNormalized(uint64(e))
		}
		n += 1 + sovNormalized(uint64(l)) + l
	}
	return n
}

func (m *Line) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionIndex != 0 {
		n += 1 + sovNormalized(uint64(m.FunctionIndex))
	}
	if m.Line != 0 {
		n += 1 + sovNormalized(uint64(m.Line))
	}
	return n
}

func (m *Function) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NameIndex != 0 {
		n += 1 + sovNormalized(uint64(m.NameIndex))
	}
	if m.SystemNameIndex != 0 {
		n += 1 + sovNormalized(uint64(m.SystemNameIndex))
	}
	if m.FilenameIndex != 0 {
		n += 1 + sovNormalized(uint64(m.FilenameIndex))
	}
	if m.StartLine != 0 {
		n += 1 + sovNormalized(uint64(m.StartLine))
	}
	return n
}

func sovNormalized(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNormalized(x uint64) (n int) {
	return sovNormalized(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Link) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNormalized
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNormalized
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNormalized
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TraceId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNormalized
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNormalized
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SpanId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNormalized(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNormalized
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttributeSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNormalized
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttributeSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttributeSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNormalized
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNormalized
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, v1.KeyValue{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedAttributesCount", wireType)
			}
			m.DroppedAttributesCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DroppedAttributesCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNormalized(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNormalized
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stacktrace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNormalized
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stacktrace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stacktrace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNormalized
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LocationIndices = append(m.LocationIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNormalized
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNormalized
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNormalized
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LocationIndices) == 0 {
					m.LocationIndices = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNormalized
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LocationIndices = append(m.LocationIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationIndices", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNormalized(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNormalized
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sample) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNormalized
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sample: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sample: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StacktraceIndex", wireType)
			}
			m.StacktraceIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StacktraceIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNormalized
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LinkIndices = append(m.LinkIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNormalized
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNormalized
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNormalized
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LinkIndices) == 0 {
					m.LinkIndices = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNormalized
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LinkIndices = append(m.LinkIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkIndices", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNormalized
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AttributeSetIndices = append(m.AttributeSetIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNormalized
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNormalized
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNormalized
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AttributeSetIndices) == 0 {
					m.AttributeSetIndices = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNormalized
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AttributeSetIndices = append(m.AttributeSetIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeSetIndices", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNormalized
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Values = append(m.Values, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNormalized
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNormalized
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNormalized
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Values) == 0 {
					m.Values = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNormalized
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Values = append(m.Values, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampUnixNano", wireType)
			}
			m.TimestampUnixNano = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.TimestampUnixNano = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipNormalized(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNormalized
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SampleType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNormalized
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SampleType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SampleType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationTemporality", wireType)
			}
			m.AggregationTemporality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AggregationTemporality |= SampleType_AggregationTemporality(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleSize", wireType)
			}
			m.SampleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeIndex", wireType)
			}
			m.TypeIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitIndex", wireType)
			}
			m.UnitIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNormalized(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNormalized
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Profile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNormalized
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Profile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Profile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNormalized
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNormalized
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SampleTypes = append(m.SampleTypes, &SampleType{})
			if err := m.SampleTypes[len(m.SampleTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stacktraces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNormalized
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNormalized
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stacktraces = append(m.Stacktraces, &Stacktrace{})
			if err := m.Stacktraces[len(m.Stacktraces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Samples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNormalized
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNormalized
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Samples = append(m.Samples, &Sample{})
			if err := m.Samples[len(m.Samples)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNormalized
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNormalized
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mappings = append(m.Mappings, &Mapping{})
			if err := m.Mappings[len(m.Mappings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNormalized
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNormalized
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locations = append(m.Locations, &Location{})
			if err := m.Locations[len(m.Locations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Functions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNormalized
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNormalized
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Functions = append(m.Functions, &Function{})
			if err := m.Functions[len(m.Functions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNormalized
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNormalized
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, &Link{})
			if err := m.Links[len(m.Links)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNormalized
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNormalized
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttributeSets = append(m.AttributeSets, &AttributeSet{})
			if err := m.AttributeSets[len(m.AttributeSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringTable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNormalized
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNormalized
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringTable = append(m.StringTable, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNormalized(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNormalized
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNormalized
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryStart", wireType)
			}
			m.MemoryStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryStart |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryLimit", wireType)
			}
			m.MemoryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileOffset", wireType)
			}
			m.FileOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileOffset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilenameIndex", wireType)
			}
			m.FilenameIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilenameIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildIdIndex", wireType)
			}
			m.BuildIdIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildIdIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SymbolicInfo", wireType)
			}
			m.SymbolicInfo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SymbolicInfo |= Mapping_SymbolFidelity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNormalized
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AttributeSetIndices = append(m.AttributeSetIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNormalized
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNormalized
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNormalized
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AttributeSetIndices) == 0 {
					m.AttributeSetIndices = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNormalized
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AttributeSetIndices = append(m.AttributeSetIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeSetIndices", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNormalized(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNormalized
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNormalized
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappingIndex", wireType)
			}
			m.MappingIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MappingIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			m.Address = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Address |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNormalized
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNormalized
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Line = append(m.Line, &Line{})
			if err := m.Line[len(m.Line)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNormalized
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AttributeSetIndices = append(m.AttributeSetIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNormalized
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNormalized
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNormalized
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AttributeSetIndices) == 0 {
					m.AttributeSetIndices = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNormalized
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AttributeSetIndices = append(m.AttributeSetIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeSetIndices", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNormalized(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNormalized
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Line) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNormalized
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Line: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Line: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionIndex", wireType)
			}
			m.FunctionIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FunctionIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line", wireType)
			}
			m.Line = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Line |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNormalized(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNormalized
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Function) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNormalized
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Function: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Function: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameIndex", wireType)
			}
			m.NameIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NameIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemNameIndex", wireType)
			}
			m.SystemNameIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SystemNameIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilenameIndex", wireType)
			}
			m.FilenameIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilenameIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartLine", wireType)
			}
			m.StartLine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartLine |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNormalized(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNormalized
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNormalized(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNormalized
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNormalized
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNormalized
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNormalized
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNormalized
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNormalized        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNormalized          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNormalized = fmt.Errorf("proto: unexpected end of group")
)
