// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by "model/internal/cmd/pdatagen/main.go". DO NOT EDIT.
// To regenerate this file run "go run model/internal/cmd/pdatagen/main.go".

package pmetric

import (
	"sort"

	"go.opentelemetry.io/collector/pdata/internal"
	"go.opentelemetry.io/collector/pdata/internal/data"
	otlpmetrics "go.opentelemetry.io/collector/pdata/internal/data/protogen/metrics/v1"
	"go.opentelemetry.io/collector/pdata/pcommon"
)

// ResourceMetricsSlice logically represents a slice of ResourceMetrics.
//
// This is a reference type. If passed by value and callee modifies it, the
// caller will see the modification.
//
// Must use NewResourceMetricsSlice function to create new instances.
// Important: zero-initialized instance is not valid for use.
type ResourceMetricsSlice internal.ResourceMetricsSlice

type MutableResourceMetricsSlice internal.MutableResourceMetricsSlice

func newResourceMetricsSlice(orig *[]*otlpmetrics.ResourceMetrics) ResourceMetricsSlice {
	return ResourceMetricsSlice(internal.NewResourceMetricsSlice(orig))
}

func newMutableResourceMetricsSlice(orig *[]*otlpmetrics.ResourceMetrics) MutableResourceMetricsSlice {
	return MutableResourceMetricsSlice(internal.NewResourceMetricsSlice(orig))
}

func (ms ResourceMetricsSlice) getOrig() *[]*otlpmetrics.ResourceMetrics {
	return internal.GetOrigResourceMetricsSlice(internal.ResourceMetricsSlice(ms))
}

func (ms MutableResourceMetricsSlice) getOrig() *[]*otlpmetrics.ResourceMetrics {
	return internal.GetMutableOrigResourceMetricsSlice(internal.MutableResourceMetricsSlice(ms))
}

// NewResourceMetricsSlice creates a ResourceMetricsSlice with 0 elements.
// Can use "EnsureCapacity" to initialize with a given capacity.
func NewResourceMetricsSlice() MutableResourceMetricsSlice {
	orig := []*otlpmetrics.ResourceMetrics(nil)
	return newMutableResourceMetricsSlice(&orig)
}

// Len returns the number of elements in the slice.
//
// Returns "0" for a newly instance created with "NewResourceMetricsSlice()".
func (es ResourceMetricsSlice) Len() int {
	return len(*es.getOrig())
}

func (es MutableResourceMetricsSlice) Len() int {
	return len(*es.getOrig())
}

// At returns the element at the given index.
//
// This function is used mostly for iterating over all the values in the slice:
//
//	for i := 0; i < es.Len(); i++ {
//	    e := es.At(i)
//	    ... // Do something with the element
//	}
func (es ResourceMetricsSlice) At(ix int) ResourceMetrics {
	return newResourceMetrics((*es.getOrig())[ix])
}

func (es MutableResourceMetricsSlice) At(ix int) MutableResourceMetrics {
	return newMutableResourceMetrics((*es.getOrig())[ix])
}

// CopyTo copies all elements from the current slice overriding the destination.
func (es ResourceMetricsSlice) CopyTo(dest MutableResourceMetricsSlice) {
	srcLen := es.Len()
	destCap := cap(*dest.getOrig())
	if srcLen <= destCap {
		(*dest.getOrig()) = (*dest.getOrig())[:srcLen:destCap]
		for i := range *es.getOrig() {
			newResourceMetrics((*es.getOrig())[i]).CopyTo(newMutableResourceMetrics((*dest.getOrig())[i]))
		}
		return
	}
	origs := make([]otlpmetrics.ResourceMetrics, srcLen)
	wrappers := make([]*otlpmetrics.ResourceMetrics, srcLen)
	for i := range *es.getOrig() {
		wrappers[i] = &origs[i]
		newResourceMetrics((*es.getOrig())[i]).CopyTo(newMutableResourceMetrics(wrappers[i]))
	}
	*dest.getOrig() = wrappers
}

// CopyTo copies all elements from the current slice overriding the destination.
func (es MutableResourceMetricsSlice) CopyTo(dest MutableResourceMetricsSlice) {
	newResourceMetricsSlice(es.getOrig()).CopyTo(dest)
}

// EnsureCapacity is an operation that ensures the slice has at least the specified capacity.
// 1. If the newCap <= cap then no change in capacity.
// 2. If the newCap > cap then the slice capacity will be expanded to equal newCap.
//
// Here is how a new ResourceMetricsSlice can be initialized:
//
//	es := NewResourceMetricsSlice()
//	es.EnsureCapacity(4)
//	for i := 0; i < 4; i++ {
//	    e := es.AppendEmpty()
//	    // Here should set all the values for e.
//	}
func (es MutableResourceMetricsSlice) EnsureCapacity(newCap int) {
	oldCap := cap(*es.getOrig())
	if newCap <= oldCap {
		return
	}

	newOrig := make([]*otlpmetrics.ResourceMetrics, len(*es.getOrig()), newCap)
	copy(newOrig, *es.getOrig())
	*es.getOrig() = newOrig
}

// AppendEmpty will append to the end of the slice an empty ResourceMetrics.
// It returns the newly added ResourceMetrics.
func (es MutableResourceMetricsSlice) AppendEmpty() MutableResourceMetrics {
	*es.getOrig() = append(*es.getOrig(), &otlpmetrics.ResourceMetrics{})
	return es.At(es.Len() - 1)
}

// Sort sorts the ResourceMetrics elements within ResourceMetricsSlice given the
// provided less function so that two instances of ResourceMetricsSlice
// can be compared.
func (es MutableResourceMetricsSlice) Sort(less func(a, b MutableResourceMetrics) bool) {
	sort.SliceStable(*es.getOrig(), func(i, j int) bool { return less(es.At(i), es.At(j)) })
}

// MoveAndAppendTo moves all elements from the current slice and appends them to the dest.
// The current slice will be cleared.
func (es MutableResourceMetricsSlice) MoveAndAppendTo(dest MutableResourceMetricsSlice) {
	if *dest.getOrig() == nil {
		// We can simply move the entire vector and avoid any allocations.
		*dest.getOrig() = *es.getOrig()
	} else {
		*dest.getOrig() = append(*dest.getOrig(), *es.getOrig()...)
	}
	*es.getOrig() = nil
}

// RemoveIf calls f sequentially for each element present in the slice.
// If f returns true, the element is removed from the slice.
func (es MutableResourceMetricsSlice) RemoveIf(f func(MutableResourceMetrics) bool) {
	newLen := 0
	for i := 0; i < len(*es.getOrig()); i++ {
		if f(es.At(i)) {
			continue
		}
		if newLen == i {
			// Nothing to move, element is at the right place.
			newLen++
			continue
		}
		(*es.getOrig())[newLen] = (*es.getOrig())[i]
		newLen++
	}
	// TODO: Prevent memory leak by erasing truncated values.
	*es.getOrig() = (*es.getOrig())[:newLen]
}

// ResourceMetrics is a collection of metrics from a Resource.
//
// This is a reference type, if passed by value and callee modifies it the
// caller will see the modification.
//
// Must use NewResourceMetrics function to create new instances.
// Important: zero-initialized instance is not valid for use.

type ResourceMetrics internal.ResourceMetrics

type MutableResourceMetrics internal.MutableResourceMetrics

func newResourceMetrics(orig *otlpmetrics.ResourceMetrics) ResourceMetrics {
	return ResourceMetrics(internal.NewResourceMetrics(orig))
}

func newMutableResourceMetrics(orig *otlpmetrics.ResourceMetrics) MutableResourceMetrics {
	return MutableResourceMetrics(internal.NewResourceMetrics(orig))
}

func (ms ResourceMetrics) getOrig() *otlpmetrics.ResourceMetrics {
	return internal.GetOrigResourceMetrics(internal.ResourceMetrics(ms))
}

func (ms MutableResourceMetrics) getOrig() *otlpmetrics.ResourceMetrics {
	return internal.GetMutableOrigResourceMetrics(internal.MutableResourceMetrics(ms))
}

// NewResourceMetrics creates a new empty ResourceMetrics.
//
// This must be used only in testing code. Users should use "AppendEmpty" when part of a Slice,
// OR directly access the member if this is embedded in another struct.
func NewResourceMetrics() MutableResourceMetrics {
	return newMutableResourceMetrics(&otlpmetrics.ResourceMetrics{})
}

// MoveTo moves all properties from the current struct overriding the destination and
// resetting the current instance to its zero value
func (ms MutableResourceMetrics) MoveTo(dest MutableResourceMetrics) {
	*dest.getOrig() = *ms.getOrig()
	*ms.getOrig() = otlpmetrics.ResourceMetrics{}
}

// Resource returns the resource associated with this ResourceMetrics.
func (ms ResourceMetrics) Resource() pcommon.Resource {
	return pcommon.Resource(internal.NewResource(&ms.getOrig().Resource))
}

// Resource returns the resource associated with this ResourceMetrics.
func (ms MutableResourceMetrics) Resource() pcommon.MutableResource {
	return pcommon.MutableResource(internal.NewMutableResource(&ms.getOrig().Resource))
}

// SchemaUrl returns the schemaurl associated with this ResourceMetrics.
func (ms ResourceMetrics) SchemaUrl() string {
	return ms.getOrig().SchemaUrl
}

// MutableSchemaUrl returns the schemaurl associated with this ResourceMetrics.
func (ms MutableResourceMetrics) SchemaUrl() string {
	return ms.getOrig().SchemaUrl
}

// SetSchemaUrl replaces the schemaurl associated with this ResourceMetrics.
func (ms MutableResourceMetrics) SetSchemaUrl(v string) {
	ms.getOrig().SchemaUrl = v
}

// ScopeMetrics returns the ScopeMetrics associated with this ResourceMetrics.
func (ms ResourceMetrics) ScopeMetrics() ScopeMetricsSlice {
	return ScopeMetricsSlice(internal.NewScopeMetricsSlice(&ms.getOrig().ScopeMetrics))
}

// ScopeMetrics returns the ScopeMetrics associated with this ResourceMetrics.
func (ms MutableResourceMetrics) ScopeMetrics() MutableScopeMetricsSlice {
	return MutableScopeMetricsSlice(internal.NewMutableScopeMetricsSlice(&ms.getOrig().ScopeMetrics))
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms ResourceMetrics) CopyTo(dest MutableResourceMetrics) {
	ms.Resource().CopyTo(dest.Resource())
	dest.SetSchemaUrl(ms.SchemaUrl())
	ms.ScopeMetrics().CopyTo(dest.ScopeMetrics())
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms MutableResourceMetrics) CopyTo(dest MutableResourceMetrics) {
	newResourceMetrics(ms.getOrig()).CopyTo(dest)
}

// ScopeMetricsSlice logically represents a slice of ScopeMetrics.
//
// This is a reference type. If passed by value and callee modifies it, the
// caller will see the modification.
//
// Must use NewScopeMetricsSlice function to create new instances.
// Important: zero-initialized instance is not valid for use.
type ScopeMetricsSlice internal.ScopeMetricsSlice

type MutableScopeMetricsSlice internal.MutableScopeMetricsSlice

func newScopeMetricsSlice(orig *[]*otlpmetrics.ScopeMetrics) ScopeMetricsSlice {
	return ScopeMetricsSlice(internal.NewScopeMetricsSlice(orig))
}

func newMutableScopeMetricsSlice(orig *[]*otlpmetrics.ScopeMetrics) MutableScopeMetricsSlice {
	return MutableScopeMetricsSlice(internal.NewScopeMetricsSlice(orig))
}

func (ms ScopeMetricsSlice) getOrig() *[]*otlpmetrics.ScopeMetrics {
	return internal.GetOrigScopeMetricsSlice(internal.ScopeMetricsSlice(ms))
}

func (ms MutableScopeMetricsSlice) getOrig() *[]*otlpmetrics.ScopeMetrics {
	return internal.GetMutableOrigScopeMetricsSlice(internal.MutableScopeMetricsSlice(ms))
}

// NewScopeMetricsSlice creates a ScopeMetricsSlice with 0 elements.
// Can use "EnsureCapacity" to initialize with a given capacity.
func NewScopeMetricsSlice() MutableScopeMetricsSlice {
	orig := []*otlpmetrics.ScopeMetrics(nil)
	return newMutableScopeMetricsSlice(&orig)
}

// Len returns the number of elements in the slice.
//
// Returns "0" for a newly instance created with "NewScopeMetricsSlice()".
func (es ScopeMetricsSlice) Len() int {
	return len(*es.getOrig())
}

func (es MutableScopeMetricsSlice) Len() int {
	return len(*es.getOrig())
}

// At returns the element at the given index.
//
// This function is used mostly for iterating over all the values in the slice:
//
//	for i := 0; i < es.Len(); i++ {
//	    e := es.At(i)
//	    ... // Do something with the element
//	}
func (es ScopeMetricsSlice) At(ix int) ScopeMetrics {
	return newScopeMetrics((*es.getOrig())[ix])
}

func (es MutableScopeMetricsSlice) At(ix int) MutableScopeMetrics {
	return newMutableScopeMetrics((*es.getOrig())[ix])
}

// CopyTo copies all elements from the current slice overriding the destination.
func (es ScopeMetricsSlice) CopyTo(dest MutableScopeMetricsSlice) {
	srcLen := es.Len()
	destCap := cap(*dest.getOrig())
	if srcLen <= destCap {
		(*dest.getOrig()) = (*dest.getOrig())[:srcLen:destCap]
		for i := range *es.getOrig() {
			newScopeMetrics((*es.getOrig())[i]).CopyTo(newMutableScopeMetrics((*dest.getOrig())[i]))
		}
		return
	}
	origs := make([]otlpmetrics.ScopeMetrics, srcLen)
	wrappers := make([]*otlpmetrics.ScopeMetrics, srcLen)
	for i := range *es.getOrig() {
		wrappers[i] = &origs[i]
		newScopeMetrics((*es.getOrig())[i]).CopyTo(newMutableScopeMetrics(wrappers[i]))
	}
	*dest.getOrig() = wrappers
}

// CopyTo copies all elements from the current slice overriding the destination.
func (es MutableScopeMetricsSlice) CopyTo(dest MutableScopeMetricsSlice) {
	newScopeMetricsSlice(es.getOrig()).CopyTo(dest)
}

// EnsureCapacity is an operation that ensures the slice has at least the specified capacity.
// 1. If the newCap <= cap then no change in capacity.
// 2. If the newCap > cap then the slice capacity will be expanded to equal newCap.
//
// Here is how a new ScopeMetricsSlice can be initialized:
//
//	es := NewScopeMetricsSlice()
//	es.EnsureCapacity(4)
//	for i := 0; i < 4; i++ {
//	    e := es.AppendEmpty()
//	    // Here should set all the values for e.
//	}
func (es MutableScopeMetricsSlice) EnsureCapacity(newCap int) {
	oldCap := cap(*es.getOrig())
	if newCap <= oldCap {
		return
	}

	newOrig := make([]*otlpmetrics.ScopeMetrics, len(*es.getOrig()), newCap)
	copy(newOrig, *es.getOrig())
	*es.getOrig() = newOrig
}

// AppendEmpty will append to the end of the slice an empty ScopeMetrics.
// It returns the newly added ScopeMetrics.
func (es MutableScopeMetricsSlice) AppendEmpty() MutableScopeMetrics {
	*es.getOrig() = append(*es.getOrig(), &otlpmetrics.ScopeMetrics{})
	return es.At(es.Len() - 1)
}

// Sort sorts the ScopeMetrics elements within ScopeMetricsSlice given the
// provided less function so that two instances of ScopeMetricsSlice
// can be compared.
func (es MutableScopeMetricsSlice) Sort(less func(a, b MutableScopeMetrics) bool) {
	sort.SliceStable(*es.getOrig(), func(i, j int) bool { return less(es.At(i), es.At(j)) })
}

// MoveAndAppendTo moves all elements from the current slice and appends them to the dest.
// The current slice will be cleared.
func (es MutableScopeMetricsSlice) MoveAndAppendTo(dest MutableScopeMetricsSlice) {
	if *dest.getOrig() == nil {
		// We can simply move the entire vector and avoid any allocations.
		*dest.getOrig() = *es.getOrig()
	} else {
		*dest.getOrig() = append(*dest.getOrig(), *es.getOrig()...)
	}
	*es.getOrig() = nil
}

// RemoveIf calls f sequentially for each element present in the slice.
// If f returns true, the element is removed from the slice.
func (es MutableScopeMetricsSlice) RemoveIf(f func(MutableScopeMetrics) bool) {
	newLen := 0
	for i := 0; i < len(*es.getOrig()); i++ {
		if f(es.At(i)) {
			continue
		}
		if newLen == i {
			// Nothing to move, element is at the right place.
			newLen++
			continue
		}
		(*es.getOrig())[newLen] = (*es.getOrig())[i]
		newLen++
	}
	// TODO: Prevent memory leak by erasing truncated values.
	*es.getOrig() = (*es.getOrig())[:newLen]
}

// ScopeMetrics is a collection of metrics from a LibraryInstrumentation.
//
// This is a reference type, if passed by value and callee modifies it the
// caller will see the modification.
//
// Must use NewScopeMetrics function to create new instances.
// Important: zero-initialized instance is not valid for use.

type ScopeMetrics internal.ScopeMetrics

type MutableScopeMetrics internal.MutableScopeMetrics

func newScopeMetrics(orig *otlpmetrics.ScopeMetrics) ScopeMetrics {
	return ScopeMetrics(internal.NewScopeMetrics(orig))
}

func newMutableScopeMetrics(orig *otlpmetrics.ScopeMetrics) MutableScopeMetrics {
	return MutableScopeMetrics(internal.NewScopeMetrics(orig))
}

func (ms ScopeMetrics) getOrig() *otlpmetrics.ScopeMetrics {
	return internal.GetOrigScopeMetrics(internal.ScopeMetrics(ms))
}

func (ms MutableScopeMetrics) getOrig() *otlpmetrics.ScopeMetrics {
	return internal.GetMutableOrigScopeMetrics(internal.MutableScopeMetrics(ms))
}

// NewScopeMetrics creates a new empty ScopeMetrics.
//
// This must be used only in testing code. Users should use "AppendEmpty" when part of a Slice,
// OR directly access the member if this is embedded in another struct.
func NewScopeMetrics() MutableScopeMetrics {
	return newMutableScopeMetrics(&otlpmetrics.ScopeMetrics{})
}

// MoveTo moves all properties from the current struct overriding the destination and
// resetting the current instance to its zero value
func (ms MutableScopeMetrics) MoveTo(dest MutableScopeMetrics) {
	*dest.getOrig() = *ms.getOrig()
	*ms.getOrig() = otlpmetrics.ScopeMetrics{}
}

// Scope returns the scope associated with this ScopeMetrics.
func (ms ScopeMetrics) Scope() pcommon.InstrumentationScope {
	return pcommon.InstrumentationScope(internal.NewInstrumentationScope(&ms.getOrig().Scope))
}

// Scope returns the scope associated with this ScopeMetrics.
func (ms MutableScopeMetrics) Scope() pcommon.MutableInstrumentationScope {
	return pcommon.MutableInstrumentationScope(internal.NewMutableInstrumentationScope(&ms.getOrig().Scope))
}

// SchemaUrl returns the schemaurl associated with this ScopeMetrics.
func (ms ScopeMetrics) SchemaUrl() string {
	return ms.getOrig().SchemaUrl
}

// MutableSchemaUrl returns the schemaurl associated with this ScopeMetrics.
func (ms MutableScopeMetrics) SchemaUrl() string {
	return ms.getOrig().SchemaUrl
}

// SetSchemaUrl replaces the schemaurl associated with this ScopeMetrics.
func (ms MutableScopeMetrics) SetSchemaUrl(v string) {
	ms.getOrig().SchemaUrl = v
}

// Metrics returns the Metrics associated with this ScopeMetrics.
func (ms ScopeMetrics) Metrics() MetricSlice {
	return MetricSlice(internal.NewMetricSlice(&ms.getOrig().Metrics))
}

// Metrics returns the Metrics associated with this ScopeMetrics.
func (ms MutableScopeMetrics) Metrics() MutableMetricSlice {
	return MutableMetricSlice(internal.NewMutableMetricSlice(&ms.getOrig().Metrics))
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms ScopeMetrics) CopyTo(dest MutableScopeMetrics) {
	ms.Scope().CopyTo(dest.Scope())
	dest.SetSchemaUrl(ms.SchemaUrl())
	ms.Metrics().CopyTo(dest.Metrics())
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms MutableScopeMetrics) CopyTo(dest MutableScopeMetrics) {
	newScopeMetrics(ms.getOrig()).CopyTo(dest)
}

// MetricSlice logically represents a slice of Metric.
//
// This is a reference type. If passed by value and callee modifies it, the
// caller will see the modification.
//
// Must use NewMetricSlice function to create new instances.
// Important: zero-initialized instance is not valid for use.
type MetricSlice internal.MetricSlice

type MutableMetricSlice internal.MutableMetricSlice

func newMetricSlice(orig *[]*otlpmetrics.Metric) MetricSlice {
	return MetricSlice(internal.NewMetricSlice(orig))
}

func newMutableMetricSlice(orig *[]*otlpmetrics.Metric) MutableMetricSlice {
	return MutableMetricSlice(internal.NewMetricSlice(orig))
}

func (ms MetricSlice) getOrig() *[]*otlpmetrics.Metric {
	return internal.GetOrigMetricSlice(internal.MetricSlice(ms))
}

func (ms MutableMetricSlice) getOrig() *[]*otlpmetrics.Metric {
	return internal.GetMutableOrigMetricSlice(internal.MutableMetricSlice(ms))
}

// NewMetricSlice creates a MetricSlice with 0 elements.
// Can use "EnsureCapacity" to initialize with a given capacity.
func NewMetricSlice() MutableMetricSlice {
	orig := []*otlpmetrics.Metric(nil)
	return newMutableMetricSlice(&orig)
}

// Len returns the number of elements in the slice.
//
// Returns "0" for a newly instance created with "NewMetricSlice()".
func (es MetricSlice) Len() int {
	return len(*es.getOrig())
}

func (es MutableMetricSlice) Len() int {
	return len(*es.getOrig())
}

// At returns the element at the given index.
//
// This function is used mostly for iterating over all the values in the slice:
//
//	for i := 0; i < es.Len(); i++ {
//	    e := es.At(i)
//	    ... // Do something with the element
//	}
func (es MetricSlice) At(ix int) Metric {
	return newMetric((*es.getOrig())[ix])
}

func (es MutableMetricSlice) At(ix int) MutableMetric {
	return newMutableMetric((*es.getOrig())[ix])
}

// CopyTo copies all elements from the current slice overriding the destination.
func (es MetricSlice) CopyTo(dest MutableMetricSlice) {
	srcLen := es.Len()
	destCap := cap(*dest.getOrig())
	if srcLen <= destCap {
		(*dest.getOrig()) = (*dest.getOrig())[:srcLen:destCap]
		for i := range *es.getOrig() {
			newMetric((*es.getOrig())[i]).CopyTo(newMutableMetric((*dest.getOrig())[i]))
		}
		return
	}
	origs := make([]otlpmetrics.Metric, srcLen)
	wrappers := make([]*otlpmetrics.Metric, srcLen)
	for i := range *es.getOrig() {
		wrappers[i] = &origs[i]
		newMetric((*es.getOrig())[i]).CopyTo(newMutableMetric(wrappers[i]))
	}
	*dest.getOrig() = wrappers
}

// CopyTo copies all elements from the current slice overriding the destination.
func (es MutableMetricSlice) CopyTo(dest MutableMetricSlice) {
	newMetricSlice(es.getOrig()).CopyTo(dest)
}

// EnsureCapacity is an operation that ensures the slice has at least the specified capacity.
// 1. If the newCap <= cap then no change in capacity.
// 2. If the newCap > cap then the slice capacity will be expanded to equal newCap.
//
// Here is how a new MetricSlice can be initialized:
//
//	es := NewMetricSlice()
//	es.EnsureCapacity(4)
//	for i := 0; i < 4; i++ {
//	    e := es.AppendEmpty()
//	    // Here should set all the values for e.
//	}
func (es MutableMetricSlice) EnsureCapacity(newCap int) {
	oldCap := cap(*es.getOrig())
	if newCap <= oldCap {
		return
	}

	newOrig := make([]*otlpmetrics.Metric, len(*es.getOrig()), newCap)
	copy(newOrig, *es.getOrig())
	*es.getOrig() = newOrig
}

// AppendEmpty will append to the end of the slice an empty Metric.
// It returns the newly added Metric.
func (es MutableMetricSlice) AppendEmpty() MutableMetric {
	*es.getOrig() = append(*es.getOrig(), &otlpmetrics.Metric{})
	return es.At(es.Len() - 1)
}

// Sort sorts the Metric elements within MetricSlice given the
// provided less function so that two instances of MetricSlice
// can be compared.
func (es MutableMetricSlice) Sort(less func(a, b MutableMetric) bool) {
	sort.SliceStable(*es.getOrig(), func(i, j int) bool { return less(es.At(i), es.At(j)) })
}

// MoveAndAppendTo moves all elements from the current slice and appends them to the dest.
// The current slice will be cleared.
func (es MutableMetricSlice) MoveAndAppendTo(dest MutableMetricSlice) {
	if *dest.getOrig() == nil {
		// We can simply move the entire vector and avoid any allocations.
		*dest.getOrig() = *es.getOrig()
	} else {
		*dest.getOrig() = append(*dest.getOrig(), *es.getOrig()...)
	}
	*es.getOrig() = nil
}

// RemoveIf calls f sequentially for each element present in the slice.
// If f returns true, the element is removed from the slice.
func (es MutableMetricSlice) RemoveIf(f func(MutableMetric) bool) {
	newLen := 0
	for i := 0; i < len(*es.getOrig()); i++ {
		if f(es.At(i)) {
			continue
		}
		if newLen == i {
			// Nothing to move, element is at the right place.
			newLen++
			continue
		}
		(*es.getOrig())[newLen] = (*es.getOrig())[i]
		newLen++
	}
	// TODO: Prevent memory leak by erasing truncated values.
	*es.getOrig() = (*es.getOrig())[:newLen]
}

// Metric represents one metric as a collection of datapoints.
// See Metric definition in OTLP: https://github.com/open-telemetry/opentelemetry-proto/blob/main/opentelemetry/proto/metrics/v1/metrics.proto
//
// This is a reference type, if passed by value and callee modifies it the
// caller will see the modification.
//
// Must use NewMetric function to create new instances.
// Important: zero-initialized instance is not valid for use.

type Metric internal.Metric

type MutableMetric internal.MutableMetric

func newMetric(orig *otlpmetrics.Metric) Metric {
	return Metric(internal.NewMetric(orig))
}

func newMutableMetric(orig *otlpmetrics.Metric) MutableMetric {
	return MutableMetric(internal.NewMetric(orig))
}

func (ms Metric) getOrig() *otlpmetrics.Metric {
	return internal.GetOrigMetric(internal.Metric(ms))
}

func (ms MutableMetric) getOrig() *otlpmetrics.Metric {
	return internal.GetMutableOrigMetric(internal.MutableMetric(ms))
}

// NewMetric creates a new empty Metric.
//
// This must be used only in testing code. Users should use "AppendEmpty" when part of a Slice,
// OR directly access the member if this is embedded in another struct.
func NewMetric() MutableMetric {
	return newMutableMetric(&otlpmetrics.Metric{})
}

// MoveTo moves all properties from the current struct overriding the destination and
// resetting the current instance to its zero value
func (ms MutableMetric) MoveTo(dest MutableMetric) {
	*dest.getOrig() = *ms.getOrig()
	*ms.getOrig() = otlpmetrics.Metric{}
}

// Name returns the name associated with this Metric.
func (ms Metric) Name() string {
	return ms.getOrig().Name
}

// MutableName returns the name associated with this Metric.
func (ms MutableMetric) Name() string {
	return ms.getOrig().Name
}

// SetName replaces the name associated with this Metric.
func (ms MutableMetric) SetName(v string) {
	ms.getOrig().Name = v
}

// Description returns the description associated with this Metric.
func (ms Metric) Description() string {
	return ms.getOrig().Description
}

// MutableDescription returns the description associated with this Metric.
func (ms MutableMetric) Description() string {
	return ms.getOrig().Description
}

// SetDescription replaces the description associated with this Metric.
func (ms MutableMetric) SetDescription(v string) {
	ms.getOrig().Description = v
}

// Unit returns the unit associated with this Metric.
func (ms Metric) Unit() string {
	return ms.getOrig().Unit
}

// MutableUnit returns the unit associated with this Metric.
func (ms MutableMetric) Unit() string {
	return ms.getOrig().Unit
}

// SetUnit replaces the unit associated with this Metric.
func (ms MutableMetric) SetUnit(v string) {
	ms.getOrig().Unit = v
}

// Type returns the type of the data for this Metric.
// Calling this function on zero-initialized Metric will cause a panic.
func (ms Metric) Type() MetricType {
	switch ms.getOrig().Data.(type) {
	case *otlpmetrics.Metric_Gauge:
		return MetricTypeGauge
	case *otlpmetrics.Metric_Sum:
		return MetricTypeSum
	case *otlpmetrics.Metric_Histogram:
		return MetricTypeHistogram
	case *otlpmetrics.Metric_ExponentialHistogram:
		return MetricTypeExponentialHistogram
	case *otlpmetrics.Metric_Summary:
		return MetricTypeSummary
	}
	return MetricTypeEmpty
}

// Gauge returns the gauge associated with this Metric.
//
// Calling this function when Type() != MetricTypeGauge returns an invalid
// zero-initialized instance of Gauge. Note that using such Gauge instance can cause panic.
//
// Calling this function on zero-initialized Metric will cause a panic.
func (ms Metric) Gauge() Gauge {
	v, ok := ms.getOrig().GetData().(*otlpmetrics.Metric_Gauge)
	if !ok {
		return Gauge{}
	}
	return newGauge(v.Gauge)
}

// SetEmptyGauge sets an empty gauge to this Metric.
//
// After this, Type() function will return MetricTypeGauge".
//
// Calling this function on zero-initialized MutableMetric will cause a panic.
func (ms MutableMetric) SetEmptyGauge() MutableGauge {
	val := &otlpmetrics.Gauge{}
	ms.getOrig().Data = &otlpmetrics.Metric_Gauge{Gauge: val}
	return newMutableGauge(val)
}

// Sum returns the sum associated with this Metric.
//
// Calling this function when Type() != MetricTypeSum returns an invalid
// zero-initialized instance of Sum. Note that using such Sum instance can cause panic.
//
// Calling this function on zero-initialized Metric will cause a panic.
func (ms Metric) Sum() Sum {
	v, ok := ms.getOrig().GetData().(*otlpmetrics.Metric_Sum)
	if !ok {
		return Sum{}
	}
	return newSum(v.Sum)
}

// SetEmptySum sets an empty sum to this Metric.
//
// After this, Type() function will return MetricTypeSum".
//
// Calling this function on zero-initialized MutableMetric will cause a panic.
func (ms MutableMetric) SetEmptySum() MutableSum {
	val := &otlpmetrics.Sum{}
	ms.getOrig().Data = &otlpmetrics.Metric_Sum{Sum: val}
	return newMutableSum(val)
}

// Histogram returns the histogram associated with this Metric.
//
// Calling this function when Type() != MetricTypeHistogram returns an invalid
// zero-initialized instance of Histogram. Note that using such Histogram instance can cause panic.
//
// Calling this function on zero-initialized Metric will cause a panic.
func (ms Metric) Histogram() Histogram {
	v, ok := ms.getOrig().GetData().(*otlpmetrics.Metric_Histogram)
	if !ok {
		return Histogram{}
	}
	return newHistogram(v.Histogram)
}

// SetEmptyHistogram sets an empty histogram to this Metric.
//
// After this, Type() function will return MetricTypeHistogram".
//
// Calling this function on zero-initialized MutableMetric will cause a panic.
func (ms MutableMetric) SetEmptyHistogram() MutableHistogram {
	val := &otlpmetrics.Histogram{}
	ms.getOrig().Data = &otlpmetrics.Metric_Histogram{Histogram: val}
	return newMutableHistogram(val)
}

// ExponentialHistogram returns the exponentialhistogram associated with this Metric.
//
// Calling this function when Type() != MetricTypeExponentialHistogram returns an invalid
// zero-initialized instance of ExponentialHistogram. Note that using such ExponentialHistogram instance can cause panic.
//
// Calling this function on zero-initialized Metric will cause a panic.
func (ms Metric) ExponentialHistogram() ExponentialHistogram {
	v, ok := ms.getOrig().GetData().(*otlpmetrics.Metric_ExponentialHistogram)
	if !ok {
		return ExponentialHistogram{}
	}
	return newExponentialHistogram(v.ExponentialHistogram)
}

// SetEmptyExponentialHistogram sets an empty exponentialhistogram to this Metric.
//
// After this, Type() function will return MetricTypeExponentialHistogram".
//
// Calling this function on zero-initialized MutableMetric will cause a panic.
func (ms MutableMetric) SetEmptyExponentialHistogram() MutableExponentialHistogram {
	val := &otlpmetrics.ExponentialHistogram{}
	ms.getOrig().Data = &otlpmetrics.Metric_ExponentialHistogram{ExponentialHistogram: val}
	return newMutableExponentialHistogram(val)
}

// Summary returns the summary associated with this Metric.
//
// Calling this function when Type() != MetricTypeSummary returns an invalid
// zero-initialized instance of Summary. Note that using such Summary instance can cause panic.
//
// Calling this function on zero-initialized Metric will cause a panic.
func (ms Metric) Summary() Summary {
	v, ok := ms.getOrig().GetData().(*otlpmetrics.Metric_Summary)
	if !ok {
		return Summary{}
	}
	return newSummary(v.Summary)
}

// SetEmptySummary sets an empty summary to this Metric.
//
// After this, Type() function will return MetricTypeSummary".
//
// Calling this function on zero-initialized MutableMetric will cause a panic.
func (ms MutableMetric) SetEmptySummary() MutableSummary {
	val := &otlpmetrics.Summary{}
	ms.getOrig().Data = &otlpmetrics.Metric_Summary{Summary: val}
	return newMutableSummary(val)
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms Metric) CopyTo(dest MutableMetric) {
	dest.SetName(ms.Name())
	dest.SetDescription(ms.Description())
	dest.SetUnit(ms.Unit())
	switch ms.Type() {
	case MetricTypeGauge:
		ms.Gauge().CopyTo(dest.SetEmptyGauge())
	case MetricTypeSum:
		ms.Sum().CopyTo(dest.SetEmptySum())
	case MetricTypeHistogram:
		ms.Histogram().CopyTo(dest.SetEmptyHistogram())
	case MetricTypeExponentialHistogram:
		ms.ExponentialHistogram().CopyTo(dest.SetEmptyExponentialHistogram())
	case MetricTypeSummary:
		ms.Summary().CopyTo(dest.SetEmptySummary())
	}

}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms MutableMetric) CopyTo(dest MutableMetric) {
	newMetric(ms.getOrig()).CopyTo(dest)
}

// Gauge represents the type of a numeric metric that always exports the "current value" for every data point.
//
// This is a reference type, if passed by value and callee modifies it the
// caller will see the modification.
//
// Must use NewGauge function to create new instances.
// Important: zero-initialized instance is not valid for use.

type Gauge internal.Gauge

type MutableGauge internal.MutableGauge

func newGauge(orig *otlpmetrics.Gauge) Gauge {
	return Gauge(internal.NewGauge(orig))
}

func newMutableGauge(orig *otlpmetrics.Gauge) MutableGauge {
	return MutableGauge(internal.NewGauge(orig))
}

func (ms Gauge) getOrig() *otlpmetrics.Gauge {
	return internal.GetOrigGauge(internal.Gauge(ms))
}

func (ms MutableGauge) getOrig() *otlpmetrics.Gauge {
	return internal.GetMutableOrigGauge(internal.MutableGauge(ms))
}

// NewGauge creates a new empty Gauge.
//
// This must be used only in testing code. Users should use "AppendEmpty" when part of a Slice,
// OR directly access the member if this is embedded in another struct.
func NewGauge() MutableGauge {
	return newMutableGauge(&otlpmetrics.Gauge{})
}

// MoveTo moves all properties from the current struct overriding the destination and
// resetting the current instance to its zero value
func (ms MutableGauge) MoveTo(dest MutableGauge) {
	*dest.getOrig() = *ms.getOrig()
	*ms.getOrig() = otlpmetrics.Gauge{}
}

// DataPoints returns the DataPoints associated with this Gauge.
func (ms Gauge) DataPoints() NumberDataPointSlice {
	return NumberDataPointSlice(internal.NewNumberDataPointSlice(&ms.getOrig().DataPoints))
}

// DataPoints returns the DataPoints associated with this Gauge.
func (ms MutableGauge) DataPoints() MutableNumberDataPointSlice {
	return MutableNumberDataPointSlice(internal.NewMutableNumberDataPointSlice(&ms.getOrig().DataPoints))
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms Gauge) CopyTo(dest MutableGauge) {
	ms.DataPoints().CopyTo(dest.DataPoints())
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms MutableGauge) CopyTo(dest MutableGauge) {
	newGauge(ms.getOrig()).CopyTo(dest)
}

// Sum represents the type of a numeric metric that is calculated as a sum of all reported measurements over a time interval.
//
// This is a reference type, if passed by value and callee modifies it the
// caller will see the modification.
//
// Must use NewSum function to create new instances.
// Important: zero-initialized instance is not valid for use.

type Sum internal.Sum

type MutableSum internal.MutableSum

func newSum(orig *otlpmetrics.Sum) Sum {
	return Sum(internal.NewSum(orig))
}

func newMutableSum(orig *otlpmetrics.Sum) MutableSum {
	return MutableSum(internal.NewSum(orig))
}

func (ms Sum) getOrig() *otlpmetrics.Sum {
	return internal.GetOrigSum(internal.Sum(ms))
}

func (ms MutableSum) getOrig() *otlpmetrics.Sum {
	return internal.GetMutableOrigSum(internal.MutableSum(ms))
}

// NewSum creates a new empty Sum.
//
// This must be used only in testing code. Users should use "AppendEmpty" when part of a Slice,
// OR directly access the member if this is embedded in another struct.
func NewSum() MutableSum {
	return newMutableSum(&otlpmetrics.Sum{})
}

// MoveTo moves all properties from the current struct overriding the destination and
// resetting the current instance to its zero value
func (ms MutableSum) MoveTo(dest MutableSum) {
	*dest.getOrig() = *ms.getOrig()
	*ms.getOrig() = otlpmetrics.Sum{}
}

// AggregationTemporality returns the aggregationtemporality associated with this Sum.
func (ms Sum) AggregationTemporality() AggregationTemporality {
	return AggregationTemporality(ms.getOrig().AggregationTemporality)
}

// AggregationTemporality returns the aggregationtemporality associated with this Sum.
func (ms MutableSum) AggregationTemporality() AggregationTemporality {
	return AggregationTemporality(ms.getOrig().AggregationTemporality)
}

// SetAggregationTemporality replaces the aggregationtemporality associated with this Sum.
func (ms MutableSum) SetAggregationTemporality(v AggregationTemporality) {
	ms.getOrig().AggregationTemporality = otlpmetrics.AggregationTemporality(v)
}

// IsMonotonic returns the ismonotonic associated with this Sum.
func (ms Sum) IsMonotonic() bool {
	return ms.getOrig().IsMonotonic
}

// MutableIsMonotonic returns the ismonotonic associated with this Sum.
func (ms MutableSum) IsMonotonic() bool {
	return ms.getOrig().IsMonotonic
}

// SetIsMonotonic replaces the ismonotonic associated with this Sum.
func (ms MutableSum) SetIsMonotonic(v bool) {
	ms.getOrig().IsMonotonic = v
}

// DataPoints returns the DataPoints associated with this Sum.
func (ms Sum) DataPoints() NumberDataPointSlice {
	return NumberDataPointSlice(internal.NewNumberDataPointSlice(&ms.getOrig().DataPoints))
}

// DataPoints returns the DataPoints associated with this Sum.
func (ms MutableSum) DataPoints() MutableNumberDataPointSlice {
	return MutableNumberDataPointSlice(internal.NewMutableNumberDataPointSlice(&ms.getOrig().DataPoints))
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms Sum) CopyTo(dest MutableSum) {
	dest.SetAggregationTemporality(ms.AggregationTemporality())
	dest.SetIsMonotonic(ms.IsMonotonic())
	ms.DataPoints().CopyTo(dest.DataPoints())
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms MutableSum) CopyTo(dest MutableSum) {
	newSum(ms.getOrig()).CopyTo(dest)
}

// Histogram represents the type of a metric that is calculated by aggregating as a Histogram of all reported measurements over a time interval.
//
// This is a reference type, if passed by value and callee modifies it the
// caller will see the modification.
//
// Must use NewHistogram function to create new instances.
// Important: zero-initialized instance is not valid for use.

type Histogram internal.Histogram

type MutableHistogram internal.MutableHistogram

func newHistogram(orig *otlpmetrics.Histogram) Histogram {
	return Histogram(internal.NewHistogram(orig))
}

func newMutableHistogram(orig *otlpmetrics.Histogram) MutableHistogram {
	return MutableHistogram(internal.NewHistogram(orig))
}

func (ms Histogram) getOrig() *otlpmetrics.Histogram {
	return internal.GetOrigHistogram(internal.Histogram(ms))
}

func (ms MutableHistogram) getOrig() *otlpmetrics.Histogram {
	return internal.GetMutableOrigHistogram(internal.MutableHistogram(ms))
}

// NewHistogram creates a new empty Histogram.
//
// This must be used only in testing code. Users should use "AppendEmpty" when part of a Slice,
// OR directly access the member if this is embedded in another struct.
func NewHistogram() MutableHistogram {
	return newMutableHistogram(&otlpmetrics.Histogram{})
}

// MoveTo moves all properties from the current struct overriding the destination and
// resetting the current instance to its zero value
func (ms MutableHistogram) MoveTo(dest MutableHistogram) {
	*dest.getOrig() = *ms.getOrig()
	*ms.getOrig() = otlpmetrics.Histogram{}
}

// AggregationTemporality returns the aggregationtemporality associated with this Histogram.
func (ms Histogram) AggregationTemporality() AggregationTemporality {
	return AggregationTemporality(ms.getOrig().AggregationTemporality)
}

// AggregationTemporality returns the aggregationtemporality associated with this Histogram.
func (ms MutableHistogram) AggregationTemporality() AggregationTemporality {
	return AggregationTemporality(ms.getOrig().AggregationTemporality)
}

// SetAggregationTemporality replaces the aggregationtemporality associated with this Histogram.
func (ms MutableHistogram) SetAggregationTemporality(v AggregationTemporality) {
	ms.getOrig().AggregationTemporality = otlpmetrics.AggregationTemporality(v)
}

// DataPoints returns the DataPoints associated with this Histogram.
func (ms Histogram) DataPoints() HistogramDataPointSlice {
	return HistogramDataPointSlice(internal.NewHistogramDataPointSlice(&ms.getOrig().DataPoints))
}

// DataPoints returns the DataPoints associated with this Histogram.
func (ms MutableHistogram) DataPoints() MutableHistogramDataPointSlice {
	return MutableHistogramDataPointSlice(internal.NewMutableHistogramDataPointSlice(&ms.getOrig().DataPoints))
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms Histogram) CopyTo(dest MutableHistogram) {
	dest.SetAggregationTemporality(ms.AggregationTemporality())
	ms.DataPoints().CopyTo(dest.DataPoints())
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms MutableHistogram) CopyTo(dest MutableHistogram) {
	newHistogram(ms.getOrig()).CopyTo(dest)
}

// ExponentialHistogram represents the type of a metric that is calculated by aggregating
// as a ExponentialHistogram of all reported double measurements over a time interval.
//
// This is a reference type, if passed by value and callee modifies it the
// caller will see the modification.
//
// Must use NewExponentialHistogram function to create new instances.
// Important: zero-initialized instance is not valid for use.

type ExponentialHistogram internal.ExponentialHistogram

type MutableExponentialHistogram internal.MutableExponentialHistogram

func newExponentialHistogram(orig *otlpmetrics.ExponentialHistogram) ExponentialHistogram {
	return ExponentialHistogram(internal.NewExponentialHistogram(orig))
}

func newMutableExponentialHistogram(orig *otlpmetrics.ExponentialHistogram) MutableExponentialHistogram {
	return MutableExponentialHistogram(internal.NewExponentialHistogram(orig))
}

func (ms ExponentialHistogram) getOrig() *otlpmetrics.ExponentialHistogram {
	return internal.GetOrigExponentialHistogram(internal.ExponentialHistogram(ms))
}

func (ms MutableExponentialHistogram) getOrig() *otlpmetrics.ExponentialHistogram {
	return internal.GetMutableOrigExponentialHistogram(internal.MutableExponentialHistogram(ms))
}

// NewExponentialHistogram creates a new empty ExponentialHistogram.
//
// This must be used only in testing code. Users should use "AppendEmpty" when part of a Slice,
// OR directly access the member if this is embedded in another struct.
func NewExponentialHistogram() MutableExponentialHistogram {
	return newMutableExponentialHistogram(&otlpmetrics.ExponentialHistogram{})
}

// MoveTo moves all properties from the current struct overriding the destination and
// resetting the current instance to its zero value
func (ms MutableExponentialHistogram) MoveTo(dest MutableExponentialHistogram) {
	*dest.getOrig() = *ms.getOrig()
	*ms.getOrig() = otlpmetrics.ExponentialHistogram{}
}

// AggregationTemporality returns the aggregationtemporality associated with this ExponentialHistogram.
func (ms ExponentialHistogram) AggregationTemporality() AggregationTemporality {
	return AggregationTemporality(ms.getOrig().AggregationTemporality)
}

// AggregationTemporality returns the aggregationtemporality associated with this ExponentialHistogram.
func (ms MutableExponentialHistogram) AggregationTemporality() AggregationTemporality {
	return AggregationTemporality(ms.getOrig().AggregationTemporality)
}

// SetAggregationTemporality replaces the aggregationtemporality associated with this ExponentialHistogram.
func (ms MutableExponentialHistogram) SetAggregationTemporality(v AggregationTemporality) {
	ms.getOrig().AggregationTemporality = otlpmetrics.AggregationTemporality(v)
}

// DataPoints returns the DataPoints associated with this ExponentialHistogram.
func (ms ExponentialHistogram) DataPoints() ExponentialHistogramDataPointSlice {
	return ExponentialHistogramDataPointSlice(internal.NewExponentialHistogramDataPointSlice(&ms.getOrig().DataPoints))
}

// DataPoints returns the DataPoints associated with this ExponentialHistogram.
func (ms MutableExponentialHistogram) DataPoints() MutableExponentialHistogramDataPointSlice {
	return MutableExponentialHistogramDataPointSlice(internal.NewMutableExponentialHistogramDataPointSlice(&ms.getOrig().DataPoints))
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms ExponentialHistogram) CopyTo(dest MutableExponentialHistogram) {
	dest.SetAggregationTemporality(ms.AggregationTemporality())
	ms.DataPoints().CopyTo(dest.DataPoints())
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms MutableExponentialHistogram) CopyTo(dest MutableExponentialHistogram) {
	newExponentialHistogram(ms.getOrig()).CopyTo(dest)
}

// Summary represents the type of a metric that is calculated by aggregating as a Summary of all reported double measurements over a time interval.
//
// This is a reference type, if passed by value and callee modifies it the
// caller will see the modification.
//
// Must use NewSummary function to create new instances.
// Important: zero-initialized instance is not valid for use.

type Summary internal.Summary

type MutableSummary internal.MutableSummary

func newSummary(orig *otlpmetrics.Summary) Summary {
	return Summary(internal.NewSummary(orig))
}

func newMutableSummary(orig *otlpmetrics.Summary) MutableSummary {
	return MutableSummary(internal.NewSummary(orig))
}

func (ms Summary) getOrig() *otlpmetrics.Summary {
	return internal.GetOrigSummary(internal.Summary(ms))
}

func (ms MutableSummary) getOrig() *otlpmetrics.Summary {
	return internal.GetMutableOrigSummary(internal.MutableSummary(ms))
}

// NewSummary creates a new empty Summary.
//
// This must be used only in testing code. Users should use "AppendEmpty" when part of a Slice,
// OR directly access the member if this is embedded in another struct.
func NewSummary() MutableSummary {
	return newMutableSummary(&otlpmetrics.Summary{})
}

// MoveTo moves all properties from the current struct overriding the destination and
// resetting the current instance to its zero value
func (ms MutableSummary) MoveTo(dest MutableSummary) {
	*dest.getOrig() = *ms.getOrig()
	*ms.getOrig() = otlpmetrics.Summary{}
}

// DataPoints returns the DataPoints associated with this Summary.
func (ms Summary) DataPoints() SummaryDataPointSlice {
	return SummaryDataPointSlice(internal.NewSummaryDataPointSlice(&ms.getOrig().DataPoints))
}

// DataPoints returns the DataPoints associated with this Summary.
func (ms MutableSummary) DataPoints() MutableSummaryDataPointSlice {
	return MutableSummaryDataPointSlice(internal.NewMutableSummaryDataPointSlice(&ms.getOrig().DataPoints))
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms Summary) CopyTo(dest MutableSummary) {
	ms.DataPoints().CopyTo(dest.DataPoints())
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms MutableSummary) CopyTo(dest MutableSummary) {
	newSummary(ms.getOrig()).CopyTo(dest)
}

// NumberDataPointSlice logically represents a slice of NumberDataPoint.
//
// This is a reference type. If passed by value and callee modifies it, the
// caller will see the modification.
//
// Must use NewNumberDataPointSlice function to create new instances.
// Important: zero-initialized instance is not valid for use.
type NumberDataPointSlice internal.NumberDataPointSlice

type MutableNumberDataPointSlice internal.MutableNumberDataPointSlice

func newNumberDataPointSlice(orig *[]*otlpmetrics.NumberDataPoint) NumberDataPointSlice {
	return NumberDataPointSlice(internal.NewNumberDataPointSlice(orig))
}

func newMutableNumberDataPointSlice(orig *[]*otlpmetrics.NumberDataPoint) MutableNumberDataPointSlice {
	return MutableNumberDataPointSlice(internal.NewNumberDataPointSlice(orig))
}

func (ms NumberDataPointSlice) getOrig() *[]*otlpmetrics.NumberDataPoint {
	return internal.GetOrigNumberDataPointSlice(internal.NumberDataPointSlice(ms))
}

func (ms MutableNumberDataPointSlice) getOrig() *[]*otlpmetrics.NumberDataPoint {
	return internal.GetMutableOrigNumberDataPointSlice(internal.MutableNumberDataPointSlice(ms))
}

// NewNumberDataPointSlice creates a NumberDataPointSlice with 0 elements.
// Can use "EnsureCapacity" to initialize with a given capacity.
func NewNumberDataPointSlice() MutableNumberDataPointSlice {
	orig := []*otlpmetrics.NumberDataPoint(nil)
	return newMutableNumberDataPointSlice(&orig)
}

// Len returns the number of elements in the slice.
//
// Returns "0" for a newly instance created with "NewNumberDataPointSlice()".
func (es NumberDataPointSlice) Len() int {
	return len(*es.getOrig())
}

func (es MutableNumberDataPointSlice) Len() int {
	return len(*es.getOrig())
}

// At returns the element at the given index.
//
// This function is used mostly for iterating over all the values in the slice:
//
//	for i := 0; i < es.Len(); i++ {
//	    e := es.At(i)
//	    ... // Do something with the element
//	}
func (es NumberDataPointSlice) At(ix int) NumberDataPoint {
	return newNumberDataPoint((*es.getOrig())[ix])
}

func (es MutableNumberDataPointSlice) At(ix int) MutableNumberDataPoint {
	return newMutableNumberDataPoint((*es.getOrig())[ix])
}

// CopyTo copies all elements from the current slice overriding the destination.
func (es NumberDataPointSlice) CopyTo(dest MutableNumberDataPointSlice) {
	srcLen := es.Len()
	destCap := cap(*dest.getOrig())
	if srcLen <= destCap {
		(*dest.getOrig()) = (*dest.getOrig())[:srcLen:destCap]
		for i := range *es.getOrig() {
			newNumberDataPoint((*es.getOrig())[i]).CopyTo(newMutableNumberDataPoint((*dest.getOrig())[i]))
		}
		return
	}
	origs := make([]otlpmetrics.NumberDataPoint, srcLen)
	wrappers := make([]*otlpmetrics.NumberDataPoint, srcLen)
	for i := range *es.getOrig() {
		wrappers[i] = &origs[i]
		newNumberDataPoint((*es.getOrig())[i]).CopyTo(newMutableNumberDataPoint(wrappers[i]))
	}
	*dest.getOrig() = wrappers
}

// CopyTo copies all elements from the current slice overriding the destination.
func (es MutableNumberDataPointSlice) CopyTo(dest MutableNumberDataPointSlice) {
	newNumberDataPointSlice(es.getOrig()).CopyTo(dest)
}

// EnsureCapacity is an operation that ensures the slice has at least the specified capacity.
// 1. If the newCap <= cap then no change in capacity.
// 2. If the newCap > cap then the slice capacity will be expanded to equal newCap.
//
// Here is how a new NumberDataPointSlice can be initialized:
//
//	es := NewNumberDataPointSlice()
//	es.EnsureCapacity(4)
//	for i := 0; i < 4; i++ {
//	    e := es.AppendEmpty()
//	    // Here should set all the values for e.
//	}
func (es MutableNumberDataPointSlice) EnsureCapacity(newCap int) {
	oldCap := cap(*es.getOrig())
	if newCap <= oldCap {
		return
	}

	newOrig := make([]*otlpmetrics.NumberDataPoint, len(*es.getOrig()), newCap)
	copy(newOrig, *es.getOrig())
	*es.getOrig() = newOrig
}

// AppendEmpty will append to the end of the slice an empty NumberDataPoint.
// It returns the newly added NumberDataPoint.
func (es MutableNumberDataPointSlice) AppendEmpty() MutableNumberDataPoint {
	*es.getOrig() = append(*es.getOrig(), &otlpmetrics.NumberDataPoint{})
	return es.At(es.Len() - 1)
}

// Sort sorts the NumberDataPoint elements within NumberDataPointSlice given the
// provided less function so that two instances of NumberDataPointSlice
// can be compared.
func (es MutableNumberDataPointSlice) Sort(less func(a, b MutableNumberDataPoint) bool) {
	sort.SliceStable(*es.getOrig(), func(i, j int) bool { return less(es.At(i), es.At(j)) })
}

// MoveAndAppendTo moves all elements from the current slice and appends them to the dest.
// The current slice will be cleared.
func (es MutableNumberDataPointSlice) MoveAndAppendTo(dest MutableNumberDataPointSlice) {
	if *dest.getOrig() == nil {
		// We can simply move the entire vector and avoid any allocations.
		*dest.getOrig() = *es.getOrig()
	} else {
		*dest.getOrig() = append(*dest.getOrig(), *es.getOrig()...)
	}
	*es.getOrig() = nil
}

// RemoveIf calls f sequentially for each element present in the slice.
// If f returns true, the element is removed from the slice.
func (es MutableNumberDataPointSlice) RemoveIf(f func(MutableNumberDataPoint) bool) {
	newLen := 0
	for i := 0; i < len(*es.getOrig()); i++ {
		if f(es.At(i)) {
			continue
		}
		if newLen == i {
			// Nothing to move, element is at the right place.
			newLen++
			continue
		}
		(*es.getOrig())[newLen] = (*es.getOrig())[i]
		newLen++
	}
	// TODO: Prevent memory leak by erasing truncated values.
	*es.getOrig() = (*es.getOrig())[:newLen]
}

// NumberDataPoint is a single data point in a timeseries that describes the time-varying value of a number metric.
//
// This is a reference type, if passed by value and callee modifies it the
// caller will see the modification.
//
// Must use NewNumberDataPoint function to create new instances.
// Important: zero-initialized instance is not valid for use.

type NumberDataPoint internal.NumberDataPoint

type MutableNumberDataPoint internal.MutableNumberDataPoint

func newNumberDataPoint(orig *otlpmetrics.NumberDataPoint) NumberDataPoint {
	return NumberDataPoint(internal.NewNumberDataPoint(orig))
}

func newMutableNumberDataPoint(orig *otlpmetrics.NumberDataPoint) MutableNumberDataPoint {
	return MutableNumberDataPoint(internal.NewNumberDataPoint(orig))
}

func (ms NumberDataPoint) getOrig() *otlpmetrics.NumberDataPoint {
	return internal.GetOrigNumberDataPoint(internal.NumberDataPoint(ms))
}

func (ms MutableNumberDataPoint) getOrig() *otlpmetrics.NumberDataPoint {
	return internal.GetMutableOrigNumberDataPoint(internal.MutableNumberDataPoint(ms))
}

// NewNumberDataPoint creates a new empty NumberDataPoint.
//
// This must be used only in testing code. Users should use "AppendEmpty" when part of a Slice,
// OR directly access the member if this is embedded in another struct.
func NewNumberDataPoint() MutableNumberDataPoint {
	return newMutableNumberDataPoint(&otlpmetrics.NumberDataPoint{})
}

// MoveTo moves all properties from the current struct overriding the destination and
// resetting the current instance to its zero value
func (ms MutableNumberDataPoint) MoveTo(dest MutableNumberDataPoint) {
	*dest.getOrig() = *ms.getOrig()
	*ms.getOrig() = otlpmetrics.NumberDataPoint{}
}

// Attributes returns the Attributes associated with this NumberDataPoint.
func (ms NumberDataPoint) Attributes() pcommon.Map {
	return pcommon.Map(internal.NewMap(&ms.getOrig().Attributes))
}

// Attributes returns the Attributes associated with this NumberDataPoint.
func (ms MutableNumberDataPoint) Attributes() pcommon.MutableMap {
	return pcommon.MutableMap(internal.NewMutableMap(&ms.getOrig().Attributes))
}

// StartTimestamp returns the starttimestamp associated with this NumberDataPoint.
func (ms NumberDataPoint) StartTimestamp() pcommon.Timestamp {
	return pcommon.Timestamp(ms.getOrig().StartTimeUnixNano)
}

// StartTimestamp returns the starttimestamp associated with this NumberDataPoint.
func (ms MutableNumberDataPoint) StartTimestamp() pcommon.Timestamp {
	return pcommon.Timestamp(ms.getOrig().StartTimeUnixNano)
}

// SetStartTimestamp replaces the starttimestamp associated with this NumberDataPoint.
func (ms MutableNumberDataPoint) SetStartTimestamp(v pcommon.Timestamp) {
	ms.getOrig().StartTimeUnixNano = uint64(v)
}

// Timestamp returns the timestamp associated with this NumberDataPoint.
func (ms NumberDataPoint) Timestamp() pcommon.Timestamp {
	return pcommon.Timestamp(ms.getOrig().TimeUnixNano)
}

// Timestamp returns the timestamp associated with this NumberDataPoint.
func (ms MutableNumberDataPoint) Timestamp() pcommon.Timestamp {
	return pcommon.Timestamp(ms.getOrig().TimeUnixNano)
}

// SetTimestamp replaces the timestamp associated with this NumberDataPoint.
func (ms MutableNumberDataPoint) SetTimestamp(v pcommon.Timestamp) {
	ms.getOrig().TimeUnixNano = uint64(v)
}

// ValueType returns the type of the value for this NumberDataPoint.
// Calling this function on zero-initialized NumberDataPoint will cause a panic.
func (ms NumberDataPoint) ValueType() NumberDataPointValueType {
	switch ms.getOrig().Value.(type) {
	case *otlpmetrics.NumberDataPoint_AsDouble:
		return NumberDataPointValueTypeDouble
	case *otlpmetrics.NumberDataPoint_AsInt:
		return NumberDataPointValueTypeInt
	}
	return NumberDataPointValueTypeEmpty
}

// DoubleValue returns the double associated with this NumberDataPoint.
func (ms NumberDataPoint) DoubleValue() float64 {
	return ms.getOrig().GetAsDouble()
}

func (ms MutableNumberDataPoint) DoubleValue() float64 {
	return ms.getOrig().GetAsDouble()
}

// SetDoubleValue replaces the double associated with this NumberDataPoint.
func (ms MutableNumberDataPoint) SetDoubleValue(v float64) {
	ms.getOrig().Value = &otlpmetrics.NumberDataPoint_AsDouble{
		AsDouble: v,
	}
}

// IntValue returns the int associated with this NumberDataPoint.
func (ms NumberDataPoint) IntValue() int64 {
	return ms.getOrig().GetAsInt()
}

func (ms MutableNumberDataPoint) IntValue() int64 {
	return ms.getOrig().GetAsInt()
}

// SetIntValue replaces the int associated with this NumberDataPoint.
func (ms MutableNumberDataPoint) SetIntValue(v int64) {
	ms.getOrig().Value = &otlpmetrics.NumberDataPoint_AsInt{
		AsInt: v,
	}
}

// Exemplars returns the Exemplars associated with this NumberDataPoint.
func (ms NumberDataPoint) Exemplars() ExemplarSlice {
	return ExemplarSlice(internal.NewExemplarSlice(&ms.getOrig().Exemplars))
}

// Exemplars returns the Exemplars associated with this NumberDataPoint.
func (ms MutableNumberDataPoint) Exemplars() MutableExemplarSlice {
	return MutableExemplarSlice(internal.NewMutableExemplarSlice(&ms.getOrig().Exemplars))
}

// Flags returns the flags associated with this NumberDataPoint.
func (ms NumberDataPoint) Flags() DataPointFlags {
	return DataPointFlags(ms.getOrig().Flags)
}

// Flags returns the flags associated with this NumberDataPoint.
func (ms MutableNumberDataPoint) Flags() DataPointFlags {
	return DataPointFlags(ms.getOrig().Flags)
}

// SetFlags replaces the flags associated with this NumberDataPoint.
func (ms MutableNumberDataPoint) SetFlags(v DataPointFlags) {
	ms.getOrig().Flags = uint32(v)
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms NumberDataPoint) CopyTo(dest MutableNumberDataPoint) {
	ms.Attributes().CopyTo(dest.Attributes())
	dest.SetStartTimestamp(ms.StartTimestamp())
	dest.SetTimestamp(ms.Timestamp())
	switch ms.ValueType() {
	case NumberDataPointValueTypeDouble:
		dest.SetDoubleValue(ms.DoubleValue())
	case NumberDataPointValueTypeInt:
		dest.SetIntValue(ms.IntValue())
	}

	ms.Exemplars().CopyTo(dest.Exemplars())
	dest.SetFlags(ms.Flags())
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms MutableNumberDataPoint) CopyTo(dest MutableNumberDataPoint) {
	newNumberDataPoint(ms.getOrig()).CopyTo(dest)
}

// HistogramDataPointSlice logically represents a slice of HistogramDataPoint.
//
// This is a reference type. If passed by value and callee modifies it, the
// caller will see the modification.
//
// Must use NewHistogramDataPointSlice function to create new instances.
// Important: zero-initialized instance is not valid for use.
type HistogramDataPointSlice internal.HistogramDataPointSlice

type MutableHistogramDataPointSlice internal.MutableHistogramDataPointSlice

func newHistogramDataPointSlice(orig *[]*otlpmetrics.HistogramDataPoint) HistogramDataPointSlice {
	return HistogramDataPointSlice(internal.NewHistogramDataPointSlice(orig))
}

func newMutableHistogramDataPointSlice(orig *[]*otlpmetrics.HistogramDataPoint) MutableHistogramDataPointSlice {
	return MutableHistogramDataPointSlice(internal.NewHistogramDataPointSlice(orig))
}

func (ms HistogramDataPointSlice) getOrig() *[]*otlpmetrics.HistogramDataPoint {
	return internal.GetOrigHistogramDataPointSlice(internal.HistogramDataPointSlice(ms))
}

func (ms MutableHistogramDataPointSlice) getOrig() *[]*otlpmetrics.HistogramDataPoint {
	return internal.GetMutableOrigHistogramDataPointSlice(internal.MutableHistogramDataPointSlice(ms))
}

// NewHistogramDataPointSlice creates a HistogramDataPointSlice with 0 elements.
// Can use "EnsureCapacity" to initialize with a given capacity.
func NewHistogramDataPointSlice() MutableHistogramDataPointSlice {
	orig := []*otlpmetrics.HistogramDataPoint(nil)
	return newMutableHistogramDataPointSlice(&orig)
}

// Len returns the number of elements in the slice.
//
// Returns "0" for a newly instance created with "NewHistogramDataPointSlice()".
func (es HistogramDataPointSlice) Len() int {
	return len(*es.getOrig())
}

func (es MutableHistogramDataPointSlice) Len() int {
	return len(*es.getOrig())
}

// At returns the element at the given index.
//
// This function is used mostly for iterating over all the values in the slice:
//
//	for i := 0; i < es.Len(); i++ {
//	    e := es.At(i)
//	    ... // Do something with the element
//	}
func (es HistogramDataPointSlice) At(ix int) HistogramDataPoint {
	return newHistogramDataPoint((*es.getOrig())[ix])
}

func (es MutableHistogramDataPointSlice) At(ix int) MutableHistogramDataPoint {
	return newMutableHistogramDataPoint((*es.getOrig())[ix])
}

// CopyTo copies all elements from the current slice overriding the destination.
func (es HistogramDataPointSlice) CopyTo(dest MutableHistogramDataPointSlice) {
	srcLen := es.Len()
	destCap := cap(*dest.getOrig())
	if srcLen <= destCap {
		(*dest.getOrig()) = (*dest.getOrig())[:srcLen:destCap]
		for i := range *es.getOrig() {
			newHistogramDataPoint((*es.getOrig())[i]).CopyTo(newMutableHistogramDataPoint((*dest.getOrig())[i]))
		}
		return
	}
	origs := make([]otlpmetrics.HistogramDataPoint, srcLen)
	wrappers := make([]*otlpmetrics.HistogramDataPoint, srcLen)
	for i := range *es.getOrig() {
		wrappers[i] = &origs[i]
		newHistogramDataPoint((*es.getOrig())[i]).CopyTo(newMutableHistogramDataPoint(wrappers[i]))
	}
	*dest.getOrig() = wrappers
}

// CopyTo copies all elements from the current slice overriding the destination.
func (es MutableHistogramDataPointSlice) CopyTo(dest MutableHistogramDataPointSlice) {
	newHistogramDataPointSlice(es.getOrig()).CopyTo(dest)
}

// EnsureCapacity is an operation that ensures the slice has at least the specified capacity.
// 1. If the newCap <= cap then no change in capacity.
// 2. If the newCap > cap then the slice capacity will be expanded to equal newCap.
//
// Here is how a new HistogramDataPointSlice can be initialized:
//
//	es := NewHistogramDataPointSlice()
//	es.EnsureCapacity(4)
//	for i := 0; i < 4; i++ {
//	    e := es.AppendEmpty()
//	    // Here should set all the values for e.
//	}
func (es MutableHistogramDataPointSlice) EnsureCapacity(newCap int) {
	oldCap := cap(*es.getOrig())
	if newCap <= oldCap {
		return
	}

	newOrig := make([]*otlpmetrics.HistogramDataPoint, len(*es.getOrig()), newCap)
	copy(newOrig, *es.getOrig())
	*es.getOrig() = newOrig
}

// AppendEmpty will append to the end of the slice an empty HistogramDataPoint.
// It returns the newly added HistogramDataPoint.
func (es MutableHistogramDataPointSlice) AppendEmpty() MutableHistogramDataPoint {
	*es.getOrig() = append(*es.getOrig(), &otlpmetrics.HistogramDataPoint{})
	return es.At(es.Len() - 1)
}

// Sort sorts the HistogramDataPoint elements within HistogramDataPointSlice given the
// provided less function so that two instances of HistogramDataPointSlice
// can be compared.
func (es MutableHistogramDataPointSlice) Sort(less func(a, b MutableHistogramDataPoint) bool) {
	sort.SliceStable(*es.getOrig(), func(i, j int) bool { return less(es.At(i), es.At(j)) })
}

// MoveAndAppendTo moves all elements from the current slice and appends them to the dest.
// The current slice will be cleared.
func (es MutableHistogramDataPointSlice) MoveAndAppendTo(dest MutableHistogramDataPointSlice) {
	if *dest.getOrig() == nil {
		// We can simply move the entire vector and avoid any allocations.
		*dest.getOrig() = *es.getOrig()
	} else {
		*dest.getOrig() = append(*dest.getOrig(), *es.getOrig()...)
	}
	*es.getOrig() = nil
}

// RemoveIf calls f sequentially for each element present in the slice.
// If f returns true, the element is removed from the slice.
func (es MutableHistogramDataPointSlice) RemoveIf(f func(MutableHistogramDataPoint) bool) {
	newLen := 0
	for i := 0; i < len(*es.getOrig()); i++ {
		if f(es.At(i)) {
			continue
		}
		if newLen == i {
			// Nothing to move, element is at the right place.
			newLen++
			continue
		}
		(*es.getOrig())[newLen] = (*es.getOrig())[i]
		newLen++
	}
	// TODO: Prevent memory leak by erasing truncated values.
	*es.getOrig() = (*es.getOrig())[:newLen]
}

// HistogramDataPoint is a single data point in a timeseries that describes the time-varying values of a Histogram of values.
//
// This is a reference type, if passed by value and callee modifies it the
// caller will see the modification.
//
// Must use NewHistogramDataPoint function to create new instances.
// Important: zero-initialized instance is not valid for use.

type HistogramDataPoint internal.HistogramDataPoint

type MutableHistogramDataPoint internal.MutableHistogramDataPoint

func newHistogramDataPoint(orig *otlpmetrics.HistogramDataPoint) HistogramDataPoint {
	return HistogramDataPoint(internal.NewHistogramDataPoint(orig))
}

func newMutableHistogramDataPoint(orig *otlpmetrics.HistogramDataPoint) MutableHistogramDataPoint {
	return MutableHistogramDataPoint(internal.NewHistogramDataPoint(orig))
}

func (ms HistogramDataPoint) getOrig() *otlpmetrics.HistogramDataPoint {
	return internal.GetOrigHistogramDataPoint(internal.HistogramDataPoint(ms))
}

func (ms MutableHistogramDataPoint) getOrig() *otlpmetrics.HistogramDataPoint {
	return internal.GetMutableOrigHistogramDataPoint(internal.MutableHistogramDataPoint(ms))
}

// NewHistogramDataPoint creates a new empty HistogramDataPoint.
//
// This must be used only in testing code. Users should use "AppendEmpty" when part of a Slice,
// OR directly access the member if this is embedded in another struct.
func NewHistogramDataPoint() MutableHistogramDataPoint {
	return newMutableHistogramDataPoint(&otlpmetrics.HistogramDataPoint{})
}

// MoveTo moves all properties from the current struct overriding the destination and
// resetting the current instance to its zero value
func (ms MutableHistogramDataPoint) MoveTo(dest MutableHistogramDataPoint) {
	*dest.getOrig() = *ms.getOrig()
	*ms.getOrig() = otlpmetrics.HistogramDataPoint{}
}

// Attributes returns the Attributes associated with this HistogramDataPoint.
func (ms HistogramDataPoint) Attributes() pcommon.Map {
	return pcommon.Map(internal.NewMap(&ms.getOrig().Attributes))
}

// Attributes returns the Attributes associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) Attributes() pcommon.MutableMap {
	return pcommon.MutableMap(internal.NewMutableMap(&ms.getOrig().Attributes))
}

// StartTimestamp returns the starttimestamp associated with this HistogramDataPoint.
func (ms HistogramDataPoint) StartTimestamp() pcommon.Timestamp {
	return pcommon.Timestamp(ms.getOrig().StartTimeUnixNano)
}

// StartTimestamp returns the starttimestamp associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) StartTimestamp() pcommon.Timestamp {
	return pcommon.Timestamp(ms.getOrig().StartTimeUnixNano)
}

// SetStartTimestamp replaces the starttimestamp associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) SetStartTimestamp(v pcommon.Timestamp) {
	ms.getOrig().StartTimeUnixNano = uint64(v)
}

// Timestamp returns the timestamp associated with this HistogramDataPoint.
func (ms HistogramDataPoint) Timestamp() pcommon.Timestamp {
	return pcommon.Timestamp(ms.getOrig().TimeUnixNano)
}

// Timestamp returns the timestamp associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) Timestamp() pcommon.Timestamp {
	return pcommon.Timestamp(ms.getOrig().TimeUnixNano)
}

// SetTimestamp replaces the timestamp associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) SetTimestamp(v pcommon.Timestamp) {
	ms.getOrig().TimeUnixNano = uint64(v)
}

// Count returns the count associated with this HistogramDataPoint.
func (ms HistogramDataPoint) Count() uint64 {
	return ms.getOrig().Count
}

// MutableCount returns the count associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) Count() uint64 {
	return ms.getOrig().Count
}

// SetCount replaces the count associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) SetCount(v uint64) {
	ms.getOrig().Count = v
}

// Sum returns the sum associated with this HistogramDataPoint.
func (ms HistogramDataPoint) Sum() float64 {
	return ms.getOrig().GetSum()
}

// Sum returns the sum associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) Sum() float64 {
	return ms.getOrig().GetSum()
}

// HasSum returns true if the HistogramDataPoint contains a
// Sum value, false otherwise.
func (ms HistogramDataPoint) HasSum() bool {
	return ms.getOrig().Sum_ != nil
}

// HasSum returns true if the HistogramDataPoint contains a
// Sum value, false otherwise.
func (ms MutableHistogramDataPoint) HasSum() bool {
	return ms.getOrig().Sum_ != nil
}

// SetSum replaces the sum associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) SetSum(v float64) {
	ms.getOrig().Sum_ = &otlpmetrics.HistogramDataPoint_Sum{Sum: v}
}

// RemoveSum removes the sum associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) RemoveSum() {
	ms.getOrig().Sum_ = nil
}

// BucketCounts returns the bucketcounts associated with this HistogramDataPoint.
func (ms HistogramDataPoint) BucketCounts() pcommon.UInt64Slice {
	return pcommon.UInt64Slice(internal.NewUInt64Slice(&ms.getOrig().BucketCounts))
}

// BucketCounts returns the bucketcounts associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) BucketCounts() pcommon.MutableUInt64Slice {
	return pcommon.MutableUInt64Slice(internal.NewMutableUInt64Slice(&ms.getOrig().BucketCounts))
}

// ExplicitBounds returns the explicitbounds associated with this HistogramDataPoint.
func (ms HistogramDataPoint) ExplicitBounds() pcommon.Float64Slice {
	return pcommon.Float64Slice(internal.NewFloat64Slice(&ms.getOrig().ExplicitBounds))
}

// ExplicitBounds returns the explicitbounds associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) ExplicitBounds() pcommon.MutableFloat64Slice {
	return pcommon.MutableFloat64Slice(internal.NewMutableFloat64Slice(&ms.getOrig().ExplicitBounds))
}

// Exemplars returns the Exemplars associated with this HistogramDataPoint.
func (ms HistogramDataPoint) Exemplars() ExemplarSlice {
	return ExemplarSlice(internal.NewExemplarSlice(&ms.getOrig().Exemplars))
}

// Exemplars returns the Exemplars associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) Exemplars() MutableExemplarSlice {
	return MutableExemplarSlice(internal.NewMutableExemplarSlice(&ms.getOrig().Exemplars))
}

// Flags returns the flags associated with this HistogramDataPoint.
func (ms HistogramDataPoint) Flags() DataPointFlags {
	return DataPointFlags(ms.getOrig().Flags)
}

// Flags returns the flags associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) Flags() DataPointFlags {
	return DataPointFlags(ms.getOrig().Flags)
}

// SetFlags replaces the flags associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) SetFlags(v DataPointFlags) {
	ms.getOrig().Flags = uint32(v)
}

// Min returns the min associated with this HistogramDataPoint.
func (ms HistogramDataPoint) Min() float64 {
	return ms.getOrig().GetMin()
}

// Min returns the min associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) Min() float64 {
	return ms.getOrig().GetMin()
}

// HasMin returns true if the HistogramDataPoint contains a
// Min value, false otherwise.
func (ms HistogramDataPoint) HasMin() bool {
	return ms.getOrig().Min_ != nil
}

// HasMin returns true if the HistogramDataPoint contains a
// Min value, false otherwise.
func (ms MutableHistogramDataPoint) HasMin() bool {
	return ms.getOrig().Min_ != nil
}

// SetMin replaces the min associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) SetMin(v float64) {
	ms.getOrig().Min_ = &otlpmetrics.HistogramDataPoint_Min{Min: v}
}

// RemoveMin removes the min associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) RemoveMin() {
	ms.getOrig().Min_ = nil
}

// Max returns the max associated with this HistogramDataPoint.
func (ms HistogramDataPoint) Max() float64 {
	return ms.getOrig().GetMax()
}

// Max returns the max associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) Max() float64 {
	return ms.getOrig().GetMax()
}

// HasMax returns true if the HistogramDataPoint contains a
// Max value, false otherwise.
func (ms HistogramDataPoint) HasMax() bool {
	return ms.getOrig().Max_ != nil
}

// HasMax returns true if the HistogramDataPoint contains a
// Max value, false otherwise.
func (ms MutableHistogramDataPoint) HasMax() bool {
	return ms.getOrig().Max_ != nil
}

// SetMax replaces the max associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) SetMax(v float64) {
	ms.getOrig().Max_ = &otlpmetrics.HistogramDataPoint_Max{Max: v}
}

// RemoveMax removes the max associated with this HistogramDataPoint.
func (ms MutableHistogramDataPoint) RemoveMax() {
	ms.getOrig().Max_ = nil
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms HistogramDataPoint) CopyTo(dest MutableHistogramDataPoint) {
	ms.Attributes().CopyTo(dest.Attributes())
	dest.SetStartTimestamp(ms.StartTimestamp())
	dest.SetTimestamp(ms.Timestamp())
	dest.SetCount(ms.Count())
	if ms.HasSum() {
		dest.SetSum(ms.Sum())
	}

	ms.BucketCounts().CopyTo(dest.BucketCounts())
	ms.ExplicitBounds().CopyTo(dest.ExplicitBounds())
	ms.Exemplars().CopyTo(dest.Exemplars())
	dest.SetFlags(ms.Flags())
	if ms.HasMin() {
		dest.SetMin(ms.Min())
	}

	if ms.HasMax() {
		dest.SetMax(ms.Max())
	}

}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms MutableHistogramDataPoint) CopyTo(dest MutableHistogramDataPoint) {
	newHistogramDataPoint(ms.getOrig()).CopyTo(dest)
}

// ExponentialHistogramDataPointSlice logically represents a slice of ExponentialHistogramDataPoint.
//
// This is a reference type. If passed by value and callee modifies it, the
// caller will see the modification.
//
// Must use NewExponentialHistogramDataPointSlice function to create new instances.
// Important: zero-initialized instance is not valid for use.
type ExponentialHistogramDataPointSlice internal.ExponentialHistogramDataPointSlice

type MutableExponentialHistogramDataPointSlice internal.MutableExponentialHistogramDataPointSlice

func newExponentialHistogramDataPointSlice(orig *[]*otlpmetrics.ExponentialHistogramDataPoint) ExponentialHistogramDataPointSlice {
	return ExponentialHistogramDataPointSlice(internal.NewExponentialHistogramDataPointSlice(orig))
}

func newMutableExponentialHistogramDataPointSlice(orig *[]*otlpmetrics.ExponentialHistogramDataPoint) MutableExponentialHistogramDataPointSlice {
	return MutableExponentialHistogramDataPointSlice(internal.NewExponentialHistogramDataPointSlice(orig))
}

func (ms ExponentialHistogramDataPointSlice) getOrig() *[]*otlpmetrics.ExponentialHistogramDataPoint {
	return internal.GetOrigExponentialHistogramDataPointSlice(internal.ExponentialHistogramDataPointSlice(ms))
}

func (ms MutableExponentialHistogramDataPointSlice) getOrig() *[]*otlpmetrics.ExponentialHistogramDataPoint {
	return internal.GetMutableOrigExponentialHistogramDataPointSlice(internal.MutableExponentialHistogramDataPointSlice(ms))
}

// NewExponentialHistogramDataPointSlice creates a ExponentialHistogramDataPointSlice with 0 elements.
// Can use "EnsureCapacity" to initialize with a given capacity.
func NewExponentialHistogramDataPointSlice() MutableExponentialHistogramDataPointSlice {
	orig := []*otlpmetrics.ExponentialHistogramDataPoint(nil)
	return newMutableExponentialHistogramDataPointSlice(&orig)
}

// Len returns the number of elements in the slice.
//
// Returns "0" for a newly instance created with "NewExponentialHistogramDataPointSlice()".
func (es ExponentialHistogramDataPointSlice) Len() int {
	return len(*es.getOrig())
}

func (es MutableExponentialHistogramDataPointSlice) Len() int {
	return len(*es.getOrig())
}

// At returns the element at the given index.
//
// This function is used mostly for iterating over all the values in the slice:
//
//	for i := 0; i < es.Len(); i++ {
//	    e := es.At(i)
//	    ... // Do something with the element
//	}
func (es ExponentialHistogramDataPointSlice) At(ix int) ExponentialHistogramDataPoint {
	return newExponentialHistogramDataPoint((*es.getOrig())[ix])
}

func (es MutableExponentialHistogramDataPointSlice) At(ix int) MutableExponentialHistogramDataPoint {
	return newMutableExponentialHistogramDataPoint((*es.getOrig())[ix])
}

// CopyTo copies all elements from the current slice overriding the destination.
func (es ExponentialHistogramDataPointSlice) CopyTo(dest MutableExponentialHistogramDataPointSlice) {
	srcLen := es.Len()
	destCap := cap(*dest.getOrig())
	if srcLen <= destCap {
		(*dest.getOrig()) = (*dest.getOrig())[:srcLen:destCap]
		for i := range *es.getOrig() {
			newExponentialHistogramDataPoint((*es.getOrig())[i]).CopyTo(newMutableExponentialHistogramDataPoint((*dest.getOrig())[i]))
		}
		return
	}
	origs := make([]otlpmetrics.ExponentialHistogramDataPoint, srcLen)
	wrappers := make([]*otlpmetrics.ExponentialHistogramDataPoint, srcLen)
	for i := range *es.getOrig() {
		wrappers[i] = &origs[i]
		newExponentialHistogramDataPoint((*es.getOrig())[i]).CopyTo(newMutableExponentialHistogramDataPoint(wrappers[i]))
	}
	*dest.getOrig() = wrappers
}

// CopyTo copies all elements from the current slice overriding the destination.
func (es MutableExponentialHistogramDataPointSlice) CopyTo(dest MutableExponentialHistogramDataPointSlice) {
	newExponentialHistogramDataPointSlice(es.getOrig()).CopyTo(dest)
}

// EnsureCapacity is an operation that ensures the slice has at least the specified capacity.
// 1. If the newCap <= cap then no change in capacity.
// 2. If the newCap > cap then the slice capacity will be expanded to equal newCap.
//
// Here is how a new ExponentialHistogramDataPointSlice can be initialized:
//
//	es := NewExponentialHistogramDataPointSlice()
//	es.EnsureCapacity(4)
//	for i := 0; i < 4; i++ {
//	    e := es.AppendEmpty()
//	    // Here should set all the values for e.
//	}
func (es MutableExponentialHistogramDataPointSlice) EnsureCapacity(newCap int) {
	oldCap := cap(*es.getOrig())
	if newCap <= oldCap {
		return
	}

	newOrig := make([]*otlpmetrics.ExponentialHistogramDataPoint, len(*es.getOrig()), newCap)
	copy(newOrig, *es.getOrig())
	*es.getOrig() = newOrig
}

// AppendEmpty will append to the end of the slice an empty ExponentialHistogramDataPoint.
// It returns the newly added ExponentialHistogramDataPoint.
func (es MutableExponentialHistogramDataPointSlice) AppendEmpty() MutableExponentialHistogramDataPoint {
	*es.getOrig() = append(*es.getOrig(), &otlpmetrics.ExponentialHistogramDataPoint{})
	return es.At(es.Len() - 1)
}

// Sort sorts the ExponentialHistogramDataPoint elements within ExponentialHistogramDataPointSlice given the
// provided less function so that two instances of ExponentialHistogramDataPointSlice
// can be compared.
func (es MutableExponentialHistogramDataPointSlice) Sort(less func(a, b MutableExponentialHistogramDataPoint) bool) {
	sort.SliceStable(*es.getOrig(), func(i, j int) bool { return less(es.At(i), es.At(j)) })
}

// MoveAndAppendTo moves all elements from the current slice and appends them to the dest.
// The current slice will be cleared.
func (es MutableExponentialHistogramDataPointSlice) MoveAndAppendTo(dest MutableExponentialHistogramDataPointSlice) {
	if *dest.getOrig() == nil {
		// We can simply move the entire vector and avoid any allocations.
		*dest.getOrig() = *es.getOrig()
	} else {
		*dest.getOrig() = append(*dest.getOrig(), *es.getOrig()...)
	}
	*es.getOrig() = nil
}

// RemoveIf calls f sequentially for each element present in the slice.
// If f returns true, the element is removed from the slice.
func (es MutableExponentialHistogramDataPointSlice) RemoveIf(f func(MutableExponentialHistogramDataPoint) bool) {
	newLen := 0
	for i := 0; i < len(*es.getOrig()); i++ {
		if f(es.At(i)) {
			continue
		}
		if newLen == i {
			// Nothing to move, element is at the right place.
			newLen++
			continue
		}
		(*es.getOrig())[newLen] = (*es.getOrig())[i]
		newLen++
	}
	// TODO: Prevent memory leak by erasing truncated values.
	*es.getOrig() = (*es.getOrig())[:newLen]
}

// ExponentialHistogramDataPoint is a single data point in a timeseries that describes the
// time-varying values of a ExponentialHistogram of double values. A ExponentialHistogram contains
// summary statistics for a population of values, it may optionally contain the
// distribution of those values across a set of buckets.
//
// This is a reference type, if passed by value and callee modifies it the
// caller will see the modification.
//
// Must use NewExponentialHistogramDataPoint function to create new instances.
// Important: zero-initialized instance is not valid for use.

type ExponentialHistogramDataPoint internal.ExponentialHistogramDataPoint

type MutableExponentialHistogramDataPoint internal.MutableExponentialHistogramDataPoint

func newExponentialHistogramDataPoint(orig *otlpmetrics.ExponentialHistogramDataPoint) ExponentialHistogramDataPoint {
	return ExponentialHistogramDataPoint(internal.NewExponentialHistogramDataPoint(orig))
}

func newMutableExponentialHistogramDataPoint(orig *otlpmetrics.ExponentialHistogramDataPoint) MutableExponentialHistogramDataPoint {
	return MutableExponentialHistogramDataPoint(internal.NewExponentialHistogramDataPoint(orig))
}

func (ms ExponentialHistogramDataPoint) getOrig() *otlpmetrics.ExponentialHistogramDataPoint {
	return internal.GetOrigExponentialHistogramDataPoint(internal.ExponentialHistogramDataPoint(ms))
}

func (ms MutableExponentialHistogramDataPoint) getOrig() *otlpmetrics.ExponentialHistogramDataPoint {
	return internal.GetMutableOrigExponentialHistogramDataPoint(internal.MutableExponentialHistogramDataPoint(ms))
}

// NewExponentialHistogramDataPoint creates a new empty ExponentialHistogramDataPoint.
//
// This must be used only in testing code. Users should use "AppendEmpty" when part of a Slice,
// OR directly access the member if this is embedded in another struct.
func NewExponentialHistogramDataPoint() MutableExponentialHistogramDataPoint {
	return newMutableExponentialHistogramDataPoint(&otlpmetrics.ExponentialHistogramDataPoint{})
}

// MoveTo moves all properties from the current struct overriding the destination and
// resetting the current instance to its zero value
func (ms MutableExponentialHistogramDataPoint) MoveTo(dest MutableExponentialHistogramDataPoint) {
	*dest.getOrig() = *ms.getOrig()
	*ms.getOrig() = otlpmetrics.ExponentialHistogramDataPoint{}
}

// Attributes returns the Attributes associated with this ExponentialHistogramDataPoint.
func (ms ExponentialHistogramDataPoint) Attributes() pcommon.Map {
	return pcommon.Map(internal.NewMap(&ms.getOrig().Attributes))
}

// Attributes returns the Attributes associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) Attributes() pcommon.MutableMap {
	return pcommon.MutableMap(internal.NewMutableMap(&ms.getOrig().Attributes))
}

// StartTimestamp returns the starttimestamp associated with this ExponentialHistogramDataPoint.
func (ms ExponentialHistogramDataPoint) StartTimestamp() pcommon.Timestamp {
	return pcommon.Timestamp(ms.getOrig().StartTimeUnixNano)
}

// StartTimestamp returns the starttimestamp associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) StartTimestamp() pcommon.Timestamp {
	return pcommon.Timestamp(ms.getOrig().StartTimeUnixNano)
}

// SetStartTimestamp replaces the starttimestamp associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) SetStartTimestamp(v pcommon.Timestamp) {
	ms.getOrig().StartTimeUnixNano = uint64(v)
}

// Timestamp returns the timestamp associated with this ExponentialHistogramDataPoint.
func (ms ExponentialHistogramDataPoint) Timestamp() pcommon.Timestamp {
	return pcommon.Timestamp(ms.getOrig().TimeUnixNano)
}

// Timestamp returns the timestamp associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) Timestamp() pcommon.Timestamp {
	return pcommon.Timestamp(ms.getOrig().TimeUnixNano)
}

// SetTimestamp replaces the timestamp associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) SetTimestamp(v pcommon.Timestamp) {
	ms.getOrig().TimeUnixNano = uint64(v)
}

// Count returns the count associated with this ExponentialHistogramDataPoint.
func (ms ExponentialHistogramDataPoint) Count() uint64 {
	return ms.getOrig().Count
}

// MutableCount returns the count associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) Count() uint64 {
	return ms.getOrig().Count
}

// SetCount replaces the count associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) SetCount(v uint64) {
	ms.getOrig().Count = v
}

// Sum returns the sum associated with this ExponentialHistogramDataPoint.
func (ms ExponentialHistogramDataPoint) Sum() float64 {
	return ms.getOrig().GetSum()
}

// Sum returns the sum associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) Sum() float64 {
	return ms.getOrig().GetSum()
}

// HasSum returns true if the ExponentialHistogramDataPoint contains a
// Sum value, false otherwise.
func (ms ExponentialHistogramDataPoint) HasSum() bool {
	return ms.getOrig().Sum_ != nil
}

// HasSum returns true if the ExponentialHistogramDataPoint contains a
// Sum value, false otherwise.
func (ms MutableExponentialHistogramDataPoint) HasSum() bool {
	return ms.getOrig().Sum_ != nil
}

// SetSum replaces the sum associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) SetSum(v float64) {
	ms.getOrig().Sum_ = &otlpmetrics.ExponentialHistogramDataPoint_Sum{Sum: v}
}

// RemoveSum removes the sum associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) RemoveSum() {
	ms.getOrig().Sum_ = nil
}

// Scale returns the scale associated with this ExponentialHistogramDataPoint.
func (ms ExponentialHistogramDataPoint) Scale() int32 {
	return ms.getOrig().Scale
}

// MutableScale returns the scale associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) Scale() int32 {
	return ms.getOrig().Scale
}

// SetScale replaces the scale associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) SetScale(v int32) {
	ms.getOrig().Scale = v
}

// ZeroCount returns the zerocount associated with this ExponentialHistogramDataPoint.
func (ms ExponentialHistogramDataPoint) ZeroCount() uint64 {
	return ms.getOrig().ZeroCount
}

// MutableZeroCount returns the zerocount associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) ZeroCount() uint64 {
	return ms.getOrig().ZeroCount
}

// SetZeroCount replaces the zerocount associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) SetZeroCount(v uint64) {
	ms.getOrig().ZeroCount = v
}

// Positive returns the positive associated with this ExponentialHistogramDataPoint.
func (ms ExponentialHistogramDataPoint) Positive() ExponentialHistogramDataPointBuckets {
	return ExponentialHistogramDataPointBuckets(internal.NewExponentialHistogramDataPointBuckets(&ms.getOrig().Positive))
}

// Positive returns the positive associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) Positive() MutableExponentialHistogramDataPointBuckets {
	return MutableExponentialHistogramDataPointBuckets(internal.NewMutableExponentialHistogramDataPointBuckets(&ms.getOrig().Positive))
}

// Negative returns the negative associated with this ExponentialHistogramDataPoint.
func (ms ExponentialHistogramDataPoint) Negative() ExponentialHistogramDataPointBuckets {
	return ExponentialHistogramDataPointBuckets(internal.NewExponentialHistogramDataPointBuckets(&ms.getOrig().Negative))
}

// Negative returns the negative associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) Negative() MutableExponentialHistogramDataPointBuckets {
	return MutableExponentialHistogramDataPointBuckets(internal.NewMutableExponentialHistogramDataPointBuckets(&ms.getOrig().Negative))
}

// Exemplars returns the Exemplars associated with this ExponentialHistogramDataPoint.
func (ms ExponentialHistogramDataPoint) Exemplars() ExemplarSlice {
	return ExemplarSlice(internal.NewExemplarSlice(&ms.getOrig().Exemplars))
}

// Exemplars returns the Exemplars associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) Exemplars() MutableExemplarSlice {
	return MutableExemplarSlice(internal.NewMutableExemplarSlice(&ms.getOrig().Exemplars))
}

// Flags returns the flags associated with this ExponentialHistogramDataPoint.
func (ms ExponentialHistogramDataPoint) Flags() DataPointFlags {
	return DataPointFlags(ms.getOrig().Flags)
}

// Flags returns the flags associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) Flags() DataPointFlags {
	return DataPointFlags(ms.getOrig().Flags)
}

// SetFlags replaces the flags associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) SetFlags(v DataPointFlags) {
	ms.getOrig().Flags = uint32(v)
}

// Min returns the min associated with this ExponentialHistogramDataPoint.
func (ms ExponentialHistogramDataPoint) Min() float64 {
	return ms.getOrig().GetMin()
}

// Min returns the min associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) Min() float64 {
	return ms.getOrig().GetMin()
}

// HasMin returns true if the ExponentialHistogramDataPoint contains a
// Min value, false otherwise.
func (ms ExponentialHistogramDataPoint) HasMin() bool {
	return ms.getOrig().Min_ != nil
}

// HasMin returns true if the ExponentialHistogramDataPoint contains a
// Min value, false otherwise.
func (ms MutableExponentialHistogramDataPoint) HasMin() bool {
	return ms.getOrig().Min_ != nil
}

// SetMin replaces the min associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) SetMin(v float64) {
	ms.getOrig().Min_ = &otlpmetrics.ExponentialHistogramDataPoint_Min{Min: v}
}

// RemoveMin removes the min associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) RemoveMin() {
	ms.getOrig().Min_ = nil
}

// Max returns the max associated with this ExponentialHistogramDataPoint.
func (ms ExponentialHistogramDataPoint) Max() float64 {
	return ms.getOrig().GetMax()
}

// Max returns the max associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) Max() float64 {
	return ms.getOrig().GetMax()
}

// HasMax returns true if the ExponentialHistogramDataPoint contains a
// Max value, false otherwise.
func (ms ExponentialHistogramDataPoint) HasMax() bool {
	return ms.getOrig().Max_ != nil
}

// HasMax returns true if the ExponentialHistogramDataPoint contains a
// Max value, false otherwise.
func (ms MutableExponentialHistogramDataPoint) HasMax() bool {
	return ms.getOrig().Max_ != nil
}

// SetMax replaces the max associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) SetMax(v float64) {
	ms.getOrig().Max_ = &otlpmetrics.ExponentialHistogramDataPoint_Max{Max: v}
}

// RemoveMax removes the max associated with this ExponentialHistogramDataPoint.
func (ms MutableExponentialHistogramDataPoint) RemoveMax() {
	ms.getOrig().Max_ = nil
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms ExponentialHistogramDataPoint) CopyTo(dest MutableExponentialHistogramDataPoint) {
	ms.Attributes().CopyTo(dest.Attributes())
	dest.SetStartTimestamp(ms.StartTimestamp())
	dest.SetTimestamp(ms.Timestamp())
	dest.SetCount(ms.Count())
	if ms.HasSum() {
		dest.SetSum(ms.Sum())
	}

	dest.SetScale(ms.Scale())
	dest.SetZeroCount(ms.ZeroCount())
	ms.Positive().CopyTo(dest.Positive())
	ms.Negative().CopyTo(dest.Negative())
	ms.Exemplars().CopyTo(dest.Exemplars())
	dest.SetFlags(ms.Flags())
	if ms.HasMin() {
		dest.SetMin(ms.Min())
	}

	if ms.HasMax() {
		dest.SetMax(ms.Max())
	}

}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms MutableExponentialHistogramDataPoint) CopyTo(dest MutableExponentialHistogramDataPoint) {
	newExponentialHistogramDataPoint(ms.getOrig()).CopyTo(dest)
}

// ExponentialHistogramDataPointBuckets are a set of bucket counts, encoded in a contiguous array of counts.
//
// This is a reference type, if passed by value and callee modifies it the
// caller will see the modification.
//
// Must use NewExponentialHistogramDataPointBuckets function to create new instances.
// Important: zero-initialized instance is not valid for use.

type ExponentialHistogramDataPointBuckets internal.ExponentialHistogramDataPointBuckets

type MutableExponentialHistogramDataPointBuckets internal.MutableExponentialHistogramDataPointBuckets

func newExponentialHistogramDataPointBuckets(orig *otlpmetrics.ExponentialHistogramDataPoint_Buckets) ExponentialHistogramDataPointBuckets {
	return ExponentialHistogramDataPointBuckets(internal.NewExponentialHistogramDataPointBuckets(orig))
}

func newMutableExponentialHistogramDataPointBuckets(orig *otlpmetrics.ExponentialHistogramDataPoint_Buckets) MutableExponentialHistogramDataPointBuckets {
	return MutableExponentialHistogramDataPointBuckets(internal.NewExponentialHistogramDataPointBuckets(orig))
}

func (ms ExponentialHistogramDataPointBuckets) getOrig() *otlpmetrics.ExponentialHistogramDataPoint_Buckets {
	return internal.GetOrigExponentialHistogramDataPointBuckets(internal.ExponentialHistogramDataPointBuckets(ms))
}

func (ms MutableExponentialHistogramDataPointBuckets) getOrig() *otlpmetrics.ExponentialHistogramDataPoint_Buckets {
	return internal.GetMutableOrigExponentialHistogramDataPointBuckets(internal.MutableExponentialHistogramDataPointBuckets(ms))
}

// NewExponentialHistogramDataPointBuckets creates a new empty ExponentialHistogramDataPointBuckets.
//
// This must be used only in testing code. Users should use "AppendEmpty" when part of a Slice,
// OR directly access the member if this is embedded in another struct.
func NewExponentialHistogramDataPointBuckets() MutableExponentialHistogramDataPointBuckets {
	return newMutableExponentialHistogramDataPointBuckets(&otlpmetrics.ExponentialHistogramDataPoint_Buckets{})
}

// MoveTo moves all properties from the current struct overriding the destination and
// resetting the current instance to its zero value
func (ms MutableExponentialHistogramDataPointBuckets) MoveTo(dest MutableExponentialHistogramDataPointBuckets) {
	*dest.getOrig() = *ms.getOrig()
	*ms.getOrig() = otlpmetrics.ExponentialHistogramDataPoint_Buckets{}
}

// Offset returns the offset associated with this ExponentialHistogramDataPointBuckets.
func (ms ExponentialHistogramDataPointBuckets) Offset() int32 {
	return ms.getOrig().Offset
}

// MutableOffset returns the offset associated with this ExponentialHistogramDataPointBuckets.
func (ms MutableExponentialHistogramDataPointBuckets) Offset() int32 {
	return ms.getOrig().Offset
}

// SetOffset replaces the offset associated with this ExponentialHistogramDataPointBuckets.
func (ms MutableExponentialHistogramDataPointBuckets) SetOffset(v int32) {
	ms.getOrig().Offset = v
}

// BucketCounts returns the bucketcounts associated with this ExponentialHistogramDataPointBuckets.
func (ms ExponentialHistogramDataPointBuckets) BucketCounts() pcommon.UInt64Slice {
	return pcommon.UInt64Slice(internal.NewUInt64Slice(&ms.getOrig().BucketCounts))
}

// BucketCounts returns the bucketcounts associated with this ExponentialHistogramDataPointBuckets.
func (ms MutableExponentialHistogramDataPointBuckets) BucketCounts() pcommon.MutableUInt64Slice {
	return pcommon.MutableUInt64Slice(internal.NewMutableUInt64Slice(&ms.getOrig().BucketCounts))
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms ExponentialHistogramDataPointBuckets) CopyTo(dest MutableExponentialHistogramDataPointBuckets) {
	dest.SetOffset(ms.Offset())
	ms.BucketCounts().CopyTo(dest.BucketCounts())
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms MutableExponentialHistogramDataPointBuckets) CopyTo(dest MutableExponentialHistogramDataPointBuckets) {
	newExponentialHistogramDataPointBuckets(ms.getOrig()).CopyTo(dest)
}

// SummaryDataPointSlice logically represents a slice of SummaryDataPoint.
//
// This is a reference type. If passed by value and callee modifies it, the
// caller will see the modification.
//
// Must use NewSummaryDataPointSlice function to create new instances.
// Important: zero-initialized instance is not valid for use.
type SummaryDataPointSlice internal.SummaryDataPointSlice

type MutableSummaryDataPointSlice internal.MutableSummaryDataPointSlice

func newSummaryDataPointSlice(orig *[]*otlpmetrics.SummaryDataPoint) SummaryDataPointSlice {
	return SummaryDataPointSlice(internal.NewSummaryDataPointSlice(orig))
}

func newMutableSummaryDataPointSlice(orig *[]*otlpmetrics.SummaryDataPoint) MutableSummaryDataPointSlice {
	return MutableSummaryDataPointSlice(internal.NewSummaryDataPointSlice(orig))
}

func (ms SummaryDataPointSlice) getOrig() *[]*otlpmetrics.SummaryDataPoint {
	return internal.GetOrigSummaryDataPointSlice(internal.SummaryDataPointSlice(ms))
}

func (ms MutableSummaryDataPointSlice) getOrig() *[]*otlpmetrics.SummaryDataPoint {
	return internal.GetMutableOrigSummaryDataPointSlice(internal.MutableSummaryDataPointSlice(ms))
}

// NewSummaryDataPointSlice creates a SummaryDataPointSlice with 0 elements.
// Can use "EnsureCapacity" to initialize with a given capacity.
func NewSummaryDataPointSlice() MutableSummaryDataPointSlice {
	orig := []*otlpmetrics.SummaryDataPoint(nil)
	return newMutableSummaryDataPointSlice(&orig)
}

// Len returns the number of elements in the slice.
//
// Returns "0" for a newly instance created with "NewSummaryDataPointSlice()".
func (es SummaryDataPointSlice) Len() int {
	return len(*es.getOrig())
}

func (es MutableSummaryDataPointSlice) Len() int {
	return len(*es.getOrig())
}

// At returns the element at the given index.
//
// This function is used mostly for iterating over all the values in the slice:
//
//	for i := 0; i < es.Len(); i++ {
//	    e := es.At(i)
//	    ... // Do something with the element
//	}
func (es SummaryDataPointSlice) At(ix int) SummaryDataPoint {
	return newSummaryDataPoint((*es.getOrig())[ix])
}

func (es MutableSummaryDataPointSlice) At(ix int) MutableSummaryDataPoint {
	return newMutableSummaryDataPoint((*es.getOrig())[ix])
}

// CopyTo copies all elements from the current slice overriding the destination.
func (es SummaryDataPointSlice) CopyTo(dest MutableSummaryDataPointSlice) {
	srcLen := es.Len()
	destCap := cap(*dest.getOrig())
	if srcLen <= destCap {
		(*dest.getOrig()) = (*dest.getOrig())[:srcLen:destCap]
		for i := range *es.getOrig() {
			newSummaryDataPoint((*es.getOrig())[i]).CopyTo(newMutableSummaryDataPoint((*dest.getOrig())[i]))
		}
		return
	}
	origs := make([]otlpmetrics.SummaryDataPoint, srcLen)
	wrappers := make([]*otlpmetrics.SummaryDataPoint, srcLen)
	for i := range *es.getOrig() {
		wrappers[i] = &origs[i]
		newSummaryDataPoint((*es.getOrig())[i]).CopyTo(newMutableSummaryDataPoint(wrappers[i]))
	}
	*dest.getOrig() = wrappers
}

// CopyTo copies all elements from the current slice overriding the destination.
func (es MutableSummaryDataPointSlice) CopyTo(dest MutableSummaryDataPointSlice) {
	newSummaryDataPointSlice(es.getOrig()).CopyTo(dest)
}

// EnsureCapacity is an operation that ensures the slice has at least the specified capacity.
// 1. If the newCap <= cap then no change in capacity.
// 2. If the newCap > cap then the slice capacity will be expanded to equal newCap.
//
// Here is how a new SummaryDataPointSlice can be initialized:
//
//	es := NewSummaryDataPointSlice()
//	es.EnsureCapacity(4)
//	for i := 0; i < 4; i++ {
//	    e := es.AppendEmpty()
//	    // Here should set all the values for e.
//	}
func (es MutableSummaryDataPointSlice) EnsureCapacity(newCap int) {
	oldCap := cap(*es.getOrig())
	if newCap <= oldCap {
		return
	}

	newOrig := make([]*otlpmetrics.SummaryDataPoint, len(*es.getOrig()), newCap)
	copy(newOrig, *es.getOrig())
	*es.getOrig() = newOrig
}

// AppendEmpty will append to the end of the slice an empty SummaryDataPoint.
// It returns the newly added SummaryDataPoint.
func (es MutableSummaryDataPointSlice) AppendEmpty() MutableSummaryDataPoint {
	*es.getOrig() = append(*es.getOrig(), &otlpmetrics.SummaryDataPoint{})
	return es.At(es.Len() - 1)
}

// Sort sorts the SummaryDataPoint elements within SummaryDataPointSlice given the
// provided less function so that two instances of SummaryDataPointSlice
// can be compared.
func (es MutableSummaryDataPointSlice) Sort(less func(a, b MutableSummaryDataPoint) bool) {
	sort.SliceStable(*es.getOrig(), func(i, j int) bool { return less(es.At(i), es.At(j)) })
}

// MoveAndAppendTo moves all elements from the current slice and appends them to the dest.
// The current slice will be cleared.
func (es MutableSummaryDataPointSlice) MoveAndAppendTo(dest MutableSummaryDataPointSlice) {
	if *dest.getOrig() == nil {
		// We can simply move the entire vector and avoid any allocations.
		*dest.getOrig() = *es.getOrig()
	} else {
		*dest.getOrig() = append(*dest.getOrig(), *es.getOrig()...)
	}
	*es.getOrig() = nil
}

// RemoveIf calls f sequentially for each element present in the slice.
// If f returns true, the element is removed from the slice.
func (es MutableSummaryDataPointSlice) RemoveIf(f func(MutableSummaryDataPoint) bool) {
	newLen := 0
	for i := 0; i < len(*es.getOrig()); i++ {
		if f(es.At(i)) {
			continue
		}
		if newLen == i {
			// Nothing to move, element is at the right place.
			newLen++
			continue
		}
		(*es.getOrig())[newLen] = (*es.getOrig())[i]
		newLen++
	}
	// TODO: Prevent memory leak by erasing truncated values.
	*es.getOrig() = (*es.getOrig())[:newLen]
}

// SummaryDataPoint is a single data point in a timeseries that describes the time-varying values of a Summary of double values.
//
// This is a reference type, if passed by value and callee modifies it the
// caller will see the modification.
//
// Must use NewSummaryDataPoint function to create new instances.
// Important: zero-initialized instance is not valid for use.

type SummaryDataPoint internal.SummaryDataPoint

type MutableSummaryDataPoint internal.MutableSummaryDataPoint

func newSummaryDataPoint(orig *otlpmetrics.SummaryDataPoint) SummaryDataPoint {
	return SummaryDataPoint(internal.NewSummaryDataPoint(orig))
}

func newMutableSummaryDataPoint(orig *otlpmetrics.SummaryDataPoint) MutableSummaryDataPoint {
	return MutableSummaryDataPoint(internal.NewSummaryDataPoint(orig))
}

func (ms SummaryDataPoint) getOrig() *otlpmetrics.SummaryDataPoint {
	return internal.GetOrigSummaryDataPoint(internal.SummaryDataPoint(ms))
}

func (ms MutableSummaryDataPoint) getOrig() *otlpmetrics.SummaryDataPoint {
	return internal.GetMutableOrigSummaryDataPoint(internal.MutableSummaryDataPoint(ms))
}

// NewSummaryDataPoint creates a new empty SummaryDataPoint.
//
// This must be used only in testing code. Users should use "AppendEmpty" when part of a Slice,
// OR directly access the member if this is embedded in another struct.
func NewSummaryDataPoint() MutableSummaryDataPoint {
	return newMutableSummaryDataPoint(&otlpmetrics.SummaryDataPoint{})
}

// MoveTo moves all properties from the current struct overriding the destination and
// resetting the current instance to its zero value
func (ms MutableSummaryDataPoint) MoveTo(dest MutableSummaryDataPoint) {
	*dest.getOrig() = *ms.getOrig()
	*ms.getOrig() = otlpmetrics.SummaryDataPoint{}
}

// Attributes returns the Attributes associated with this SummaryDataPoint.
func (ms SummaryDataPoint) Attributes() pcommon.Map {
	return pcommon.Map(internal.NewMap(&ms.getOrig().Attributes))
}

// Attributes returns the Attributes associated with this SummaryDataPoint.
func (ms MutableSummaryDataPoint) Attributes() pcommon.MutableMap {
	return pcommon.MutableMap(internal.NewMutableMap(&ms.getOrig().Attributes))
}

// StartTimestamp returns the starttimestamp associated with this SummaryDataPoint.
func (ms SummaryDataPoint) StartTimestamp() pcommon.Timestamp {
	return pcommon.Timestamp(ms.getOrig().StartTimeUnixNano)
}

// StartTimestamp returns the starttimestamp associated with this SummaryDataPoint.
func (ms MutableSummaryDataPoint) StartTimestamp() pcommon.Timestamp {
	return pcommon.Timestamp(ms.getOrig().StartTimeUnixNano)
}

// SetStartTimestamp replaces the starttimestamp associated with this SummaryDataPoint.
func (ms MutableSummaryDataPoint) SetStartTimestamp(v pcommon.Timestamp) {
	ms.getOrig().StartTimeUnixNano = uint64(v)
}

// Timestamp returns the timestamp associated with this SummaryDataPoint.
func (ms SummaryDataPoint) Timestamp() pcommon.Timestamp {
	return pcommon.Timestamp(ms.getOrig().TimeUnixNano)
}

// Timestamp returns the timestamp associated with this SummaryDataPoint.
func (ms MutableSummaryDataPoint) Timestamp() pcommon.Timestamp {
	return pcommon.Timestamp(ms.getOrig().TimeUnixNano)
}

// SetTimestamp replaces the timestamp associated with this SummaryDataPoint.
func (ms MutableSummaryDataPoint) SetTimestamp(v pcommon.Timestamp) {
	ms.getOrig().TimeUnixNano = uint64(v)
}

// Count returns the count associated with this SummaryDataPoint.
func (ms SummaryDataPoint) Count() uint64 {
	return ms.getOrig().Count
}

// MutableCount returns the count associated with this SummaryDataPoint.
func (ms MutableSummaryDataPoint) Count() uint64 {
	return ms.getOrig().Count
}

// SetCount replaces the count associated with this SummaryDataPoint.
func (ms MutableSummaryDataPoint) SetCount(v uint64) {
	ms.getOrig().Count = v
}

// Sum returns the sum associated with this SummaryDataPoint.
func (ms SummaryDataPoint) Sum() float64 {
	return ms.getOrig().Sum
}

// MutableSum returns the sum associated with this SummaryDataPoint.
func (ms MutableSummaryDataPoint) Sum() float64 {
	return ms.getOrig().Sum
}

// SetSum replaces the sum associated with this SummaryDataPoint.
func (ms MutableSummaryDataPoint) SetSum(v float64) {
	ms.getOrig().Sum = v
}

// QuantileValues returns the QuantileValues associated with this SummaryDataPoint.
func (ms SummaryDataPoint) QuantileValues() SummaryDataPointValueAtQuantileSlice {
	return SummaryDataPointValueAtQuantileSlice(internal.NewSummaryDataPointValueAtQuantileSlice(&ms.getOrig().QuantileValues))
}

// QuantileValues returns the QuantileValues associated with this SummaryDataPoint.
func (ms MutableSummaryDataPoint) QuantileValues() MutableSummaryDataPointValueAtQuantileSlice {
	return MutableSummaryDataPointValueAtQuantileSlice(internal.NewMutableSummaryDataPointValueAtQuantileSlice(&ms.getOrig().QuantileValues))
}

// Flags returns the flags associated with this SummaryDataPoint.
func (ms SummaryDataPoint) Flags() DataPointFlags {
	return DataPointFlags(ms.getOrig().Flags)
}

// Flags returns the flags associated with this SummaryDataPoint.
func (ms MutableSummaryDataPoint) Flags() DataPointFlags {
	return DataPointFlags(ms.getOrig().Flags)
}

// SetFlags replaces the flags associated with this SummaryDataPoint.
func (ms MutableSummaryDataPoint) SetFlags(v DataPointFlags) {
	ms.getOrig().Flags = uint32(v)
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms SummaryDataPoint) CopyTo(dest MutableSummaryDataPoint) {
	ms.Attributes().CopyTo(dest.Attributes())
	dest.SetStartTimestamp(ms.StartTimestamp())
	dest.SetTimestamp(ms.Timestamp())
	dest.SetCount(ms.Count())
	dest.SetSum(ms.Sum())
	ms.QuantileValues().CopyTo(dest.QuantileValues())
	dest.SetFlags(ms.Flags())
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms MutableSummaryDataPoint) CopyTo(dest MutableSummaryDataPoint) {
	newSummaryDataPoint(ms.getOrig()).CopyTo(dest)
}

// SummaryDataPointValueAtQuantileSlice logically represents a slice of SummaryDataPointValueAtQuantile.
//
// This is a reference type. If passed by value and callee modifies it, the
// caller will see the modification.
//
// Must use NewSummaryDataPointValueAtQuantileSlice function to create new instances.
// Important: zero-initialized instance is not valid for use.
type SummaryDataPointValueAtQuantileSlice internal.SummaryDataPointValueAtQuantileSlice

type MutableSummaryDataPointValueAtQuantileSlice internal.MutableSummaryDataPointValueAtQuantileSlice

func newSummaryDataPointValueAtQuantileSlice(orig *[]*otlpmetrics.SummaryDataPoint_ValueAtQuantile) SummaryDataPointValueAtQuantileSlice {
	return SummaryDataPointValueAtQuantileSlice(internal.NewSummaryDataPointValueAtQuantileSlice(orig))
}

func newMutableSummaryDataPointValueAtQuantileSlice(orig *[]*otlpmetrics.SummaryDataPoint_ValueAtQuantile) MutableSummaryDataPointValueAtQuantileSlice {
	return MutableSummaryDataPointValueAtQuantileSlice(internal.NewSummaryDataPointValueAtQuantileSlice(orig))
}

func (ms SummaryDataPointValueAtQuantileSlice) getOrig() *[]*otlpmetrics.SummaryDataPoint_ValueAtQuantile {
	return internal.GetOrigSummaryDataPointValueAtQuantileSlice(internal.SummaryDataPointValueAtQuantileSlice(ms))
}

func (ms MutableSummaryDataPointValueAtQuantileSlice) getOrig() *[]*otlpmetrics.SummaryDataPoint_ValueAtQuantile {
	return internal.GetMutableOrigSummaryDataPointValueAtQuantileSlice(internal.MutableSummaryDataPointValueAtQuantileSlice(ms))
}

// NewSummaryDataPointValueAtQuantileSlice creates a SummaryDataPointValueAtQuantileSlice with 0 elements.
// Can use "EnsureCapacity" to initialize with a given capacity.
func NewSummaryDataPointValueAtQuantileSlice() MutableSummaryDataPointValueAtQuantileSlice {
	orig := []*otlpmetrics.SummaryDataPoint_ValueAtQuantile(nil)
	return newMutableSummaryDataPointValueAtQuantileSlice(&orig)
}

// Len returns the number of elements in the slice.
//
// Returns "0" for a newly instance created with "NewSummaryDataPointValueAtQuantileSlice()".
func (es SummaryDataPointValueAtQuantileSlice) Len() int {
	return len(*es.getOrig())
}

func (es MutableSummaryDataPointValueAtQuantileSlice) Len() int {
	return len(*es.getOrig())
}

// At returns the element at the given index.
//
// This function is used mostly for iterating over all the values in the slice:
//
//	for i := 0; i < es.Len(); i++ {
//	    e := es.At(i)
//	    ... // Do something with the element
//	}
func (es SummaryDataPointValueAtQuantileSlice) At(ix int) SummaryDataPointValueAtQuantile {
	return newSummaryDataPointValueAtQuantile((*es.getOrig())[ix])
}

func (es MutableSummaryDataPointValueAtQuantileSlice) At(ix int) MutableSummaryDataPointValueAtQuantile {
	return newMutableSummaryDataPointValueAtQuantile((*es.getOrig())[ix])
}

// CopyTo copies all elements from the current slice overriding the destination.
func (es SummaryDataPointValueAtQuantileSlice) CopyTo(dest MutableSummaryDataPointValueAtQuantileSlice) {
	srcLen := es.Len()
	destCap := cap(*dest.getOrig())
	if srcLen <= destCap {
		(*dest.getOrig()) = (*dest.getOrig())[:srcLen:destCap]
		for i := range *es.getOrig() {
			newSummaryDataPointValueAtQuantile((*es.getOrig())[i]).CopyTo(newMutableSummaryDataPointValueAtQuantile((*dest.getOrig())[i]))
		}
		return
	}
	origs := make([]otlpmetrics.SummaryDataPoint_ValueAtQuantile, srcLen)
	wrappers := make([]*otlpmetrics.SummaryDataPoint_ValueAtQuantile, srcLen)
	for i := range *es.getOrig() {
		wrappers[i] = &origs[i]
		newSummaryDataPointValueAtQuantile((*es.getOrig())[i]).CopyTo(newMutableSummaryDataPointValueAtQuantile(wrappers[i]))
	}
	*dest.getOrig() = wrappers
}

// CopyTo copies all elements from the current slice overriding the destination.
func (es MutableSummaryDataPointValueAtQuantileSlice) CopyTo(dest MutableSummaryDataPointValueAtQuantileSlice) {
	newSummaryDataPointValueAtQuantileSlice(es.getOrig()).CopyTo(dest)
}

// EnsureCapacity is an operation that ensures the slice has at least the specified capacity.
// 1. If the newCap <= cap then no change in capacity.
// 2. If the newCap > cap then the slice capacity will be expanded to equal newCap.
//
// Here is how a new SummaryDataPointValueAtQuantileSlice can be initialized:
//
//	es := NewSummaryDataPointValueAtQuantileSlice()
//	es.EnsureCapacity(4)
//	for i := 0; i < 4; i++ {
//	    e := es.AppendEmpty()
//	    // Here should set all the values for e.
//	}
func (es MutableSummaryDataPointValueAtQuantileSlice) EnsureCapacity(newCap int) {
	oldCap := cap(*es.getOrig())
	if newCap <= oldCap {
		return
	}

	newOrig := make([]*otlpmetrics.SummaryDataPoint_ValueAtQuantile, len(*es.getOrig()), newCap)
	copy(newOrig, *es.getOrig())
	*es.getOrig() = newOrig
}

// AppendEmpty will append to the end of the slice an empty SummaryDataPointValueAtQuantile.
// It returns the newly added SummaryDataPointValueAtQuantile.
func (es MutableSummaryDataPointValueAtQuantileSlice) AppendEmpty() MutableSummaryDataPointValueAtQuantile {
	*es.getOrig() = append(*es.getOrig(), &otlpmetrics.SummaryDataPoint_ValueAtQuantile{})
	return es.At(es.Len() - 1)
}

// Sort sorts the SummaryDataPointValueAtQuantile elements within SummaryDataPointValueAtQuantileSlice given the
// provided less function so that two instances of SummaryDataPointValueAtQuantileSlice
// can be compared.
func (es MutableSummaryDataPointValueAtQuantileSlice) Sort(less func(a, b MutableSummaryDataPointValueAtQuantile) bool) {
	sort.SliceStable(*es.getOrig(), func(i, j int) bool { return less(es.At(i), es.At(j)) })
}

// MoveAndAppendTo moves all elements from the current slice and appends them to the dest.
// The current slice will be cleared.
func (es MutableSummaryDataPointValueAtQuantileSlice) MoveAndAppendTo(dest MutableSummaryDataPointValueAtQuantileSlice) {
	if *dest.getOrig() == nil {
		// We can simply move the entire vector and avoid any allocations.
		*dest.getOrig() = *es.getOrig()
	} else {
		*dest.getOrig() = append(*dest.getOrig(), *es.getOrig()...)
	}
	*es.getOrig() = nil
}

// RemoveIf calls f sequentially for each element present in the slice.
// If f returns true, the element is removed from the slice.
func (es MutableSummaryDataPointValueAtQuantileSlice) RemoveIf(f func(MutableSummaryDataPointValueAtQuantile) bool) {
	newLen := 0
	for i := 0; i < len(*es.getOrig()); i++ {
		if f(es.At(i)) {
			continue
		}
		if newLen == i {
			// Nothing to move, element is at the right place.
			newLen++
			continue
		}
		(*es.getOrig())[newLen] = (*es.getOrig())[i]
		newLen++
	}
	// TODO: Prevent memory leak by erasing truncated values.
	*es.getOrig() = (*es.getOrig())[:newLen]
}

// SummaryDataPointValueAtQuantile is a quantile value within a Summary data point.
//
// This is a reference type, if passed by value and callee modifies it the
// caller will see the modification.
//
// Must use NewSummaryDataPointValueAtQuantile function to create new instances.
// Important: zero-initialized instance is not valid for use.

type SummaryDataPointValueAtQuantile internal.SummaryDataPointValueAtQuantile

type MutableSummaryDataPointValueAtQuantile internal.MutableSummaryDataPointValueAtQuantile

func newSummaryDataPointValueAtQuantile(orig *otlpmetrics.SummaryDataPoint_ValueAtQuantile) SummaryDataPointValueAtQuantile {
	return SummaryDataPointValueAtQuantile(internal.NewSummaryDataPointValueAtQuantile(orig))
}

func newMutableSummaryDataPointValueAtQuantile(orig *otlpmetrics.SummaryDataPoint_ValueAtQuantile) MutableSummaryDataPointValueAtQuantile {
	return MutableSummaryDataPointValueAtQuantile(internal.NewSummaryDataPointValueAtQuantile(orig))
}

func (ms SummaryDataPointValueAtQuantile) getOrig() *otlpmetrics.SummaryDataPoint_ValueAtQuantile {
	return internal.GetOrigSummaryDataPointValueAtQuantile(internal.SummaryDataPointValueAtQuantile(ms))
}

func (ms MutableSummaryDataPointValueAtQuantile) getOrig() *otlpmetrics.SummaryDataPoint_ValueAtQuantile {
	return internal.GetMutableOrigSummaryDataPointValueAtQuantile(internal.MutableSummaryDataPointValueAtQuantile(ms))
}

// NewSummaryDataPointValueAtQuantile creates a new empty SummaryDataPointValueAtQuantile.
//
// This must be used only in testing code. Users should use "AppendEmpty" when part of a Slice,
// OR directly access the member if this is embedded in another struct.
func NewSummaryDataPointValueAtQuantile() MutableSummaryDataPointValueAtQuantile {
	return newMutableSummaryDataPointValueAtQuantile(&otlpmetrics.SummaryDataPoint_ValueAtQuantile{})
}

// MoveTo moves all properties from the current struct overriding the destination and
// resetting the current instance to its zero value
func (ms MutableSummaryDataPointValueAtQuantile) MoveTo(dest MutableSummaryDataPointValueAtQuantile) {
	*dest.getOrig() = *ms.getOrig()
	*ms.getOrig() = otlpmetrics.SummaryDataPoint_ValueAtQuantile{}
}

// Quantile returns the quantile associated with this SummaryDataPointValueAtQuantile.
func (ms SummaryDataPointValueAtQuantile) Quantile() float64 {
	return ms.getOrig().Quantile
}

// MutableQuantile returns the quantile associated with this SummaryDataPointValueAtQuantile.
func (ms MutableSummaryDataPointValueAtQuantile) Quantile() float64 {
	return ms.getOrig().Quantile
}

// SetQuantile replaces the quantile associated with this SummaryDataPointValueAtQuantile.
func (ms MutableSummaryDataPointValueAtQuantile) SetQuantile(v float64) {
	ms.getOrig().Quantile = v
}

// Value returns the value associated with this SummaryDataPointValueAtQuantile.
func (ms SummaryDataPointValueAtQuantile) Value() float64 {
	return ms.getOrig().Value
}

// MutableValue returns the value associated with this SummaryDataPointValueAtQuantile.
func (ms MutableSummaryDataPointValueAtQuantile) Value() float64 {
	return ms.getOrig().Value
}

// SetValue replaces the value associated with this SummaryDataPointValueAtQuantile.
func (ms MutableSummaryDataPointValueAtQuantile) SetValue(v float64) {
	ms.getOrig().Value = v
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms SummaryDataPointValueAtQuantile) CopyTo(dest MutableSummaryDataPointValueAtQuantile) {
	dest.SetQuantile(ms.Quantile())
	dest.SetValue(ms.Value())
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms MutableSummaryDataPointValueAtQuantile) CopyTo(dest MutableSummaryDataPointValueAtQuantile) {
	newSummaryDataPointValueAtQuantile(ms.getOrig()).CopyTo(dest)
}

// ExemplarSlice logically represents a slice of Exemplar.
//
// This is a reference type. If passed by value and callee modifies it, the
// caller will see the modification.
//
// Must use NewExemplarSlice function to create new instances.
// Important: zero-initialized instance is not valid for use.
type ExemplarSlice internal.ExemplarSlice

type MutableExemplarSlice internal.MutableExemplarSlice

func newExemplarSlice(orig *[]otlpmetrics.Exemplar) ExemplarSlice {
	return ExemplarSlice(internal.NewExemplarSlice(orig))
}

func newMutableExemplarSlice(orig *[]otlpmetrics.Exemplar) MutableExemplarSlice {
	return MutableExemplarSlice(internal.NewExemplarSlice(orig))
}

func (ms ExemplarSlice) getOrig() *[]otlpmetrics.Exemplar {
	return internal.GetOrigExemplarSlice(internal.ExemplarSlice(ms))
}

func (ms MutableExemplarSlice) getOrig() *[]otlpmetrics.Exemplar {
	return internal.GetMutableOrigExemplarSlice(internal.MutableExemplarSlice(ms))
}

func (ms MutableExemplarSlice) immutable() ExemplarSlice {
	return newExemplarSlice(ms.getOrig())
}

// NewExemplarSlice creates a ExemplarSlice with 0 elements.
// Can use "EnsureCapacity" to initialize with a given capacity.
func NewExemplarSlice() MutableExemplarSlice {
	orig := []otlpmetrics.Exemplar(nil)
	return MutableExemplarSlice(internal.NewExemplarSlice(&orig))
}

// Len returns the number of elements in the slice.
//
// Returns "0" for a newly instance created with "NewExemplarSlice()".
func (es ExemplarSlice) Len() int {
	return len(*es.getOrig())
}

func (es MutableExemplarSlice) Len() int {
	return newMutableExemplarSlice(es.getOrig()).Len()
}

// At returns the element at the given index.
//
// This function is used mostly for iterating over all the values in the slice:
//
//	for i := 0; i < es.Len(); i++ {
//	    e := es.At(i)
//	    ... // Do something with the element
//	}
func (es ExemplarSlice) At(ix int) Exemplar {
	return newExemplar(&(*es.getOrig())[ix])
}

func (es MutableExemplarSlice) At(ix int) MutableExemplar {
	return newMutableExemplar(&(*es.getOrig())[ix])
}

// CopyTo copies all elements from the current slice overriding the destination.
func (es ExemplarSlice) CopyTo(dest MutableExemplarSlice) {
	srcLen := es.Len()
	destCap := cap(*dest.getOrig())
	if srcLen <= destCap {
		(*dest.getOrig()) = (*dest.getOrig())[:srcLen:destCap]
	} else {
		(*dest.getOrig()) = make([]otlpmetrics.Exemplar, srcLen)
	}

	for i := range *es.getOrig() {
		newExemplar(&(*es.getOrig())[i]).CopyTo(newMutableExemplar(&(*dest.getOrig())[i]))
	}
}

// CopyTo copies all elements from the current slice overriding the destination.
func (es MutableExemplarSlice) CopyTo(dest MutableExemplarSlice) {
	newExemplarSlice(es.getOrig()).CopyTo(dest)
}

// EnsureCapacity is an operation that ensures the slice has at least the specified capacity.
// 1. If the newCap <= cap then no change in capacity.
// 2. If the newCap > cap then the slice capacity will be expanded to equal newCap.
//
// Here is how a new ExemplarSlice can be initialized:
//
//	es := NewExemplarSlice()
//	es.EnsureCapacity(4)
//	for i := 0; i < 4; i++ {
//	    e := es.AppendEmpty()
//	    // Here should set all the values for e.
//	}
func (es MutableExemplarSlice) EnsureCapacity(newCap int) {
	oldCap := cap(*es.getOrig())
	if newCap <= oldCap {
		return
	}

	newOrig := make([]otlpmetrics.Exemplar, len(*es.getOrig()), newCap)
	copy(newOrig, *es.getOrig())
	*es.getOrig() = newOrig
}

// AppendEmpty will append to the end of the slice an empty Exemplar.
// It returns the newly added Exemplar.
func (es MutableExemplarSlice) AppendEmpty() MutableExemplar {
	*es.getOrig() = append(*es.getOrig(), otlpmetrics.Exemplar{})
	return es.At(es.Len() - 1)
}

// MoveAndAppendTo moves all elements from the current slice and appends them to the dest.
// The current slice will be cleared.
func (es MutableExemplarSlice) MoveAndAppendTo(dest MutableExemplarSlice) {
	if *dest.getOrig() == nil {
		// We can simply move the entire vector and avoid any allocations.
		*dest.getOrig() = *es.getOrig()
	} else {
		*dest.getOrig() = append(*dest.getOrig(), *es.getOrig()...)
	}
	*es.getOrig() = nil
}

// RemoveIf calls f sequentially for each element present in the slice.
// If f returns true, the element is removed from the slice.
func (es MutableExemplarSlice) RemoveIf(f func(MutableExemplar) bool) {
	newLen := 0
	for i := 0; i < len(*es.getOrig()); i++ {
		if f(es.At(i)) {
			continue
		}
		if newLen == i {
			// Nothing to move, element is at the right place.
			newLen++
			continue
		}
		(*es.getOrig())[newLen] = (*es.getOrig())[i]
		newLen++
	}
	// TODO: Prevent memory leak by erasing truncated values.
	*es.getOrig() = (*es.getOrig())[:newLen]
}

// Exemplar is a sample input double measurement.
//
// Exemplars also hold information about the environment when the measurement was recorded,
// for example the span and trace ID of the active span when the exemplar was recorded.
//
// This is a reference type, if passed by value and callee modifies it the
// caller will see the modification.
//
// Must use NewExemplar function to create new instances.
// Important: zero-initialized instance is not valid for use.

type Exemplar internal.Exemplar

type MutableExemplar internal.MutableExemplar

func newExemplar(orig *otlpmetrics.Exemplar) Exemplar {
	return Exemplar(internal.NewExemplar(orig))
}

func newMutableExemplar(orig *otlpmetrics.Exemplar) MutableExemplar {
	return MutableExemplar(internal.NewExemplar(orig))
}

func (ms Exemplar) getOrig() *otlpmetrics.Exemplar {
	return internal.GetOrigExemplar(internal.Exemplar(ms))
}

func (ms MutableExemplar) getOrig() *otlpmetrics.Exemplar {
	return internal.GetMutableOrigExemplar(internal.MutableExemplar(ms))
}

// NewExemplar creates a new empty Exemplar.
//
// This must be used only in testing code. Users should use "AppendEmpty" when part of a Slice,
// OR directly access the member if this is embedded in another struct.
func NewExemplar() MutableExemplar {
	return newMutableExemplar(&otlpmetrics.Exemplar{})
}

// MoveTo moves all properties from the current struct overriding the destination and
// resetting the current instance to its zero value
func (ms MutableExemplar) MoveTo(dest MutableExemplar) {
	*dest.getOrig() = *ms.getOrig()
	*ms.getOrig() = otlpmetrics.Exemplar{}
}

// Timestamp returns the timestamp associated with this Exemplar.
func (ms Exemplar) Timestamp() pcommon.Timestamp {
	return pcommon.Timestamp(ms.getOrig().TimeUnixNano)
}

// Timestamp returns the timestamp associated with this Exemplar.
func (ms MutableExemplar) Timestamp() pcommon.Timestamp {
	return pcommon.Timestamp(ms.getOrig().TimeUnixNano)
}

// SetTimestamp replaces the timestamp associated with this Exemplar.
func (ms MutableExemplar) SetTimestamp(v pcommon.Timestamp) {
	ms.getOrig().TimeUnixNano = uint64(v)
}

// ValueType returns the type of the value for this Exemplar.
// Calling this function on zero-initialized Exemplar will cause a panic.
func (ms Exemplar) ValueType() ExemplarValueType {
	switch ms.getOrig().Value.(type) {
	case *otlpmetrics.Exemplar_AsDouble:
		return ExemplarValueTypeDouble
	case *otlpmetrics.Exemplar_AsInt:
		return ExemplarValueTypeInt
	}
	return ExemplarValueTypeEmpty
}

// DoubleValue returns the double associated with this Exemplar.
func (ms Exemplar) DoubleValue() float64 {
	return ms.getOrig().GetAsDouble()
}

func (ms MutableExemplar) DoubleValue() float64 {
	return ms.getOrig().GetAsDouble()
}

// SetDoubleValue replaces the double associated with this Exemplar.
func (ms MutableExemplar) SetDoubleValue(v float64) {
	ms.getOrig().Value = &otlpmetrics.Exemplar_AsDouble{
		AsDouble: v,
	}
}

// IntValue returns the int associated with this Exemplar.
func (ms Exemplar) IntValue() int64 {
	return ms.getOrig().GetAsInt()
}

func (ms MutableExemplar) IntValue() int64 {
	return ms.getOrig().GetAsInt()
}

// SetIntValue replaces the int associated with this Exemplar.
func (ms MutableExemplar) SetIntValue(v int64) {
	ms.getOrig().Value = &otlpmetrics.Exemplar_AsInt{
		AsInt: v,
	}
}

// FilteredAttributes returns the FilteredAttributes associated with this Exemplar.
func (ms Exemplar) FilteredAttributes() pcommon.Map {
	return pcommon.Map(internal.NewMap(&ms.getOrig().FilteredAttributes))
}

// FilteredAttributes returns the FilteredAttributes associated with this Exemplar.
func (ms MutableExemplar) FilteredAttributes() pcommon.MutableMap {
	return pcommon.MutableMap(internal.NewMutableMap(&ms.getOrig().FilteredAttributes))
}

// TraceID returns the traceid associated with this Exemplar.
func (ms Exemplar) TraceID() pcommon.TraceID {
	return pcommon.TraceID(ms.getOrig().TraceId)
}

// TraceID returns the traceid associated with this Exemplar.
func (ms MutableExemplar) TraceID() pcommon.TraceID {
	return pcommon.TraceID(ms.getOrig().TraceId)
}

// SetTraceID replaces the traceid associated with this Exemplar.
func (ms MutableExemplar) SetTraceID(v pcommon.TraceID) {
	ms.getOrig().TraceId = data.TraceID(v)
}

// SpanID returns the spanid associated with this Exemplar.
func (ms Exemplar) SpanID() pcommon.SpanID {
	return pcommon.SpanID(ms.getOrig().SpanId)
}

// SpanID returns the spanid associated with this Exemplar.
func (ms MutableExemplar) SpanID() pcommon.SpanID {
	return pcommon.SpanID(ms.getOrig().SpanId)
}

// SetSpanID replaces the spanid associated with this Exemplar.
func (ms MutableExemplar) SetSpanID(v pcommon.SpanID) {
	ms.getOrig().SpanId = data.SpanID(v)
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms Exemplar) CopyTo(dest MutableExemplar) {
	dest.SetTimestamp(ms.Timestamp())
	switch ms.ValueType() {
	case ExemplarValueTypeDouble:
		dest.SetDoubleValue(ms.DoubleValue())
	case ExemplarValueTypeInt:
		dest.SetIntValue(ms.IntValue())
	}

	ms.FilteredAttributes().CopyTo(dest.FilteredAttributes())
	dest.SetTraceID(ms.TraceID())
	dest.SetSpanID(ms.SpanID())
}

// CopyTo copies all properties from the current struct overriding the destination.
func (ms MutableExemplar) CopyTo(dest MutableExemplar) {
	newExemplar(ms.getOrig()).CopyTo(dest)
}
