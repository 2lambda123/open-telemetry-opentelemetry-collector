// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"errors"
	"io"
	"sort"
	"strings"
)

var ErrNotMultimatch = errors.New("this index doesn't represent a valid multimatch pattern")

type Pattern struct {
	pattern     string
	level       int
	hasWildcard bool
	valueAssign any
}

func NewPattern(pattern string, valueAssign any) Pattern {
	level := 0
	for _, c := range pattern {
		if c == '.' {
			level++
		}
	}
	wildcard := strings.Contains(pattern, "*")
	return Pattern{
		pattern:     pattern,
		level:       level,
		hasWildcard: wildcard,
		valueAssign: valueAssign,
	}
}

func (p Pattern) Match(s string) bool {
	if len(s) == 0 {
		return true
	}
	lastWildcard := -1
	patternScan := &scanner{str: p.pattern}
	strScan := &scanner{str: s}
	for !strScan.isFinished() {
		strChar, err := strScan.current()
		if err != nil {
			return false
		}
		patternChar, err := patternScan.current()
		if err != nil {
			return false
		}

		switch patternChar {
		case '*':
			if patternScan.isLast() {
				return true
			}
			patternNext, err := patternScan.peek()
			if err == nil && strChar == patternNext {
				lastWildcard = patternScan.idx
				patternScan.idx += 2
			}

		case '{':
			allowedMatches, err := patternScan.parseMultimatch()
			if err == nil {
				if !strScan.tryMultimatch(allowedMatches) {
					return false
				}
				// Breaks the switch statement
				break
			}
			// Fallthrough if the multimatch parsing failed
			fallthrough

		default:
			if strChar != patternChar {
				if lastWildcard == -1 {
					return false
				}
				patternScan.idx = lastWildcard
				lastWildcard = -1
			} else {
				patternScan.idx++
			}
		}

		strScan.idx++
	}
	return patternScan.isFinished()
}

type Patterns []Pattern

func AddPattern(ps *Patterns, p Pattern) {
	newPatterns := append(*ps, p)
	sort.SliceStable(newPatterns, func(i, j int) bool {
		if newPatterns[i].hasWildcard && newPatterns[j].hasWildcard {
			return newPatterns[i].level < newPatterns[j].level
		}
		return newPatterns[i].hasWildcard
	})
	*ps = newPatterns
}

type scanner struct {
	str string
	idx int
}

func (s *scanner) current() (rune, error) {
	if s.isFinished() {
		return 0, io.EOF
	}

	return rune(s.str[s.idx]), nil
}

func (s *scanner) peek() (rune, error) {
	if s.idx >= len(s.str)-1 {
		return 0, io.EOF
	}

	return rune(s.str[s.idx+1]), nil
}

func (s *scanner) isLast() bool {
	return s.idx == len(s.str)-1
}

func (s *scanner) isFinished() bool {
	return s.idx >= len(s.str)
}

func (s *scanner) parseMultimatch() ([]string, error) {
	current, err := s.current()
	if err != nil || current != '{' {
		return nil, ErrNotMultimatch
	}
	startIdx := s.idx
	s.idx++
	matchStrings := []string{}
	currentStr := ""
	for !s.isFinished() {
		c, err := s.current()
		if err != nil {
			return nil, err
		}

		switch c {
		case '}':
			matchStrings = append(matchStrings, currentStr)
			s.idx++
			return matchStrings, nil

		case ',':
			matchStrings = append(matchStrings, currentStr)
			currentStr = ""

		default:
			currentStr += string(c)
		}

		s.idx++
	}

	s.idx = startIdx
	return nil, ErrNotMultimatch
}

func (s *scanner) tryMultimatch(multimatch []string) bool {
	if len(multimatch) == 0 {
		return true
	}
	startIdx := s.idx
	for _, m := range multimatch {
		matchScan := &scanner{str: m}
		for !s.isFinished() {
			matchChar, err := matchScan.current()
			if err != nil {
				break
			}
			strChar, err := s.current()
			if err != nil {
				break
			}

			if matchChar != strChar {
				s.idx = startIdx
				break
			}

			matchScan.idx++
			if matchScan.isFinished() {
				return true
			}
			s.idx++
		}
	}
	return false
}

func ContainsPattern(keys []string) bool {
	for _, key := range keys {
		if strings.Contains(key, "*") || strings.Contains(key, "{") {
			return true
		}
	}
	return false
}

func ExpandPatternMap(patternMap map[string]any, matchNames []string) map[string]any {
	expandedMap := map[string]any{}
	patterns := Patterns{}

	for pattern, assign := range patternMap {
		AddPattern(&patterns, NewPattern(pattern, assign))
	}

	for _, pattern := range patterns {
		matched := []string{}
		for _, name := range matchNames {
			if pattern.Match(name) {
				matched = append(matched, name)
			}
		}
		for _, name := range matched {
			expandedMap[name] = pattern.valueAssign
		}
	}

	return expandedMap
}
