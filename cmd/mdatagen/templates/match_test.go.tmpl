// Code generated by mdatagen. DO NOT EDIT.

package {{ .Package }}

import (
	"reflect"
	"testing"
)

func TestParsePatternValid(t *testing.T) {
	testCases := []struct {
		name    string
		input   string
		pattern *pattern
	}{
		{
			name:  "basic",
			input: "*",
			pattern: &pattern{
				groups: []group{
					{
						typ: groupWildcard,
					},
				},
			},
		},
		{
			name:  "wildcard end",
			input: "x.*",
			pattern: &pattern{
				groups: []group{
					{
						typ: groupIdentifier,
						values: []string{
							"x",
						},
					},
					{
						typ: groupWildcard,
					},
				},
			},
		},
		{
			name:  "wildcard start",
			input: "*.x",
			pattern: &pattern{
				groups: []group{
					{
						typ: groupWildcard,
					},
					{
						typ: groupIdentifier,
						values: []string{
							"x",
						},
					},
				},
			},
		},
		{
			name:  "multimatch",
			input: "a_b.{one,two}",
			pattern: &pattern{
				groups: []group{
					{
						typ: groupIdentifier,
						values: []string{
							"a_b",
						},
					},
					{
						typ: groupMultimatch,
						values: []string{
							"one",
							"two",
						},
					},
				},
			},
		},
		{
			name:  "identifier wildcard and multimatch",
			input: "x.*.{first_metric,second_metric}",
			pattern: &pattern{
				groups: []group{
					{
						typ: groupIdentifier,
						values: []string{
							"x",
						},
					},
					{
						typ: groupWildcard,
					},
					{
						typ: groupMultimatch,
						values: []string{
							"first_metric",
							"second_metric",
						},
					},
				},
			},
		},
		{
			name:  "identifier multimatch and wildcard",
			input: "x.{first_metric,second_metric}.*",
			pattern: &pattern{
				groups: []group{
					{
						typ: groupIdentifier,
						values: []string{
							"x",
						},
					},
					{
						typ: groupMultimatch,
						values: []string{
							"first_metric",
							"second_metric",
						},
					},
					{
						typ: groupWildcard,
					},
				},
			},
		},
		{
			name:  "with numeric character",
			input: "x1",
			pattern: &pattern{
				groups: []group{
					{
						typ: groupIdentifier,
						values: []string{
							"x1",
						},
					},
				},
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			p, err := newPatternFromString(tc.input)
			if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}
			if !comparePatterns(p, tc.pattern) {
				t.Errorf("expected %v, got %v", tc.pattern, p)
			}
		})
	}
}

func comparePatterns(a, b *pattern) bool {
	if len(a.groups) != len(b.groups) {
		return false
	}
	for i := range a.groups {
		if a.groups[i].typ != b.groups[i].typ {
			return false
		}
		if !arrayCompare(a.groups[i].values, b.groups[i].values) {
			return false
		}
	}
	return true
}

func arrayCompare[T comparable](a, b []T) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func TestParsePatternInvalid(t *testing.T) {
	testCases := []struct {
		name  string
		input string
	}{
		{
			name:  "identifier underscore ending",
			input: "x_",
		},
		{
			name:  "identifier underscore starting",
			input: "_x",
		},
		{
			name:  "wildcard in the middle of identifier",
			input: "x*y",
		},
		{
			name:  "multimatch in the middle of identifier",
			input: "x{one,two}y",
		},
		{
			name:  "invalid character in multimatch option",
			input: "{a.b,c}",
		},
		{
			name:  "invalid ending to multimatch",
			input: "x.{a,",
		},
		{
			name:  "invalid start to multimatch",
			input: "x.b}",
		},
		{
			name:  "starts with .",
			input: ".x",
		},
		{
			name:  "ends with .",
			input: "x.",
		},
		{
			name:  "random character",
			input: "x.f^fl.x",
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			_, err := newPatternFromString(tc.input)
			// Use -v to check out the error message.
			t.Logf("error output:\n---\n%v\n---\n", err)
			if err == nil {
				t.Fatalf("expected error, got nil")
			}
		})
	}
}

func TestMatchNames(t *testing.T) {
	testCases := []struct {
		name            string
		pattern         string
		names           []string
		expectedMatches []string
		expectError     bool
	}{
		{
			name:            "simple match",
			pattern:         "a",
			names:           []string{"a"},
			expectedMatches: []string{"a"},
		},
		{
			name:            "simple wildcard match",
			pattern:         "*",
			names:           []string{"a", "a.a", "a.a.a"},
			expectedMatches: []string{"a", "a.a", "a.a.a"},
		},
		{
			name:            "simple multimatch",
			pattern:         "a.{b,c}",
			names:           []string{"a.b", "a.c", "a.d"},
			expectedMatches: []string{"a.b", "a.c"},
		},
		{
			name:            "wildcard match in prefix",
			pattern:         "*.a",
			names:           []string{"a", "b.a", "c.a"},
			expectedMatches: []string{"b.a", "c.a"},
		},
		{
			name:            "wildcard and multimatch",
			pattern:         "a.{b,c,d}.*",
			names:           []string{"a.b.a", "a.c.x", "a.d.c.d.f", "a.e.x"},
			expectedMatches: []string{"a.b.a", "a.c.x", "a.d.c.d.f"},
		},
		{
			name:            "shorter name than pattern",
			pattern:         "{b,c}",
			names:           []string{"a.b", "a.c"},
			expectedMatches: []string{},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			p, err := newPatternFromString(tc.pattern)
			if err != nil {
				t.Fatalf("failed to parse pattern: %v", err)
			}
			matches, err := matchNames(p, tc.names)
			if tc.expectError && err == nil {
				t.Fatalf("expected error, got none")
			} else {
				if !arrayCompare(matches, tc.expectedMatches) {
					t.Fatalf("expected %v, got %v", tc.expectedMatches, matches)
				}
			}
		})
	}
}

func TestPatternPriorityAndDeterminism(t *testing.T) {
	testCases := []struct {
		name          string
		patterns      []string
		expectedOrder []string
	}{
		{
			name:          "less groups applied first",
			patterns:      []string{"b.a", "a"},
			expectedOrder: []string{"a", "b.a"},
		},
		{
			name:          "earlier matcher applied first",
			patterns:      []string{"a.*", "*.a", "*.*.a", "a.a.*"},
			expectedOrder: []string{"*.a", "a.*", "*.*.a", "a.a.*"},
		},
		{
			name:          "wildcard before multimatch",
			patterns:      []string{"{a,b}.*", "*.{a,b}"},
			expectedOrder: []string{"*.{a,b}", "{a,b}.*"},
		},
		{
			name:          "lexicographical order",
			patterns:      []string{"b", "c", "a"},
			expectedOrder: []string{"a", "b", "c"},
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			testPatternPriorityOrder(t, tc.patterns, tc.expectedOrder)
		})
	}
}

func stringsToPatternBlocks(t *testing.T, patterns []string) patternBlocks {
	t.Helper()

	ptBlocks := patternBlocks{}
	for _, p := range patterns {
		ptStrBlock := patternStringBlock{ptStr: p}
		ptBlock, err := patternBlockFromStringBlock(ptStrBlock)
		if err != nil {
			t.Fatalf("failed to parse pattern: %v", err)
		}
		ptBlocks.add(ptBlock)
	}
	return ptBlocks
}

func testPatternPriorityOrder(t *testing.T, input []string, expectedOrder []string) {
	t.Helper()

	ptBlocks := stringsToPatternBlocks(t, input)
	resultOrder := []string{}
	for _, ptBlock := range ptBlocks {
		resultOrder = append(resultOrder, ptBlock.pt.originalStr)
	}
	if !arrayCompare(resultOrder, expectedOrder) {
		t.Fatalf("expected %v, got %v", expectedOrder, resultOrder)
	}
}

var httpMetrics = []string{
	"http.server.request.duration",
	"http.server.active_requests",
	"http.server.request.body.size",
	"http.server.response.body.size",
	"http.client.request.duration",
	"http.client.request.body.size",
	"http.client.response.body.size",
	"http.client.open_connections",
	"http.client.connection.duration",
	"http.client.active_requests",
}

func TestApplicationScenarios(t *testing.T) {
	testCases := []struct {
		name            string
		patterns        map[string]any
		names           []string
		expectedMatches map[string]any
	}{
		{
			name: "simple match",
			patterns: map[string]any{
				"a": 1,
			},
			names: []string{"a"},
			expectedMatches: map[string]any{
				"a": 1,
			},
		},
		{
			name:  "http metrics wildcard",
			names: httpMetrics,
			patterns: map[string]any{
				"*":             0,
				"http.client.*": 1,
			},
			expectedMatches: map[string]any{
				"http.server.request.duration":    0,
				"http.server.active_requests":     0,
				"http.server.request.body.size":   0,
				"http.server.response.body.size":  0,
				"http.client.request.duration":    1,
				"http.client.request.body.size":   1,
				"http.client.response.body.size":  1,
				"http.client.open_connections":    1,
				"http.client.connection.duration": 1,
				"http.client.active_requests":     1,
			},
		},
		{
			name:  "http metrics complex",
			names: httpMetrics,
			patterns: map[string]any{
				"http.*.{request,response}.body.size": 1,
			},
			expectedMatches: map[string]any{
				"http.client.request.body.size":  1,
				"http.client.response.body.size": 1,
				"http.server.request.body.size":  1,
				"http.server.response.body.size": 1,
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result, err := expandPatternMap(tc.patterns, tc.names)
			if err != nil {
				t.Fatalf("failed to match: %v", err)
			}
			if !reflect.DeepEqual(result, tc.expectedMatches) {
				t.Fatalf("expected %v, got %v", tc.expectedMatches, result)
			}
		})
	}
}
